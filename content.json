{"meta":{"title":"AIR PAN","subtitle":"NOTE","description":"Waiting....","author":"Ðυ₭","url":"http://yoursite.com","root":"/"},"pages":[{"title":"「Air Pan」","date":"2019-05-21T23:56:51.000Z","updated":"2019-07-21T04:26:44.191Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Blog 记录自己的成长 研究技术、分享心得 行万里，阅万卷 Blogger 入门级 运维攻城狮 Contact Eamil: 1062351852@qq.com document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","author":"「Air Pan」"},{"title":"tags","date":"2019-05-21T23:57:08.000Z","updated":"2019-07-21T10:14:31.429Z","comments":false,"path":"books/index.html","permalink":"http://yoursite.com/books/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"categories","date":"2019-05-22T01:00:50.000Z","updated":"2019-07-20T15:33:26.765Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"「Air Pan」","date":"2019-05-21T23:56:51.000Z","updated":"2019-07-16T12:30:23.059Z","comments":true,"path":"laboratory/index.html","permalink":"http://yoursite.com/laboratory/index.html","excerpt":"","text":"Blog 记录自己的成长 研究技术、分享心得 行万里，阅万卷 Blogger 入门级 运维攻城狮 Contact Eamil: 1062351852@qq.com document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","author":"「Air Pan」"},{"title":"schedule","date":"2019-05-21T23:58:27.000Z","updated":"2019-05-21T23:58:27.700Z","comments":true,"path":"schedule/index.html","permalink":"http://yoursite.com/schedule/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"tags","date":"2019-05-21T23:57:08.000Z","updated":"2019-07-20T15:32:34.047Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"WordPress个人博客搭建「一」","slug":"WordPress/01.WordPress","date":"2019-05-25T10:11:07.000Z","updated":"2019-07-21T01:21:36.763Z","comments":true,"path":"2019/05/25/WordPress/01.WordPress/","link":"","permalink":"http://yoursite.com/2019/05/25/WordPress/01.WordPress/","excerpt":"","text":"简介一步一步教你基于WordPress搭建自己的个人博客，WordPress作为成熟的CMS框架，美观，方便，插件多，更新频繁，非常适合个人博客与网站的搭建，无需太多的代码基础。 购买VPS购买云服务器为了搭建个人网站，首先肯定需要一个云服务器国内的推荐腾讯云，毕竟大公司，工单服务贼及时！还送免费的CDN加速流量 购买域名有了云服务器，还需要一个域名。国内的域名需要备案，购买的话阿里云腾讯云都可以。 搭建Apache+MySQL+PHP7环境这一部分介绍如何在Centos7 上配置Apache+MySQL+PHP7. 安装Apache yum install httpd httpd-devel 安装MySQL在CentOS7 中默认安装有MariaDB，这个是MySQL的分支，还是要在系统中安装MySQL，而且安装完成之后可以直接覆盖掉MariaDB 下载MySQL官方的 Yum Repository 并安装MySQL。[root@localhost ~]# wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm[root@localhost ~]# yum -y install mysql57-community-release-el7-10.noarch.rpm[root@localhost ~]# yum -y install mysql-community-server MySQL 设置找出初始的root用户的密码，通过如下命令可以在日志文件中找出密码：[root@localhost ~]# grep “password” /var/log/mysqld.log2019-05-19T00:42:03.830587Z 1 [Note] A temporary password is generated for root@localhost: 5&vPo_Vej1GZ如下命令进入数据库：[root@localhost ~]# mysql -uroot -p输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库：mysql> ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘new password’; 安装PHP 安装php 检查当前安装的PHP包yum list installed | grep php如果有安装的PHP包，先删除他们 更新yum 源rpm -Uvh http://mirror.webtatic.com/yum/el5/latest.rpm ##CentOs 5.xrpm -Uvh http://mirror.webtatic.com/yum/el6/latest.rpm ##CentOs 6.xrpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm ##CentOs 7.Xrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm 安装yum install php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_64 测试PHP[root@localhost ~]# cd /var/www/html/[root@localhost html]# vi info.php 1234567891011测试：curl -I http://localhost/info.phpHTTP/1.1 200 OKDate: Sat, 25 May 2019 01:06:40 GMTServer: Apache/2.4.6 (CentOS) PHP/7.0.33X-Powered-By: PHP/7.0.33Content-Type: text/html; charset=UTF-8 基于LAMP 部署WordPress安装WordPress 下载WordPress直接通过wget命令去它官网下载最新的版本（英文）：wget http://wordpress.org/latest.tar.gz下载中文wordpress-5.0.3:wget https://cn.wordpress.org/wordpress-5.0.3-zh_CN.tar.gztar -xzvf wordpress-5.0.3-zh_CN.tar.gz 创建WordPress操作的数据库和用户 创建数据库：CREATE DATABASE wordpress; 配置权限：GRANT ALL PRIVILEGES ON wordpress.* TO wordpress@localhost IDENTIFIED BY ‘your password’;FLUSH PRIVILEGES; 配置WordPress 修改配置文件wordpress/wp-config-sample.php修改的内容包括DB_NAME，DB_USER，DB_PASSWORD以及下面的唯一key 1234define( 'DB_NAME', 'wordpress' );define( 'DB_USER', 'wordpress' );define( 'DB_PASSWORD', 'WordPress@1234' );define( 'DB_HOST', 'localhost' ); 拷贝WordPress源码至网站根目录rm -rf /var/www/htmlcp -r wordpress/* /var/www/mv wordpress html 安装WordPress访问你的ip或者是域名应该就是这样子的了：http://x.x.x.x/wp-admin/install.php 根据提示安装并登录安装WordPress -> 数据库信息 -> 站点、用户、邮箱 ->登陆 后台管理输入“域名/wp-admin/”或“公网ip/wp-admin/”，就可以进入网站的后台管理页面了： 访问你的IP或者域名，一个初始的博客就搭建好了~： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"博客","slug":"博客","permalink":"http://yoursite.com/categories/博客/"}],"tags":[{"name":"Wordpress","slug":"Wordpress","permalink":"http://yoursite.com/tags/Wordpress/"}],"author":"DU"},{"title":"Python 的常用模块","slug":"Python/03.High-level/03.Pyhton的常用模块","date":"2019-05-20T10:11:07.000Z","updated":"2019-07-21T01:21:36.771Z","comments":true,"path":"2019/05/20/Python/03.High-level/03.Pyhton的常用模块/","link":"","permalink":"http://yoursite.com/2019/05/20/Python/03.High-level/03.Pyhton的常用模块/","excerpt":"","text":"常用模块 calendar time datetime timeit os shutil 归档 zip random string 上述所有模块使用理论上都应该先导入，string是特例 calendar 跟日历相关的模块 time模块 时间戳一个时间表示，根据不同语言，可以是整数或者浮点数是从1970年1月1日0时0分0秒到现在经历的秒数如果表示的时间是1970年以前或者太遥远的未来，可能出现异常32位操作系统能够支持到2038年 UTC时间UTC又称为世界协调时间，以英国的格林尼治天文所在地区的时间作为参考的时间，也叫做世界标准时间。中国时间是 UTC+8 东八区 夏令时夏令时就是在夏天的时候将时间调快一小时，本意是督促大家早睡早起节省蜡烛！ 每天变成25个小时，本质没变还是24小时 时间元组 一个包含时间内容的普通元组 索引 内容 属性 值 0 年 tm_year 2015 1 月 tm_mon 1～12 2 日 tm_mday 1～31 3 时 tm_hour 0～23 4 分 tm_min 0～59 5 秒 tm_sec 0～61 60表示闰秒 61保留值 6 周几 tm_wday 0～6 7 第几天 tm_yday 1～366 8 夏令时 tm_isdst 0，1，-1（表示夏令时） 时间模块的属性 timezone: 当前时区和UTC时间相差的秒数，在没有夏令时的情况下的间隔,东八区的是 -28800 altzone 获取当前时区与UTC时间相差的秒数，在有夏令时的情况下， daylight 测当前是否是夏令时时间状态, 0 表示是。time.daylight 时间模块的方法 time.time()返回值: 时间戳 localtime() 得到当前时间的时间结构t = time.localtime()print(t.tm_hour) asctime() 返回元组的正常字符串化之后的时间格式格式：time.asctime（时间元组）返回值:字符串 Tue Jun 6 11:11:00 2017t = time.localtime()tt = time.asctime(t) ctime: 获取字符串化的当前时间格式：time.ctime()返回值：字符串 Mon Mar 26 20:46:30 2018t = time.ctime() mktime() 使用时间元组获取对应的时间戳格式：time.mktime（时间元组）返回值：浮点数时间戳lt = time.localtime()ts = time.mktime(lt) sleep: 使程序进入睡眠，n秒后继续格式：sleep(5) clock() 获取CPU时间格式：time.clock() strftime:将时间元组转化为自定义的字符串格式 123456789101112131415161718192021222324252627格式 含义 备注%a 本地（locale）简化星期名称 %A 本地完整星期名称 %b 本地简化月份名称 %B 本地完整月份名称 %c 本地相应的日期和时间表示 %d 一个月中的第几天（01 - 31） %H 一天中的第几个小时（24 小时制，00 - 23） %I 一天中的第几个小时（12 小时制，01 - 12） %j 一年中的第几天（001 - 366） %m 月份（01 - 12） %M 分钟数（00 - 59） %p 本地 am 或者 pm 的相应符 注1%S 秒（01 - 61） 注2%U 一年中的星期数（00 - 53 星期天是一个星期的开始）第一个星期天之前的所有天数都放在第 0 周 注3%w 一个星期中的第几天（0 - 6，0 是星期天） 注3%W 和 %U 基本相同，不同的是 %W 以星期一为一个星期的开始 %x 本地相应日期 %X 本地相应时间 %y 去掉世纪的年份（00 - 99） %Y 完整的年份 %z 用 +HHMM 或 -HHMM 表示距离格林威治的时区偏移（H 代表十进制的小时数，M 代表十进制的分钟数） %% %号本身# 把时间表示成: 2018年3月26日 21:05t = time.localtime()ft = time.strftime(\"%Y年%m月%d日 %H:%M\" , t) datetime 模块 datetinme 提供日期和时间的运算和表示 类方法 datetime.today()返回当前本地datetime. datetime.fromtimestamp(time.time()). datetime.now([tz])返回当前本地日期和时间,如果可选参数tz为None或没有详细说明,这个方法会像today(). datetime.utcnow()返回当前的UTC日期和时间, 如果tzinfo None ,那么与now()类似. datetime.fromtimestamp(timestamp[, tz])根据时间戳返回本地的日期和时间.tz指定时区. datetime.utcfromtimestamp(timestamp)根据时间戳返回 UTC datetime. datetime.fromordinal(ordinal)根据Gregorian ordinal 返回datetime. datetime.combine(date, time)根据date和time返回一个新的datetime. datetime.strptime(date_string, format)根据date_string和format返回一个datetime. 实例方法 datetime.date()返回相同年月日的date对象. datetime.time()返回相同时分秒微秒的time对象. datetime.replace(kw)kw in [year, month, day, hour, minute, second, microsecond, tzinfo], 与date类似. 类属性 datetime.min: datetime(MINYEAR, 1, 1). datetime.max: datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999). 实例属性(read-only) datetime.year: 1 至 9999 datetime.month: 1 至 12 datetime.day: 1 至 n datetime.hour: In range(24). 0 至 23 datetime.minute: In range(60). datetime.second: In range(60). datetime.microsecond: In range(1000000). timeit-时间测量工具 测量程序运行时间间隔实验 12345678910111213141516171819import timeit# 生成列表两种方法的比较# 如果单纯比较生成一个列表的时间，可能很难实现c = '''sum = []for i in range(1000): sum.append(i) # 利用timeit调用代码，执行100000次，查看运行时间t1= timeit.timeit(stmt=\"[i for i in range(1000)]\", number=100000 )# 测量代码c执行100000次运行结果t2 = timeit.timeit(stmt=c, number=100000)print(t1)print(t2)2.68340802099919536.945136217000254 timeit 可以执行一个函数，来测量一个函数的执行时间 12345678910111213141516171819202122232425262728293031def doIt(): num = 3 for i in range(num): print(\"Repeat for {0}\".format(i)) # 执行函数，重复10次t = timeit.timeit(stmt=doIt, number=10)print(t)s = '''def doIt(num): for i in range(num): print(\"Repeat for {0}\".format(i))'''# 执行doIt(num)# setup负责把环境变量准备好# 实际相当于给timeit创造了一个小环境# 在创作的小环境中， 代码执行的顺序大致是'''def doIt(num): ..... num = 3doIt(num)'''t = timeit.timeit(\"doIt(num)\", setup=s+\"num=3\", number=10)print(t) os - 操作系统相关 跟操作系统相关，主要是文件操作 于系统相关的操作，主要包含在三个模块里 os， 操作系统目录相关 os.path, 系统路径相关操作 shutil， 高级文件操作，目录树的操作，文件赋值，删除，移动 路径： 绝对路径： 总是从根目录上开始 相对路径： 基本以当前环境为开始的一个相对的地方 import os os 模块 getcwd() 获取当前的工作目录格式：os.getcwd()返回值：当前工作目录的字符串 chdir() 改变当前的工作目录格式：os.chdir（路径）返回值：无 listdir() 获取一个目录中所有子目录和文件的名称列表格式:os.listdir(路径)返回值：所有子目录和文件名称的列表 makedirs（） 递归创建文件夹格式：os.makedirs(递归路径)返回值：无递归路径：多个文件夹层层包含的路径就是递归路径 例如 ‘a/b/c…’ system() 运行系统shell命令格式：os.system(系统命令)返回值：打开一个shell或者终端界面一般推荐使用subprocess代替 12rst = os.system(\"ls\")print(rst) getenv() 获取指定的系统环境变量值相应的还有putenv格式：os.getenv(‘环境变量名’)返回值：指定环境变量名对应的值 值部分 os.curdir: curretn dir,当前目录 os.pardir: parent dir， 父亲目录 os.sep: 当前系统的路径分隔符 windows: “\\” linux: “/“ os.linesep: 当前系统的换行符号 windows: “\\r\\n” unix,linux,macos: “\\n” os.name： 当前系统名称 windows： nt mac，unix，linux： posix os.path 模块,路径相关的模块 abspath() 将路径转化为绝对路径格式:os.path.abspath(‘路径’)返回值：路径的绝对路径形式 basename() 获取路径中的文件名部分格式:os.path.basename(路径)返回值：文件名字符串 join() 将多个路径拼合成一个路径格式：os.path.join(路径1，路径2….)返回值：组合之后的新路径字符串 split() 将路径切割为文件夹部分和当前文件部分格式:os.path.split（路径）返回值：路径和文件名组成的元组 12345678t = op.split(\"/home/tlxy/dana.haha\")print(t)d,p = op.split(\"/home/tlxy/dana.haha\")print(d, p)('/home/tlxy', 'dana.haha')/home/tlxy dana.haha isdir() 检测是否是目录格式：os.path.isdir(路径)返回值：布尔值 jexists() 检测文件或者目录是否存在格式：os.path.exists(路径)返回值:布尔值 shutil copy() 复制文件格式：shutil.copy(来源路径，目标路径)返回值：返回目标路径拷贝的同时，可以给文件重命名 copy2() 复制文件,(保留元数据文件信息）格式：shutil.copy2(来源路径，目标路径)返回值：返回目标路径注意：copy和copy2的唯一区别在于copy2复制文件时尽量保留元数据 copyfile()将一个文件中的内容复制到另外一个文件当中格式：shutil.copyfile（’源路径’,’目标路径’)返回值：无 move() 移动文件/文件夹格式：shutil.move(源路径，目标路径)返回值：目标路径 归档 归档： 把多个文件或者文件夹合并到一个文件当中 make_archive() 归档操作格式:shutil.make_archive(‘归档之后的目录和文件名’,’后缀’,’需要归档的文件夹’)返回值：归档之后的地址 12345#help(shutil.make_archive)# 是想得到一个叫做tuling.zip的归档文件rst = shutil.make_archive(\"/home/tlxy/tuling\", \"zip\", \"/home/tlxy/dana\")print(rst) # /home/tlxy/tuling.zip unpack_archive() 解包操作格式：shutil.unpack_archive(‘归档文件地址’,’解包之后的地址’)返回值：解包之后的地址 zip - 压缩包 压缩： 用算法把多个文件或者文件夹无损或者有损合并到一个文件当中 模块名称叫 zipfile zipfile.ZipFile(file[, mode[, compression[, allowZip64]]]) 1234# 创建一个ZipFile对象，表示一个zip文件。参数file表示文件的路径或类文件对象(file-like object)；参数mode指示打开zip文件的模式，默认值为’r’，表示读已经存在的zip文件，也可以为’w’或’a’，’w’表示新建一个zip文档或覆盖一个已经存在的zip文档，’a’表示将数据附加到一个现存的zip文档中。参数compression表示在写zip文档时使用的压缩方法，它的值可以是zipfile. ZIP_STORED 或zipfile. ZIP_DEFLATED。如果要操作的zip文件大小超过2G，应该将allowZip64设置为True。# 对/home/tlxy/tuling.zip压缩zf = zipfile.ZipFile(\"/home/tlxy/tuling.zip\") ZipFile.getinfo(name):获取zip文档内指定文件的信息。返回一个zipfile.ZipInfo对象，它包括文件的详细信息。 1234rst = zf.getinfo(\"dana.haha\")print(rst) ZipFile.namelist()获取zip文档内所有文件的名称列表。 123456nl = zf.namelist()# ZipFile.extractall([path[, members[, pwd]]])# 解压zip文档中的所有文件到当前目录。参数members的默认值为zip文档内的所有文件名称列表，也可以自己设置，选择要解压的文件名称。rst = zf.extractall(\"/home/tlxy/dana\") random 随机数 所有的随机模块都是伪随机 random() 获取0-1之间的随机小数格式：random.random()返回值：随机0-1之间的小数 choice() 随机返回序列中的某个值格式：random.choice(序列)返回值：序列中的某个值 shuffle() 随机打乱列表格式：random.shuffle(列表)返回值：打乱顺序之后的列表 randint(a,b): 返回一个a到b之间的随机整数，包含a和b document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"author":"DU"},{"title":"Python 的异常处理","slug":"Python/03.High-level/02.Python的异常处理","date":"2019-05-14T10:11:07.000Z","updated":"2019-07-21T07:00:42.611Z","comments":true,"path":"2019/05/14/Python/03.High-level/02.Python的异常处理/","link":"","permalink":"http://yoursite.com/2019/05/14/Python/03.High-level/02.Python的异常处理/","excerpt":"","text":"异常 异常的分类 异常处理 异常手动抛出 自定义异常 异常的分类AssertError 断言语句（assert）失败 AttributeError 尝试访问未知的对象属性 EOFError 用户输入文件末尾标志EOF（Ctrl+d） FloatingPointError 浮点计算错误 GeneratorExit generator.close()方法被调用的时候 ImportError 导入模块失败的时候 IndexError 索引超出序列的范围 KeyError 字典中查找一个不存在的关键字 KeyboardInterrupt 用户输入中断键（Ctrl+c） MemoryError 内存溢出（可通过删除对象释放内存） NameError 尝试访问一个不存在的变量 NotImplementedError 尚未实现的方法 OSError 操作系统产生的异常（例如打开一个不存在的文件） OverflowError 数值运算超出最大限制 ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象 RuntimeError 一般的运行时错误 StopIteration 迭代器没有更多的值 SyntaxError Python的语法错误 IndentationError 缩进错误 TabError Tab和空格混合使用 SystemError Python编译器系统错误 SystemExit Python编译器进程被关闭 TypeError 不同类型间的无效操作 UnboundLocalError 访问一个未初始化的本地变量（NameError的子类） UnicodeError Unicode相关的错误（ValueError的子类） UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类） UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类） UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类） ValueError 传入无效的参数 ZeroDivisionError 除数为零 异常处理 不能保证程序永远正确运行 但是，必须保证程序在最坏的情况下得到的问题被妥善处理 python的异常处理模块全部语法为： try: 尝试实现某个操作， 如果没出现异常，任务就可以完成 如果出现异常，将异常从当前代码块扔出去尝试解决异常 except 异常类型1: 解决方案1：用于尝试在此处处理异常解决问题 except 异常类型2： 解决方案2：用于尝试在此处处理异常解决问题 except (异常类型1,异常类型2...) 解决方案：针对多个异常使用相同的处理方式 excpet: 解决方案：所有异常的解决方案 else: 如果没有出现任何异常，将会执行此处代码 finally: 管你有没有异常都要执行的代码 流程 执行try下面的语句 如果出现异常，则在except语句里查找对应异常病进行处理 如果没有出现异常，则执行else语句内容 最后，不管是否出现异常，都要执行finally语句 除except(最少一个)以外，else和finally可选123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475# 简单异常案例1:try: num = int(input(\"Plz input your number:\")) rst = 100/num print(\"计算结果是： {0}\".format(rst))except: print(\"你特娘的输入的啥玩意儿\") # exit是退出程序的意思 exit() Plz input your number:0你特娘的输入的啥玩意儿 # 简单异常案例2:# 给出提示信息try: num = int(input(\"Plz input your number:\")) rst = 100/num print(\"计算结果是： {0}\".format(rst))# 捕获异常后，把异常实例化，出息信息会在实例里# 注意以下写法# 以下语句是捕获ZeroDivisionError异常并实例化实例eexcept ZeroDivisionError as e: print(\"你特娘的输入的啥玩意儿\") print(e) # exit是退出程序的意思 exit() Plz input your number:0你特娘的输入的啥玩意儿division by zero# 简单异常案例3:# 给出提示信息try: num = int(input(\"Plz input your number:\")) rst = 100/num print(\"计算结果是： {0}\".format(rst))# 如果是多种error的情况# 需要把越具体的错误，越往前放# 在异常类继承关系中，越是子类的异常，越要往前放，# 越是父亲类的异常，越要往后放# 在处理异常的时候，一旦拦截到某一个异常，则不在继续往下查看，直接进行下一个# 代码，即有finally则执行finally语句块，否则就执行下一个大的语句except ZeroDivisionError as e: print(\"你特娘的输入的啥玩意儿\") print(e) # exit是退出程序的意思 exit()except NameError as e: print(\"名字起错了\") print(e)except AttributeError as e: print(\"好像属性有问题\") print(e) exit() # 所有异常都是继承自Exception# 如果写上下面这句话，任何异常都会拦截住# 而且，下面这句话一定是最后一个exceptionexcept Exception as e: print(\"我也不知道就出错了\") print(e) except ValueError as e: print(\"NO>>>>>>>>>>>>>>>>>>\") Plz input your number:rerer我也不知道就出错了invalid literal for int() with base 10: 'rerer' 用户手动引发异常 当某些情况，用户希望自己引发一个异常的时候，可以使用 raise 关键字来引发异常1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162# raise案例-1try: # 手动引发一个异常 # 注意语法： raise errorclassname raise ValueError print(\"还没完呀\")except NameError as e: print(\"NameError\")except ValueError as e: print(\"ValueError\")except Exception as e: print(\"有异常\")finally: print(\"我肯定会被执行的\") ValueError我肯定会被执行的# raise案例-2# 自己定义异常# 需要注意： 自定义异常必须是系统异常的子类class DanaValueError(ValueError): passtry: # 手动引发一个异常 # 注意语法： raise errorclassname raise DanaValueError print(\"还没完呀\")except NameError as e: print(\"NameError\")except ValueError as e: print(\"ValueError\")except Exception as e: print(\"有异常\")finally: print(\"我肯定会被执行的\") ValueError我肯定会被执行的 # else语句案例:try: num = int(input(\"Plz input your number:\")) rst = 100/num print(\"计算结果是： {0}\".format(rst))except Exception as e: print(\"Exception\") else: print(\"No Exception\")finally: print(\"反正我会被执行\")Plz input your number:ghhjException反正我会被执行 关于自定义异常 只要是raise异常，则推荐自定义异常 在自定义异常的时候，一般包含以下内容： 自定义发生异常的异常代码 自定义发生异常后的问题提示 自定义发生异常的行数 最终的目的是，一旦发生异常，方便程序员快速定位错误现场 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"author":"DU"},{"title":"Python 的模块和包","slug":"Python/03.High-level/01.Python的模块和包","date":"2019-05-10T10:11:07.000Z","updated":"2019-07-21T01:21:36.769Z","comments":true,"path":"2019/05/10/Python/03.High-level/01.Python的模块和包/","link":"","permalink":"http://yoursite.com/2019/05/10/Python/03.High-level/01.Python的模块和包/","excerpt":"","text":"Python 的模块和包 模块 包 命名空间 模块 一个模块就是一个包含pytho代码的文件， 后缀名成是.py就可以，模块就是个python文件 为什么我们用模块程序太大，编写维护非常不方便，需要拆分模块可以增加代码重复利用的方式当做命名空间使用，避免命名冲突 如何定义模块模块就是一个普通文件，所以任何代码可以直接书写不过根据模块的规范，最好在模块中编写以下内容：函数（单一功能）类（相似功能的组合，或者类似业务模块）测试代码 如何使用模块模块直接导入 123import module_namemodule_name.function_namemodule_name.class_name 假如模块名称直接以数字开头，借助importlib帮助 12345678# 借助于importlib包可以实现导入以数字开头的模块名称import importlib# 相当于导入了一个叫01的模块并把导入模块赋值给了tulingtuling = importlib.import_module(\"01\")stu = tuling.Student()stu.say() import 模块 as 别名from module_name import func_name, class_name按上述方法有选择性的导入使用的时候可以直接使用导入的内容，不需要前缀 from module_name import *导入模块所有内容 if __name__ == \"__main__ 的使用可以有效避免模块代码被导入的时候被动执行的问题建议所欲程序的入口都以此代码为入口 模块的搜索路径和存储 什么是模块的搜索路径：加载模块的时候，系统会在那些地方寻找此模块 系统默认的模块搜索路径 12import syssys.path 属性可以获取路径列表 添加搜索路径: sys.path.append(dir) 模块的加载顺序搜索内存中已经加载好的模块搜索python的内置模块搜索sys.path路径 包 包是一种组织管理代码的方式，包里面存放的是模块- 用于将模块包含在一起的文件夹就是包 自定义包的结构 |---包 |---|--- __init__.py 包的标志文件 |---|--- 模块1 |---|--- 模块2 |---|--- 子包(子文件夹) |---|---|--- __init__.py 包的标志文件 |---|---|--- 子包模块1 |---|---|--- 子包模块2 包的导入操作import package_name直接导入一个包，可以使用init.py中的内容使用方式是： 12package_name.func_namepackage_name.class_name.func_name() import package_name as p注意:此种方法是默认对init.py内容的导入 import package.module导入包中某一个具体的模块使用方法 123package.module.func_namepackage.module.class.fun()package.module.class.var import package.module as pm from … import 导入from package import module1, module2, module3此种导入方法不执行__init__的内容 from package import *导入当前包 __init__.py文件中所有的函数和类使用方法 123func_name()class_name.func_name()class_name.var from package.module import *导入包中指定的模块的所有内容使用方法 12func_name()class_name.func_name() 在开发环境中经常会所以用其他模块，可以在当前包中直接导入其他模块中的内容 import 完整的包或者模块的路径 __all__ 的用法在使用from package import 的时候， 可以导入的内容 __init__.py中如果文件为空， 或者没有 __all__， 那么只可以把__init__中的内容导入 __init__ 如果设置了__all__的值，那么则按照__all__ 指定的子包或者模块进行加载 如此则不会载入__init__中的内容 __all__=['module1', 'module2', 'package1'.........] 命名空间 用于区分不同位置不同功能但相同名称的函数或者变量的一个特定前缀 作用是防止命名冲突123setName()Student.setName()Dog.setName() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"author":"DU"},{"title":"Ansible 基础 「一」","slug":"Ansible/01.ansible","date":"2019-05-08T10:11:07.000Z","updated":"2019-07-21T01:21:36.765Z","comments":true,"path":"2019/05/08/Ansible/01.ansible/","link":"","permalink":"http://yoursite.com/2019/05/08/Ansible/01.ansible/","excerpt":"","text":"ansible 简介ansible 系统架构ansible简介ansible是新出现的自动化运维工具，ansible是一个配置管理和应用部署工具,基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric.SaltStack ）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。ansible是基于模块工作的，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架,根据官方提供的信息，当前使用ansible的用户有:美国国家航空航天局（NASA /ˈnæsə/）evernote(印象笔记),rackspace(全球三大云计算中心之一),atlassian,twitter(全球互联网上访问量最大的十个网站之一)等 ansible在生产环境当中的应用自动化部署应用自动化管理配置自动化持续交付自动化(aws)云服务器管理 ansible的优点 ansible糅合了众多老牌运维工具的优点，基本上pubbet和saltstack能实现的功能全部能实现 轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可； ansible是一个工具，ansible不需要启动服务，仅仅只是一个工具，可以轻松的实现分布式扩展 批量任务执行可以写成脚本，而且不用分发到远程就可以执行 ansible是一致性，高可靠性，安全性设计的轻量级自动化工具 使用python编写，维护更简单，ruby语法过于复杂； 特性 no agents：不需要在被管控主机上安装任何客户端； no server：无服务器端，使用时直接运行命令即可； modules in any languages：基于模块工作，可使用任意语言开发模块； yaml，not code：使用yaml语言定制剧本playbook； ssh by default：基于SSH工作； strong multi-tier solution：可实现多级指挥。 ansible的基本架构 连接插件(connectior plugins) 用于连接主机 用来连接被管理端 核心模块(core modules) 连接主机实现操作， 它依赖于具体的模块来做具体的事情 自定义模块(custom modules) 根据自己的需求编写具体的模块 插件(plugins) 完成模块功能的补充 playbooks(剧本) ansible的配置文件,将多个任务定义在剧本中，由ansible自动执行 host inventory（主机清单）定义ansible需要操作主机的范围 最重要的一点是 ansible是模块化的 它所有的操作都依赖于模块比如我需要创建一个文件 那么我就需要调用file模块 我需要copy文件，那么我就需要copy模块我需要测试机器的存活率，那么就需要ping模块，例如：ansible all -m ping ansible安装ansible只是一个进程 不需要添加数据库也不需要启动和运行守护进程它只是一个进程你可以轻松使用它安装在任何一点主机上面（除了windows）ansible管理机不能安装到windows上面版本的选择 因为2.0有非常大的改进 一般都会使用2.0以上的版本控制机的要求 因为ansible是python写的 所以需要在安装了python2.6或者2.7以上的python版本才可以安装管理节点的要求 需要安装ssh python版本在2.5以上 安装有3个方式 yum -y install ansiblewget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-6.repo（下载yum源） pip install ansible 从github下载 1234$ git clone git：//github.com/ansible/ansible.git --recursive$ cd ./ansible$ make rpm$ sudo rpm -Uvh ./rpm-build/ansible-*.noarch.rpm 任务执行模式ansible系统由控制主机对被管节点的操作方式有两种ad_hoc和playbook ad_hoc单命令模式 可以对多台主机执行单个命令ansible all -a “/bin/echo hello” playbook通过多个tasks的集合完成一类功能如web的安装部署，数据库服务器的批量备份等 123456789101112131415161718---- hosts: webservers vars: http_port: 80 max_clients: 200 remote_user: root tasks: - name: ensure apache is at the latest version yum: name=httpd state=latest - name: write the apache config file template: src=/srv/httpd.j2 dest=/etc/httpd.conf notify: - restart apache - name: ensure apache is running (and enable it at boot) service: name=httpd state=started enabled=yes handlers: - name: restart apache service: name=httpd state=restarted ansible的七个指令：ansible、ansible-doc、ansible-galaxy、ansible-lint、ansible-playbook、ansible-pull、ansible-vault 。这里我们只查看usage部分，详细部分可以通过 “指令 -h” 的方式获取。 ansible[root@localhost ~]# ansible -hUsage: ansible [options]ansible是指令核心部分，其主要用于执行ad-hoc命令，即单条命令。默认后面需要跟主机和选项部分，默认不指定模块时，使用的是command模块。如：[root@VM_0_2_centos ~]# ansible 127.0.0.1 -a “date”127.0.0.1 | CHANGED | rc=0 >>Sun Jun 2 18:32:30 CST 2019 默认使用的模块是可以在ansible.cfg 中进行修改的。ansible命令下的参数部分解释如下123456789101112131415161718192021222324252627282930313233343536参数： -a ‘Arguments‘, --args=‘Arguments‘ 命令行参数 -m NAME, --module-name=NAME 指定执行的模块，默认使用 command 模块-i PATH, --inventory=PATH 指定库存主机文件的路径,默认为/etc/ansible/hosts. -u Username， --user=Username 执行用户，使用这个远程用户名而不是当前用户 -U --sud-user=SUDO_User sudo到哪个用户，默认为 root -k --ask-pass 登录密码，提示输入SSH密码而不是假设基于密钥的验证 -K --ask-sudo-pass 提示密码使用sudo -s --sudo sudo运行 -S --su 用 su 命令 -l --list 显示所支持的所有模块 -f --forks=NUM 并行任务数。NUM被指定为一个整数,默认是5。 #ansible testhosts -a \"/sbin/reboot\" -f 10 重启testhosts组的所有机器，每次重启10台 --private-key=PRIVATE_KEY_FILE 私钥路径，使用这个文件来验证连接-v --verbose 详细信息 -M MODULE_PATH, --module-path=MODULE_PATH 要执行的模块的路径，默认为/usr/share/ansible/ --list-hosts 只打印有哪些主机会执行这个 playbook 文件，不是实际执行该 playbook 文件 -o --one-line 压缩输出，摘要输出.尝试一切都在一行上输出。 -t Directory, --tree=Directory 将内容保存在该输出目录,结果保存在一个文件中在每台主机上。 -B 后台运行超时时间 -P 调查后台程序时间 -T Seconds, --timeout=Seconds 时间，单位秒s -P NUM, --poll=NUM 调查背景工作每隔数秒。需要- b -c Connection, --connection=Connection 连接类型使用。可能的选项是paramiko(SSH),SSH和地方。当地主要是用于crontab或启动。 --tags=TAGS 只执行指定标签的任务 例子:ansible-playbook test.yml --tags=copy 只执行标签为copy的那个任务 --list-hosts 只打印有哪些主机会执行这个 playbook 文件，不是实际执行该 playbook 文件--list-tasks 列出所有将被执行的任务 -C, --check 只是测试一下会改变什么内容，不会真正去执行;相反,试图预测一些可能发生的变化 --syntax-check 执行语法检查的剧本,但不执行它 -l SUBSET, --limit=SUBSET 进一步限制所选主机/组模式 --limit=192.168.0.15 只对这个ip执行 --skip-tags=SKIP_TAGS 只运行戏剧和任务不匹配这些值的标签 --skip-tags=copy_start -e EXTRA_VARS, --extra-vars=EXTRA_VARS 额外的变量设置为键=值或YAML / JSON #cat update.yml --- - hosts: {{ hosts }} remote_user: {{ user }} .............. #ansible-playbook update.yml --extra-vars \"hosts=vipers user=admin\" 传递{{hosts}}、{{user}}变量,hosts可以是 ip或组名 -l,--limit 对指定的 主机/组 执行任务 --limit=192.168.0.10，192.168.0.11 或 -l 192.168.0.10，192.168.0.11 只对这个2个ip执行任务 ansible-doc[root@VM_0_2_centos ~]# ansible-doc -hUsage: ansible-doc [-l|-F|-s] [options] [-t ] [plugin] 列出所有已安装的模块[root@VM_0_2_centos ~]# ansible-doc -l 查看具体某模块的用法，这里查看command模块[root@VM_0_2_centos ~]# ansible-doc -s command ansible-galaxyansible-galaxy 指令用于方便的从https://galaxy.ansible.com/ 站点下载第三方扩展模块，我们可以形象的理解其类似于centos下的yum、python下的pip或easy_install 。如下示例：[root@localhost ~]# ansible-galaxy install aeriscloud.dockerdownloading role ‘docker‘ owned by aeriscloud- downloading role from https://github.com/AerisCloud/ansible-docker/archive/v1.0.0.tar.gz- extracting aeriscloud.docker to /etc/ansible/roles/aeriscloud.docker- aeriscloud.docker was installed successfully 这个安装了一个aeriscloud.docker组件，前面aeriscloud是galaxy上创建该模块的用户名，后面对应的是其模块。在实际应用中也可以指定txt或yml 文件进行多个组件的下载安装。这部分可以参看官方文档。 ansible-lintansible-lint是对playbook的语法进行检查的一个工具。用法:ansible-lint playbook.yml 。 ansible-playbook该指令是使用最多的指令，其通过读取playbook 文件后，执行相应的动作，这个后面会做为一个重点来讲。 ansible-pull该指令使用需要谈到ansible的另一种模式－－－pull 模式，这和我们平常经常用的push模式刚好相反其适用于以下场景：你有数量巨大的机器需要配置，即使使用非常高的线程还是要花费很多时间；你要在一个没有网络连接的机器上运行Anisble，比如在启动之后安装。这部分也会单独做一节来讲。 ansible-vaultansible-vault主要应用于配置文件中含有敏感信息，又不希望他能被人看到，vault可以帮你加密/解密这个配置文件，属高级用法。主要对于playbooks里比如涉及到配置密码或其他变量时，可以通过该指令加密，这样我们通过cat看到的会是一个密码串类的文件，编辑的时候需要输入事先设定的密码才能打开。这种playbook文件在执行时，需要加上 –ask-vault-pass参数，同样需要输入密码后才能正常执行。具体该部分可以参查官方博客。 ansible配置文件 ansible.cfg查看配置文件设置http://docs.ansible.com/ansible/intro_configuration.html#poll-interval1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374* inventory–这个参数表示资源清单inventory文件配置，资源清单就是一些ansible需要链接管理的主机列表。安装完ansible之后默认所在的inventory列表配置如下： inventory = /etc/ansible/hosts * library–Ansible的操作动作，无论是本地或远程，都使用一小段代码来执行。这小段代码成为模块，这个library参数就是只想存放在Ansible模块的目录。Ansible支持多个目录方式，只要用冒号（：）隔开就可以，同时也会检查当前执行playbook位置下的./library位置。默认的配置如下：library = /usr/share/ansible * forks–设置默认情况下Ansible最多能有多少个进程同时工作，默认设置最多5个进程并行处理。具体需要设置多少个，可以根据控制主机的性能和被管理节点的数量来确定。默认参数配置如下： forks=20 你没有优化的优化的情况下执行比较慢forks = 5* sudo_user–这个设置默认执行命令的用户，在playbook中重新设置这个参数。默认参数配置如下：sudo_user = root * remote_port–这个是指定链接被管节点的管理端口，默认22。除非设置了特殊的SSH端口，不然这个参数一般是不需要修改的。默认配置如下：remote_port = 22* host_key_checking–这个设置是否检查SSH主机的秘钥。可以设置为True或者False。默认配置如下：host_key_checking = false * timeout–这是设置SSH链接的超时间隔，单位是秒。默认配置实例如下：timeout = 60* log_path–Ansible系统默认是不记录日志的，如果想把Ansible系统的输出记录到日志文件中，需要设置log\\_path来指定一个存储Ansible日志的文件。配置实例如下：log_path = /var/log/ansible.log poll_interval 异步执行任务的时候多久检查一次任务装填poll_interval = 15选择远程的工具 默认情况下就是smart(智能)模式 自动选择连接方式只有当你需要优化执行速度的时候才需要修改这个选项transport = smart module_set_locale 设置本地的环境变量 inventory = /etc/ansible/hosts 这个是默认库文件位置,脚本,或者存放可通信主机的目录 #library = /usr/share/my_modules/ Ansible默认搜寻模块的位置 remote_tmp = $HOME/.ansible/tmp Ansible 通过远程传输模块到远程主机,然后远程执行,执行后在清理现场.在有些场景下,你也许想使用默认路径希望像更换补丁一样使用 pattern = * 如果没有提供“hosts”节点,这是playbook要通信的默认主机组.默认值是对所有主机通信 forks = 5 在与主机通信时的默认并行进程数 ，默认是5d poll_interval = 15 当具体的poll interval 没有定义时,多少时间回查一下这些任务的状态, 默认值是5秒 sudo_user = root sudo使用的默认用户 ，默认是root #ask_sudo_pass = True 用来控制Ansible playbook 在执行sudo之前是否询问sudo密码.默认为no #ask_pass = True 控制Ansible playbook 是否会自动默认弹出密码 transport = smart 通信机制.默认 值为’smart’。如果本地系统支持 ControlPersist技术的话,将会使用(基于OpenSSH)‘ssh’,如果不支持讲使用‘paramiko’.其他传输选项包括‘local’, ‘chroot’,’jail’等等 #remote_port = 22 远程SSH端口。 默认是22 module_lang = C 模块和系统之间通信的计算机语言，默认是C语言 gathering = implicit 控制默认facts收集（远程系统变量）. 默认值为’implicit’, 每一次play,facts都会被收集#roles_path = /etc/ansible/roles roles 路径指的是’roles/’下的额外目录,用于playbook搜索Ansible roles#host_key_checking = False 检查主机密钥sudo_exe = sudo 如果在其他远程主机上使用另一种方式执sudu操作.可以使用该参数进行更换#what flags to pass to sudo 传递sudo之外的参数#sudo_flags = -H#SSH timeout SSH超时时间timeout = 10#remote_user = root 使用/usr/bin/ansible-playbook链接的默认用户名，如果不指定，会使用当前登录的用户名#log_path = /var/log/ansible.log 日志文件存放路径#module_name = command ansible命令执行默认的模块#executable = /bin/sh 在sudo环境下产生一个shell交互接口. 用户只在/bin/bash的或者sudo限制的一些场景中需要修改#jinja2_extensions = jinja2.ext.do,jinja2.ext.i18n 允许开启Jinja2拓展模块#private_key_file = /root/.ssh/id_rsa 私钥文件存储位置ansible_managed = Ansible managed: {file} modified on %Y-%m-%d %H:%M:%S by {uid} on {host} 这个设置可以告知用户,Ansible修改了一个文件,并且手动写入的内容可能已经被覆盖.#display_skipped_hosts = True 显示任何跳过任务的状态 ，默认是显示#error_on_undefined_vars = False 如果所引用的变量名称错误的话, 将会导致ansible在执行步骤上失败#system_warnings = True 允许禁用系统运行ansible相关的潜在问题警告#deprecation_warnings = True 允许在ansible-playbook输出结果中禁用“不建议使用”警告#command_warnings = False 当shell和命令行模块被默认模块简化的时,Ansible 将默认发出警告#nocows = 1 默认ansible可以调用一些cowsay的特性 开启/禁用：0/1#nocolor = 1 输出带上颜色区别， 开启/关闭：0/1 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Ansible","slug":"Ansible","permalink":"http://yoursite.com/categories/Ansible/"}],"tags":[{"name":"Ansible","slug":"Ansible","permalink":"http://yoursite.com/tags/Ansible/"}],"author":"DU"},{"title":"Python 的面向对象","slug":"Python/02.Oop/01.Python的面向对象","date":"2019-05-01T10:11:07.000Z","updated":"2019-07-21T01:21:36.772Z","comments":true,"path":"2019/05/01/Python/02.Oop/01.Python的面向对象/","link":"","permalink":"http://yoursite.com/2019/05/01/Python/02.Oop/01.Python的面向对象/","excerpt":"","text":"Python的面向对象- OO - 类的基本实现 - 类和对象的成员分析 - self 面向对象概述（ObjectOriented，OO） OOP思想接触到任意一个任务，首先想到的是任务这个世界的构成，是由模型构成的OO:面向对象OOA：面向对象的分析OOD：面向对象的设计OOI：xxx的实现OOP：xxx的编程OOA->OOD->OOI: 面向对象的实现过程 类和对象的概念类：抽象名词，代表一个集合，共性的事物对象：具象的事物，单个个体类跟对象的关系一个具象，代表一类事物的某一个个体一个是抽象，代表的是一大类事物 类中的内容，应该具有两个内容表明事物的特征，叫做属性(变量)表明事物功能或动作， 称为成员方法(函数) 类的基本实现 类的命名遵守变量命名的规范大驼峰（由一个或者多个单词构成，每个单词首字母大写，单词跟单词直接相连）尽量避开跟系统命名相似的命名 你如何声明一个类class关键字类由属性和方法构成，其他不允许出现成员属性定义可以直接使用变量赋值，如果没有值，许使用None 实例化类 变量 = 类名() #实例化了一个对象 访问对象成员 12obj.成员属性名称 obj.成员方法 对象的所有成员 12# dict前后各有两个下划线obj.__dict__ 类的所有成员 12# dict前后各有两个下划线class_name.__dict__ 类和对象的成员分析 类和对象都可以存储成员，成员可以归类所有，也可以归对象所有 类存储成员时使用的是与类关联的一个对象 独享存储成员是是存储在当前对象中 对象访问一个成员时，如果对象中没有该成员，尝试访问类中的同名成员， 如果对象中有此成员，一定使用对象中的成员 创建对象的时候，类中的成员不会放入对象当中，而是得到一个空对象，没有成员 12345678910111213141516171819202122232425262728案例：class A(): name = \"kobe\" number = 24# A 称为类实例 print (\"A\",A.name,id(A.name))print (\"A\",A.number,id(A.number))print(\"*\" * 20)a = A()print (\"a\",a.name,id(a.name))print (\"a\",a.number,id(a.number))# 查看所有的属性print (\"A\",A.__dict__)print (\"a\",a.__dict__) #{} 空 # 在不对对象的实例属性赋值的前提下，类实例的属性和其对象实例的属性指向同一个变量A kobe 140589649254976A 24 9306720********************a kobe 140589649254976a 24 9306720A {'__module__': '__main__', 'name': 'kobe', 'number': 24, '__dict__': , '__weakref__': , '__doc__': None}a {} 通过对象对类中成员重新赋值或者通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员 1234567891011121314151617181920212223242526272829303132333435363738394041案例:class A(): name = \"kobe\" number = 24 # A 称为类实例 print (\"A\",A.name,id(A.name))print (\"A\",A.number,id(A.number))print(\"*\" * 20)a = A()print (\"a\",a.name,id(a.name))print (\"a\",a.number,id(a.number))## 查看所有的属性print (\"A\",A.__dict__)print (\"a\",a.__dict__) #{} print(\"*\" * 20)#赋值a.name = \"Owen\"a.number = 11print (\"a\",a.name,id(a.name))print (\"a\",a.number,id(a.number))print (\"a\",a.__dict__)#通过对象对类中成员重新赋值或者通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员A kobe 140589649254976A 24 9306720********************a kobe 140589649254976a 24 9306720A {'__module__': '__main__', 'name': 'kobe', 'number': 24, '__dict__': , '__weakref__': , '__doc__': None}a {}********************a Owen 140589649496696a 11 9306304a {'name': 'Owen', 'number': 11} self self在对象的方法中表示当前对象本身，如果通过对象调用一个方法，那么该对象会自动传入到当前方法的第一个参数中 self并不是关键字，只是一个用于接受对象的普通参数，理论上可以用任何一个普通变量名代替 12345678910111213141516171819案例:class Student(): name = \"dana\" age = 18 # 注意say的写法，参数有一个self def say(self): self.age = 200 print(\"My age is {0}\".format(self.age)) # 任何一个普通变量名代替self def sayAgain(s): print(\"My age is {0}\".format(s.age)) yueyue = Student()yueyue.say()yueyue.sayAgain()My age is 200My age is 200 方法中有self形参的方法是非绑定类的方法，可以通过对象访问； 没有self的是绑定类的方法，只能通过类访问 类方法中需要访问当前类的成员，可以通过 class成员名来访问 12345678910111213141516171819202122232425262728class Teacher(): name = \"dana\" age = 19 def say(self): self.name = \"yaona\" self.age = 17 print(\"My name is {0}\".format(self.name)) # 调用类的成员变量需要用 __class__ print(\"My age is {0}\".format(__class__.age)) def sayAgain(): print(__class__.name) print(__class__.age ) print(\"Hello, nice to see you again\") t = Teacher()t.say()# 调用绑定类函数使用类名Teacher.sayAgain()# 如果类方法中需要访问当前类的成员，可以通过 __class__成员名来访问My name is yaonaMy age is 19dana19Hello, nice to see you again 关于self的案例 12345678910111213141516171819202122232425262728293031323334353637383940# 案例:class A(): name = \" liuying\" age = 18 def __init__(self): self.name = \"aaaa\" self.age = 200 def say(self): print(self.name) print(self.age) class B(): name = \"bbbb\" age = 90a = A()# 此时，系统会默认把对象a作为第一个参数传入函数a.say() A.say() #错误，类实例不会自动传入第一个参数，需要手动传入一个# 此时，self被a替换A.say(a)# 同样可以把A作为参数传入A.say(A)# 此时，传入的是类实例B，因为B具有name和age属性，所以不会报错A.say(B)# 以上代码，利用了鸭子模型aaaa200aaaa200liuying18bbbb90 面向对象编程- 封装 - 继承 - 多态、Mixin - 类的相关函数 - 类的成员描述符 - 类的内置属性 - 魔法函数 - 类和对象的三种方法 - 抽象类 - 自定义类 面向对象的三大特性：封装、继承、多态 封装 将属性和方法封装到一个抽象的类中 封装的三个级别：公开，public受保护的，protected私有的，privatepublic，private，protected不是关键字 判别对象的位置对象内部对象外部子类中 python中下划线使用 私有私有成员是最高级别的封装，只能在当前类或对象中访问在成员前面添加两个两个下划线即可: __agePython的私有不是真私有，是一种成为name mangling的改名策略可以使用:对象._classname_attributename访问 123456789101112# 案例:# __age是私有变量,不能直接访问。print(p.__age) #注意报错信息 # name mangling技术 print(Person.__dict__)p._Person__age = 19print(p._Person__age) {'__module__': '__main__', 'name': 'liuying', '_Person__age': 18, '__dict__': , '__weakref__': , '__doc__': None}19 受保护的封装 protected受保护的封装是将对象成员进行一定级别的封装，然后，在类中或者子类中都可以进行访问，但是在外部不可以封装方法： 在成员名称前添加一个下划线即可name mangling的改名策略可以使用:对象._classname_attributename访问 公开的，公共的 public公共的封装实际对成员没有任何操作，任何地方都可以访问 继承 继承就是一个类可以获得另外一个类中的成员属性和成员方法 作用： 减少代码，增加代码的复用功能， 同时可以设置类与类直接的关系 继承与被继承的概念：被继承的类叫父类，也叫基类，也叫超类用于继承的类，叫子类，也叫派生类继承与被继承一定存在一个 is-a 关系 继承的语法: 12#父类写在括号内class Teacher(Person): 继承的特征所有的类都继承自object类，即所有的类都是object类的子类子类一旦继承父类，则可以使用父类中除私有成员外的所有内容子类继承父类后并没有将父类成员完全赋值到子类中，而是通过引用关系访问调用子类中可以定义独有的成员属性和方法子类中定义的成员和父类成员如果相同，则优先使用子类成员子类如果想扩充父类的方法，可以在定义新方法的同时访问父类成员来进行代码重用 12[父类名.父类成员]的格式来调用父类成员super().父类成员的格式来调用 子类扩充父类功能的案例 12345678910111213141516171819202122232425262728293031# 人由工作的函数， 老师也由工作的函数，但老师的工作需要讲课class Person(): name = \"NoName\" age = 18 __score = 0 # 考试成绩是秘密，只要自己知道 _petname = \"sec\" #小名，是保护的，子类可以用，但不能公用 def sleep(self): print(\"Sleeping ... ...\") def work(self): print(\"make some money\") #父类写在括号内class Teacher(Person): teacher_id = \"9527\" name = \"DaNa\" def make_test(self): print(\"attention\") def work(self): # 扩充父类的功能只需要调用父类相应的函数 #Person.work(self) # 扩充父类的另一种方法 # super代表得到父类 super().work() self.make_test() t = Teacher()t.work()make some moneyattention 继承变量函数的查找顺序问题优先查找自己的变量没有则查找父类构造函数如果本类中没有定义，则自动查找调用父类构造函数如果本类有定义，则不在继续向上查找 构造函数是一类特殊的函数，在类进行实例化之前进行调用 12345678910案例：class Dog():# __init__就是构造函数 def __init__(self): print(\"I am init in dog\")# 实例话的时候，括号内的参数需要跟构造函数参数匹配kaka = Dog() I am init in dog 构造函数查找顺序如果定义了构造函数，则实例化时使用构造函数，不查找父类构造函数如果没定义，则自动查找父类构造函数如果子类没定义，父类的构造函数带参数，则构造对象时的参数应该按父类参数构造 supersuper不是关键字， 而是一个类super的作用是获取MRO（MethodResolustionOrder）列表中的第一个类super于父类直接没任何实质性关系，但通过super可以调用到父类super使用的两个方法,参见在构造函数中调用父类的构造函数 单继承和多继承单继承：每个类只能继承一个类多继承，每个类允许继承多个类 单继承和多继承的优缺点单继承：优点：传承有序逻辑清晰语法简单隐患少呀缺点：功能不能无限扩展，只能在当前唯一的继承链中扩展多继承：优点：类的功能扩展方便缺点：继承关系混乱 菱形继承/钻石继承问题多个子类继承自同一个父类，这些子类由被同一个类继承，于是继承关系图形成一个菱形图谱MRO关于多继承的MROMRO就是多继承中，用于保存继承顺序的一个列表python本身采用C3算法来多多继承的菱形继承进行计算的结果 MRO列表的计算原则：子类永远在父类前面如果多个父类，则根据继承语法中括号内类的书写顺序存放如果多个类继承了同一个父类，孙子类中只会选取继承语法括号中第一个父类的父类 123456789101112131415161718192021222324252627282930313233343536373839404142案例：扩展构造函数class A(): def __init__(self): print(\"A\")class B(A): def __init__(self, name): print(\"B\") print(name) class C(B): # c中想扩展B的构造函数， # 即调用B的构造函数后在添加一些功能 # 由两种方法实现 ''' # 第一种是通过父类名调用 def __init__(self, name): # 首先调用父类构造函数 B.__init__(self, name) # 其次，再增加自己的功能 print(\"这是C中附加的功能\") ''' # 第二种，使用super调用 def __init__(self, name): # 首先调用父类构造函数 super(C, self).__init__(name) # 其次，再增加自己的功能 print(\"这是C中附加的功能\") # 此时，首先查找C的构造函数# 如果没有，则向上按照MRO顺序查找父类的构造函数，知道找到为止# 此时，会出现参数结构不对应错误c = C(\"我是C\")B我是C这是C中附加的功能 多态 不同的子类对象调用相同的父类方法，产生不同的执行结果 以继承和重写父类方法为前提 多态性：同一种调用方式，产生不同的执行效果 多态和多态性 Mixin设计模式主要采用多继承方式对类的功能进行扩展Mixin概念MRO and MixinMixin模式Mixin MROMRO 我们使用多继承语法来实现Minxin 使用Mixin实现多继承的时候非常小心首先他必须表示某一单一功能，而不是某个物品职责必须单一，如果由多个功能，则写多个MixinMixin不能依赖于子类的实现子类及时没有继承这个Mixin类， 也能照样工作，只是缺少了某个功能 优点使用Mixin可以在不对类进行任何修改的情况下，扩充功能可以方便的组织和维护不同功能组件的划分可以根据需要任意调整功能类的组合可以避免创建很多新的类，导致类的继承混乱 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# Mixin案例class Person(): name = \"liuying\" age = 18 def eat(self): print(\"EAT.......\") def drink(self): print(\"DRINK......\") def sleep(self): print(\"SLEEP.....\") class Teacher(Person): def work(self): print(\"Work\")class Student(Person): def study(self): print(\"Study\") class Tutor(Teacher, Student): passt = Tutor() print(Tutor.__mro__)print(t.__dict__)print(Tutor.__dict__)print(\"*\"*20)class TeacherMixin(): def work(self): print(\"Work\")class StudentMixin(): def study(self): print(\"Study\") class TutorM(Person, TeacherMixin, StudentMixin): passtt = TutorM()print(TutorM.__mro__)print(tt.__dict__)print(TutorM.__dict__) 类相关函数 issubclass:检测一个类是否是另一个类的子类 isinstance:检测一个对象是否是一个类的实例 hasattr:检测一个对象是否由成员xxx getattr: get attribute setattr: set attribute delattr: delete attribute dir: 获取对象的成员列表 类的成员描述符（属性） 类的成员描述符是为了在类中对类的成员属性进行相关操作而创建的一种方式get： 获取属性的操作set：修改或者添加属性操作delete： 删除属性的操作 如果想使用类的成员描述符，大概有三种方法使用类实现描述器使用属性修饰符使用property函数:property(fget, fset, fdel, doc) 1234567891011121314151617181920# peroperty案例# 定义一个Person类，具有name，age属性# 对于任意输入的姓名，我们希望都用大写方式保存# 年龄，我们希望内部统一用整数保存# x = property(fget, fset, fdel, doc)class Person(): # 函数的名称可以任意 def fget(self): return self._name * 2 def fset(self, name): # 所有输入的姓名以大写形式保存 self._name = name.upper() def fdel(self): self._name = \"NoName\" name2 = property(fget, fset, fdel, \"对name进行下下操作啦\") 无论哪种修饰符都是为了对成员属性进行相应的控制类的方式： 适合多个类中的多个属性共用用一个描述符property：使用当前类中使用，可以控制一个类中多个属性属性修饰符： 使用于当前类中使用，控制一个类中的一个属性 类的内置属性 dict以字典的方式显示类的成员组成 doc:获取类的文档信息 name获取类的名称，如果在模块中使用，获取模块的名称 bases获取某个类的所有父类，以元组的方式显示 类的常用魔术方法 魔术方法就是不需要人为调用的方法，基本是在特定的时刻自动触发 魔术方法的统一的特征，方法名被前后各两个下滑线包裹 操作类__init__: 构造函数__new__: 对象实例化方法，此函数较特殊，一般不需要使用__call__: 对象当函数使用的时候触发__str__: 当对象被当做字符串使用的时候调用__repr__: 返回字符串 描述符相关__set____get____delete__ 属性操作相关__getattr__: 访问一个不存在的属性时触发__setattr__: 对成员属性进行设置的时候触发参数：self用来获取当前对象被设置的属性名称，以字符串形式出现需要对属性名称设置的值作用：进行属性设置的时候进行验证或者修改注意： 在该方法中不能对属性直接进行赋值操作，否则死循环 1234567891011121314151617# __setattr__案例class Person(): def __init__(self): pass def __setattr__(self, name, value): print(\"设置属性： {0}\".format(name)) # 下面语句会导致问题，死循环 #self.name = value # 此种情况，为了避免死循环，规定统一调用父类魔法函数 super().__setattr__(name, value) p = Person()print(p.__dict__)p.age = 18 运算分类相关魔术方法__gt__: 进行大于判断的时候触发的函数参数：self第二个参数是第二个对象返回值:可以是任意值，推荐返回布尔值 123456789101112131415161718# __gt__class Student(): def __init__(self, name): self._name = name def __gt__(self, obj): print(\"哈哈， {0} 会比 {1} 大吗？\".format(self, obj)) return self._name > obj._name stu1 = Student(\"one\")stu2 = Student(\"two\")print(stu1 > stu2)哈哈， 会比 大吗？False 类和对象的三种方法 实例方法需要实例化对象才能使用的方法，使用过程中可能需要截止对象的其他对象的方法完成 静态方法不需要实例化，通过类直接访问 类方法不需要实例化 12345678910111213141516171819202122232425262728293031# 三种方法的案例class Person: # 实例方法 def eat(self): print(self) print(\"Eating.....\") #类方法 # 类方法的第一个参数，一般命名为cls，区别于self @classmethod def play(cls): print(cls) print(\"Playing.....\") # 静态方法 # 不需要用第一个参数表示自身或者类 @staticmethod def say(): print(\"Saying....\") yueyue = Person()# 实例方法yueyue.eat()# 类方法Person.play()yueyue.play()#静态方法Person.say()yueyue.say() 抽象类 抽象方法：没有具体实现内容的方法成为抽象方法 抽象方法的主要意义是规范了子类的行为和接口 抽象类的使用需要借助abc模块 import abc 抽象类：包含抽象方法的类叫抽象类，通常成为ABC类 12345678910111213141516171819202122232425# 抽象类的实现import abc#声明一个类并且指定当前类的元类class Human(metaclass=abc.ABCMeta): # 定义一个抽象的方法 @abc.abstractmethod def smoking(self): pass # 定义类抽象方法 @abc.abstractclassmethod def drink(): pass # 定义静态抽象方法 @abc.abstractstaticmethod def play(): pass # 定义一个具体方法 def sleep(self): print(\"Sleeping.......\") 抽象类的使用抽象类可以包含抽象方法，也可以包含具体方法抽象类中可以有方法也可以有属性抽象类不允许直接实例化必须继承才可以使用，且继承的子类必须实现所有继承来的抽象方法假定子类没有是现实所有继承的抽象方法，则子类也不能实例化抽象类的主要作用是设定类的标准，以便于开发的时候具有统一的规范 自定义类123456789# 函数名可以当变量使用def sayHello(name): print(\"{0}你好 \".format(name)) sayHello(\"月月\")B = sayHelloB(\"yueyue\") 类其实是一个类定义和各种方法的自由组合 可以定义类和函数，然后自己通过类直接赋值 123456789101112131415161718# 组装类 1 class A(): passdef say(self): print(\"Saying... ...\") #等同于 class B(): def say(self): print(\"Saying......\")say(9)A.say = saya = A()a.say() 可以借助于MethodType实现 12345678910111213141516# 组装类例子 2# 自己组装一个类from types import MethodTypeclass A(): passdef say(self): print(\"Saying... ...\") a = A()# 通过MethodType 把say组装到A a.say = MethodType(say, A)a.say() 借助于type实现 1234567891011121314151617# 利用type造一个类# 先定义类应该具有的成员函数def say(self): print(\"Saying.....\") def talk(self): print(\"Talking .....\") #用type来创建一个类A = type(\"AName\", (object, ), {\"class_say\":say, \"class_talk\":talk})# 然后可以像正常访问一样使用类a = A()a.class_say()a.class_talk() 利用元类实现- MetaClass元类是类被用来创造别的类 1234567891011121314151617181920# 元类演示# 元类写法是固定的，必须继承自type# 元类一般命名以MetaClass结尾class TulingMetaClass(type): # 注意以下写法 def __new__(cls, name, bases, attrs): #自己的业务处理 print(\"哈哈，我是元类呀\") attrs['id'] = '000000' attrs['addr'] = \"北京海淀区公主坟西翠路12号\" return type.__new__(cls, name, bases, attrs) # 元类定义完就可以使用，使用注意写法class Teacher(object, metaclass=TulingMetaClass): passt = Teacher()t.id document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"author":"DU"},{"title":"Prometheus","slug":"Prometheus/01.pro","date":"2019-05-01T10:11:07.000Z","updated":"2019-07-21T01:21:36.753Z","comments":true,"path":"2019/05/01/Prometheus/01.pro/","link":"","permalink":"http://yoursite.com/2019/05/01/Prometheus/01.pro/","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Prometheus","slug":"Prometheus","permalink":"http://yoursite.com/categories/Prometheus/"}],"tags":[{"name":"Prometheus","slug":"Prometheus","permalink":"http://yoursite.com/tags/Prometheus/"}],"author":"DU"},{"title":"Python 的流程控制","slug":"Python/01.Basic-level/02.Python的流程控制","date":"2019-04-27T10:11:07.000Z","updated":"2019-07-21T01:21:36.767Z","comments":true,"path":"2019/04/27/Python/01.Basic-level/02.Python的流程控制/","link":"","permalink":"http://yoursite.com/2019/04/27/Python/01.Basic-level/02.Python的流程控制/","excerpt":"","text":"流程控制 分支结构 循环结构 分支结构/选择结构 单项分支: 12if 条件表达式： ... 双向分支 1234if 条件表达式: ...else: ... 多项分支 12345678if 条件表达式： ...elif 条件表达式: ... elif 条件表达式： ...else: ... 巢状分支巢状分支就是多个其他if…else分支的嵌套组合 12345678if x < 5: print('x真的小于5哦') if y < 6: print('如果y < 6，我会被输出') elif y > 6: print('如果上y大于6，我会被输出')elif x > 5: print('x大于5') 注意：：在python中并没有switch…case分支。后期可以使用字典和函数的组合来代替。 循环结构while循环 while …: … while …: … else: … while True: … for循环 for … in 循环 1234567891011121314# 格式1: for 变量 in 序列: ... # 格式2:for 变量1,变量2.. in 多层序列： ... # 格式3：for 变量 in 序列：: ...else: ... 其他流程控制语句 break 破坏，结束，打破作用：结束程序循环，一旦程序执行了break语句，那么当前break所在的循环就会被终止 continue 继续作用：结束本次循环，开始下一次的循环，他不会终止整个循环，仅对于循环中的某次循环有效 pass 通过，忽略作用：在程序结构中有时不需用写任何python内容，但是如果没有内容，语言结构会出现语法错误！pass可以作为语法占位符使用，pass语句没有任何意义，也不会做任何操作 函数函数的定义最基本的函数结构1234def 函数名()： ...调用函数： 函数名() 具有参数的函数结构1234def 函数名(参数名，参数名...): ...调用函数: 函数名(值,值...) 声明函数的()中的参数称之为形参，形参表示形式上的参数调用函数的()中的参数称之为实参，实参表示真实的值注意:实参传递值给形参的过程，本质上就是普通的变量赋值 具有默认值参数的函数12345def 函数名(形参名 = 默认值,形参名 = 默认值...): ...调用函数1：函数名()调用函数2:函数名(实参,实参...) 函数文档 查看函数文档：使用help(函数名)，可以查看函数文档信息，查看信息时信息会换行使用函数名.doc的方式查看，查看信息时信息不会换行，会显示\\n 自定义函数文档：在函数内部开始的第一行使用字符串定义文字内容即可 123456789101112131415def 函数名()： '此处书写函数文档信息，单引号中使用\\n换行' 函数中的其他代码...或者def 函数名(): ''' 此处书写函数文档信息 此处书写函数文档信息 ''' 函数中的其他代码... lambda表达式 lambda不是一种函数结构，只是一种表达式而且不需要函数名。（匿名函数）格式： 变量 = lambda 形参,形参…： 功能代码 案例： 12345#传入两个参数返回这两个数的乘积 lambda x,y :x*y #根据条件表达式的真假返回值1还是值2 lambda x： 值1 if 条件表达式 else 值2 优点：lambda表达式书写简单，不用def关键字，可惜要用lambdalambda表达式不需要函数名，省得命名头疼看起来比较装逼！ 缺点：lambda表达式功能受限，无法使用循环以及部分流程控制相关语句lambda表达式不适合较为复杂的程序。 收集参数 收集参数1 (专用于收集非关键字参数)12345# 「*」 形参格式的收集参数会收集到调用函数时传入的所有没有关键字的形参 def 函数名(*形参名)： ... 调用函数： 函数名(实参,实参....) 注意:1) 收集参数收集到的最终数据是由所有非关键字实参组成的元组。2) 收集参数和普通的参数（关键字参数）可以共存 收集参数2 (专门用于收集关键字参数)12345#「**」 形参格式会收集调用函数时传入函数的所有关键字参数 def 函数名(**args): ...调用函数：函数名(形参名 = 值,形参名=值...) -注意:1) 收集的所有关键字参数最终组成的数据为字典类型2) 关键字参数收集的方式可以和普通形参共存，但是必须在最后 注意：普通形参，非关键字收集形参和关键字收集形参具有顺序关系普通形参放最前面非关键字形参放中间关键字形参放最后所有收集参数只能够收集没有形参接受的实参 函数的变量作用域全局变量和局部变量 全局变量: 在函数外部声明的变量就是全局变量 局部变量: 在函数内部声明的变量就是局部变量 局部变量和全局变量的作用范围 全局变量在全局范围内可以使用 全局变量在局部范围内可以使用(访问) 局部变量在局部范围内可以使用 局部变量在全局范围内无法正常使用 global 关键字 global 关键字的作用是提升局部变量为全局变量1234def 函数名(): ... #提升局部变量为全局变量 global 局部变量 内部函数 在函数内部声明的函数就是内部函数 特征:内部函数在函数内部可以访问内部函数的调用必须在定义内部函数之后内部函数不可以在函数外部调用本质上内部函数等同于内部变量 闭包 闭包将函数内部的局部变量或者内部函数,弄到函数外,并且可以正常使用的特殊方法.突破了局部作用域的限制!注意:闭包少用! 闭包格式： 1234567def 外层函数()： 局部变量 局部变量 def 内部函数()： pass return (局部变量，局部变量...内部函数,内部函数...) nonlocal关键字 声明当前变量不是当前函数内部的变量，他有可能是当前函数的外部变量（不是全局变量）123456789101112def 外部函数() 局部变量 def 内部函数（）: nonlocal 变量名#声明当前变量不是内部函数中的变量 其他代码... return 代码 递归函数 在函数中调用当前函数本身的函数就是递归函数。示例：123456789101112131415161718def recursion(n): #输出当前的n的值 print(n) #判断n的值是否>0,决定下一步操作 if n>0: #n>0 在此调用当前函数digui，将n - 1放进去 recursion(n-1) else: #n>0 为False 输出分隔线 print('------') #再次输出n的值 print(n)recursion(3)执行结果:3 2 1 0 ----- 0 1 2 3 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"author":"DU"},{"title":"Python 的语法基础","slug":"Python/01.Basic-level/01.Python的语法基础","date":"2019-04-25T10:11:07.000Z","updated":"2019-07-21T01:21:36.772Z","comments":true,"path":"2019/04/25/Python/01.Basic-level/01.Python的语法基础/","link":"","permalink":"http://yoursite.com/2019/04/25/Python/01.Basic-level/01.Python的语法基础/","excerpt":"","text":"Python的语法基础 基础语法 基础语法 编码默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 查看数据类型用法：type(变量名) 获取变量在内存中的id标识用法：id(变量名) 系统中保留关键字： 12import keyword print (keyword.kwlist) 多行语句Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句 1234567total = item_one + \\ item_two + \\ item_three # 在 [], {}, 或 () 中的多行语句，不需要使用反斜杠(\\)total = ['item_one', 'item_two', 'item_three', 'item_four', 'item_five'] 等待用户输入：input() 同一行显示多条语句 123# Python可以在同一行中使用多条语句，语句之间使用分号(;)分割 import sys; x = 'runoob'; sys.stdout.write(x + '\\n') Python的数据类型Python中可以自定义数据类型,可以具有无限种数据类型系统默认提供6个标准数据类型： Number类型(数字) String类型（字符串） List类型 (列表) tuple类型(元组) Dictionary类型(字典) Set类型（集合） Number类型Number类型主要包含数学相关的数据：一共分为4种小类型： 整型整型就是整数。包括正整数负整数和0二进制（0b开头）变量 = 0b10101八进制（0o开头）变量 = 0o777十进制（不需要）变量 = 250十六进制（0x开头）变量 = 0xabcd 浮点型浮点型就是小数。使用小数表示浮点数 float1 = 3.141592653科学计数法表示浮点数float2 = 314e-2 # 314*10的-2次方 复数什么是复数。 复数由实数和虚数两部分组成表达式: 163 + 2j使用复数功能结构: com2 = complex(15,3) 布尔类类型布尔值就是表示确定或者否定的数据类型，只有2个值：True和False 在python当中没有真正的布尔类型，而是使用数字0来表示False，数字1表示True，所以bool是Number类型 String类型字符串就是文字类型 字符串的声明： 单引号声明字符串 变量 = ‘值’ 双引号声明字符串 变量 = “值” 三引号声明变量 变量 = ‘’’值’’’ 变量 = “””值””” 三引号声明字符串的方式适合大数据的字符串、多行数据 字符串相关操作 常用字符串连接符号: +字符复制操作: *[] 通过指定位置（索引）来获取指定位置的字符[:] 取片操作（不包含结束位置）注意事项：单引号中不可以直接使用单引号双引号中不可以直接使用双引号三引号中可以随意使用单双引号 字符串的转义操作：(在行尾时) 续行符\\ 反斜杠符号\\’ 单引号\\” 双引号\\a 响铃\\b 退格(Backspace)\\e 转义\\000 空\\n 换行\\v 纵向制表符\\t 横向制表符\\r 回车\\f 换页\\oyy 八进制数，yy代表的字符，例如：\\o12代表换行\\xyy 十六进制数，yy代表的字符，例如：\\x0a代表换行\\other 其它的字符以普通格式输出 r 防止转义:print(r’hello\\nrunoob’) str 的内置函数 capitalize() 首字母大写格式： str.capitalize()返回值：首字母大写的字符串，仅把整个字符串的第一个字符大写 upper() 将所有英文字符变为大写格式：str.upper()返回值：返回所有英文字符大写的字符串 lower() 将所有英文字符变为小写格式：str.lower()返回值：返回所有英文字符小写的字符串 swapcase() 大小写互相转换格式：str.swapcase()返回值：转换之后的字符串 title() 按照标题格式进行大小写转换（每个单词首字母大写)格式：str.title()返回值：返回所有英文单词首字母大写的字符串 len() 计算字符串的字符个数,以后也可以用于计算元组列表等序列格式: len(str)返回值:整型 count() 计算一个字符串中出现指定字符串的次数格式：str.count(‘查找的字符串’[,开始位置])返回值:返回整型 find() 查找字符串中是否具有指定的字符串,查找不到返回-1格式：str.find(查找的字符串[，开始位置])返回值:第一次出现的位置 index() 查找字符串中是否具有指定的字符串，查找不到直接报错格式：str.index(查找的字符串[，开始位置])返回值:第一次出现的位置 startswith() 检测字符串是否以指定的字符串开头格式： str.startswith(‘查找的字符串’[，开始位置])返回值：布尔值 endswith() 检测字符串是否以指定的字符串结尾格式： str.endswith(‘查找的字符串’[，开始位置])返回值：布尔值 isupper() 检测字符串中字母是否都是大写字母格式：str.isupper()返回值：布尔值 islower() 检测字符串中的字母是否都是小写字母格式：str.islower()返回值：布尔值 isalnum() 检测一个字符串是否都是有数字或者是否都是有字母组成格式：str.isalnum()返回值:布尔值注意：空字符串返回False isalpha() 检测字符串是否都是有字母类型构成，汉字作为字母处理格式：str.isalpha()返回值：布尔值注意：空字符串返回False isdigit() 检测字符串是否由纯数字字符组成格式：str.isdigit()返回值：布尔值注意：空字符串返回False isspace() 检测字符串是否完全由空白字符组成格式：str.isspace()返回值：布尔值注意：回车，换行，缩进，空格都可以当作空白字符，空字符串是False istitle() 检测字符串是否符合title()的结果，每个单词首字母大写格式：str.istitle()返回值：布尔值 isnumeric() 检测字符串是否有纯数字构成格式：str.isnumeric()返回值：布尔值 isdecimal() 检测字符串是否完全由十进制字符组成格式：str.isdecimal()返回值：布尔值 split() 使用指定的字符将字符串卷拆解成多个字符串格式： str.split(‘用于拆解的字符串’)返回值：列表类型 splitlines() 使用\\n，\\r或者\\r\\n切割字符串格式：str.splitlines()返回值：列表类型 join() 使用指定的字符串将序列中的内容组成新的字符串格式：连接字符串.join(序列)返回值：组成的新的字符串 zfill() 0填充操作格式： str.zfill(长度)返回值：填充0的字符串注意：填充结果原有内容靠右对齐，前面位数不足使用0来补充，常用于数字类型字符串。 center() 将字符串进行居中操作，并且在空白处进行填充格式： str.center(未来字符宽度,空白填充字符)返回值：新的字符串 ljust（） 将字符串进行左对齐操作，并且在空白处进行填充格式： str.ljust(未来字符宽度,空白填充字符)返回值：新的字符串 rjust() 将字符串进行右对齐操作，并且在空白处进行填充格式： str.rjust(未来字符宽度,空白填充字符)返回值：新的字符串 lstrip() 去掉字符串左侧的空白格式： str.lstrip()返回值：字符串 rstrip()去掉字符串右侧的空白格式： str.rstrip()返回值：字符串 strip()去掉字符串两侧的空白格式： str.strip()返回值：字符串 replace() 字符串替换操作格式： str.replace(被替换的字符串,替换字符串)返回值：替换之后的字符串、 maketrans() 制作一个字符串映射表，为了给translate函数使用格式:str.maketrans（’被替换的字符串’,’替换字符串’）返回值：字典类型，被替换字符串组成键，替换字符串组成值注意： 两个参数的字符串个数必须一一对应，这里的str不是值字符串，而是真正的str，也可以写空字符串代替str（字符串都是str制作的） translate() 进行字符串翻译操作，类似转换格式：str.translate(映射表)返回值:新的字符串注意:translate用于多字符替换，replace用于长字符串替换 string模块相关内容 获取所有的空白字符:print (string.whitespace) 获取ascii码的所有字母表（包含大写和小写）:print(string.ascii_letters) 获取ascii码中的所有大写字母:print(string.ascii_uppercase) 获取ascii码中所有的小写字母:print(string.ascii_lowercase) 获取ascii码中所有10进制数字字符:print(string.digits) 获取八进制所有数字字符:print(string.octdigits) 获取十六进制的所有数字字符print(string.hexdigits) 打印所有可见字符print(string.printable) 打印所有标点符号print(string.punctuation) List类型 (列表)列表的定义和访问： 列表的定义变量 = [值,值,值….]列表的标志符号是[] 列表的访问操作列表变量：[索引位置]添加列表操作：不可以使用索引方式添加修改列表操作：列表变量[索引位置] = 新值删除列表操作：del 列表变量[索引位置] 列表的序列操作 索引操作格式： 列表变量[索引] 分片操作列表[:]表示获取列表的所有数据列表[开始索引：]表示丛开始索引位置截取到列表的最后列表[:结束索引]表示从列表的开头截取到结束索引位置之前，不包含结束位置列表[开始索引:结束索引]表示从列表的开始索引位置截取到结束索引位置之前，不包含结束位置列表[开始索引:结束索引:跳步值]表示从开始索引位置到结束索引位置之间，不包含索引位置，并且获取数据时索引每次+跳步值来获取，默认跳步值为1 序列相加格式：列表 = 列表1 + 列表2 列表相乘格式： 列表 = 列表1 * 整数结果：将列表重复N分组成新的列表注意： 数字必须为整数 成员资格运算格式1：数据 in 列表作用：检测数据是否在列表当中返回值：布尔值格式2：数据 not in 列表作用：检测数据是不是不在列表当中返回值：布尔值 最大、最小、长度计算 列表的遍历 for i in 列表: while i < length: 双层列表循环列表 = [[值1,值2],[值1,值2]，[值1,值2]…]for i,j in 列表: 列表内涵： list content 简单的列表内涵：格式：[[变量 for [变量 in 列表]作用：遍历列表中的数据并且组成新的列表，如果需要改变原有数据，在最开始i处修改结果：新的列表 带有判断的列表内涵格式 [变量 for 变量 in 列表 判断条件]作用：遍历列表中的数据，根据判断条件取出符合条件的数据组成新的列表结果:新的列表 多循环带判断的列表内涵格式：[[变量1+变量2 for 变量1 in 列表1 for 变量2 in 列表2 判断条件]作用：将列表1中和列表2中每个数据进行操作，但是必须在符合判断条件的前提下进行。结果：新的列表 序列函数 len() 获取列表的数据长度格式：len(列表)返回值：整型 max() 获取列表中的最大值格式：max(列表)返回值：列表中的最大值 min() 获取列表的最小值格式：min(列表)返回值：列表中的最小值 list() 将其他序列类型转化为列表格式：list(序列)返回值：列表 列表专用函数 append() 在列表的最后追加新数据格式： 列表.append(数据)返回值：无注意：该操作直接改变原有列表 insert() 在列表指定的位置插入数据格式：列表.insert（索引,数据）返回值：无注意：该操作直接改变原有列表 pop() 在列表中移除一个元素格式：列表.pop()返回值:移除掉的元素注意：移除列表最后的元素 格式：列表.pop(索引)返回值：:移除掉的元素注意：移除列表中指定索引的元素 remove() 在列表中移除指定的值的元素格式:列表.remove(值)返回值：无注意：该操作直接改变原有列表 clear() 清空列表格式：列表.clear()返回值：无注意：该操作直接改变原有列表 reverse() 列表反转格式：列表.reverse（）返回值：无注意：该操作直接改变原有列表 extend() 在原有列表最后追加新的序列格式:列表.extend(序列类型)返回值： 无注意：该操作直接改变原有列表 count() 计算指定值在列表中出现的次数格式: 列表.count(值)返回值：整数 copy() 复制原有列表格式: 列表.copy()返回值：新的列表 tuple类型(元组)元组的创建和特征 元组的创建创建空元组:变量 = ()创建单个数据的元组: 变量 = (值,) 或 变量 = 值,创建多个数据的元组: 变量 = (值,值，值…) 或者 变量 = 值,值，值… 元组的特征元组的关键符号是逗号而不是小括号。元组不具备修改功能。是一种特殊的列表。 序列操作 索引操作元组[索引位置] 分片操作元组[:]获取元素的所有数据元组[开始索引:]获取开始索引位置到最后的所有数据元组[:结束索引]获取元组开头到结束索引位置之前的所有数据（不包含结束位置）元组[开始索引:结束索引]获取元素开始索引位置到结束索引位置之间的所有数据（不包含结束位置）元组[开始索引:结束索引:跳步值]获取元素开始位置到结束索引之间的指定间隔的数据数据（不包含结束位置） 相加操作新元组 = 元组 + 元组 相乘操作新元组 = 元组 * 整数 成员检测格式1:数据 in 元组作用：检测数据是不是在元组当中返回值：布尔值格式2:数据 not in 元组检测数据是否不在元组当中返回值：布尔值 - 元组的遍历 for i in 元组： 双层元组循环元组 = ((值1,值2),(值1,值2)，(值1,值2)…)for i,j in 元组： 元组的函数 len() 获取元组中数据的长度格式： len(元组)返回值：整数 max() 返回元组中最大的值格式：max(元组) min() 返回元组中的最小值格式：min(元组) tuple() 将其他序列转化为元组类型格式： tuple(任意序列) 元组的方法 count() 计算指定数据出现的次数格式:元组.count(查找的数据)返回值：整数 index() 获取指定值在元组中的索引位置格式：元组.index(查找的数据)返回值：索引位置或者错误信息 变量交换 （元组特殊用法）a,b = b,a Dictionary类型(字典) 字典格式：变量 = {键:值,键:值….} 键就是标志或者说是目录,值就是真实的值 字典的标志符号是{} 字典的创建和特征 创建空字典变量 = {} 或者 变量 = dict() 创建有数据的字典变量 = {键:值,键:值,键:值…}变量 = dict({键:值,键:值,键:值…})变量 = dict(键=值,键=值,键=值…)变量 = dict([(键,值),(键,值),（键,值）…])变量 = dict(zip((键，键，键….),(值,值，值…))) 字典的特征字典也是序列类型但是是无序序列，所以分片操作无法使用字典中每个数据都由键和值两部分组成：值：任意数据都可以当作值来使用键：可以使用 int，float,str,tuple，冰冻集合，但是list，set，dict等不可以使用 字典的基本操作 访问数据：字典变量[键] 添加数据字典变量[新键] = 值 修改数据字典变量[键] = 新值 删除数据del 字典变量[键] 序列操作 检测数据是否在字典的键中格式：数据 in 字典 检测数据是否不再字典的键中格式：数据 not in 字典 遍历操作 键遍历操作: for k in 字典: 键值遍历: for k,v in 字典.items()： 字典内涵 基本的字典内涵变量= {key:value for key,value in 字典.items()} 带有条件的字典内涵变量 = {key:value for key,value in 字典.items() if 条件} 字典函数 len() 计算字典的长度格式： len(字典)返回值:字典的长度 max() 获取字典中的最大值 （默认比较字典的键）格式:max(字典)返回值：最大的键 min() 获取字典中的最小值（默认比较字典的键）格式：min(字典)返回值:最小值 dict() 将其他序列转化为字典详情请看字典的定义 str(字典) 返回字典的字符串格式 字典方法 clear() 清空字典格式：字典.clear()返回值：无 None注意：直接改变原有字典 items() 获取字典的键值对组成的元组格式格式：字典.items()返回值：将键值对变成元组的列表形式。注意:返回的数据是内建的dict_items类型，专用于字典的转换中间类型 keys() 获取字典中所有键组成的序列，常用语字典遍历格式： 字典.keys()返回值:返回所有键的组合注意：类型为 dict_keysL类型，也是一种字典转换的中间类型 values() 获取字典中所有值组成的序列，常用语字典遍历格式： 字典.values()返回值：所有值的组合注意：类型为dict_values类型，也是一种字典转换的中间类型 get（） 根据指定的键获取值格式：字典.get(键,默认值)返回值：字典键对应的数据注意：如果键不存在与字典中，则返回默认值而不会报错 pop() 根据键从字典中删除数据格式:字典.pop(键)返回值：删除的键对应的值注意：pop在字典中使用必须有参数，因为字典无序序列，直接改变原有字典 copy() 赋值一个字典格式：字典.copy()返回值：复制出来的新的字典 setdefault() 设置字典中不存在的键的值格式：字典.setdefault(键,默认值)返回值：设置时的默认值注意：如果设置时键已经存在于字典中，则不进行任何操作，直接改变原有字典 fromkeys() 使用指定的序列作为键,使用一个值作为字典的所有值格式:字典.fromkeys(序列,值)返回值：由序列作为字典的键，由值作为所有键对应的值组成的字典 update() 使用字典更新另外一个字典格式：字典1.update(字典2)返回值：无注意:直接改变原有字典 Set类型（集合）集合的创建和特征 创建空集合变量 = set() 创建多个数据的集合变量 = {值,值,值….} 集合的特征集合是一种无序的数据类型，无法通过索引和分片进行操作集合是内部元素绝对唯一的数据，常常用于去掉重复数据集合的数据，str，int，float,bool,tuple，冰冻集合。 集合序列操作 检测数据是否在集合当中格式：数据 in 集合 检测数据是否不在集合当中格式：数据 not in 集合 集合遍历操作 for i in 集合: 带有元组的集合遍历集合 = {(值1,值2..),(值3,值4..)…}for i,j in 集合: 集合内涵 普通集合内涵新集合 = {变量 for 变量 in 集合} 带条件的集合内涵新集合 = {变量 for 变量 in 集合 if 条件} 多循环的集合内涵新集合 = {变量1+变量2 for 变量1 in 集合1 for 变量2 in 集合2 if 条件} 集合函数 len() 获取集合中元素的个数格式:len(集合)返回值：整数 max() 获取集合中最大的元素格式:max(集合)返回值：集合中最大的值 min() 获取集合中最小的元组格式：min(集合)返回值：集合中的最小值 set() 将其他序列转化为集合类型格式：set(序列)返回值：集合类型 集合方法 add() 向集合中添加数据格式： 集合.add(数据)返回值：无注意：直接改变原有集合，已存在的数据无法添加 clear() 清空集合格式：集合.clear()返回值：无注意：直接改变原有集合 copy() 集合复制格式:集合.copy()返回值:原集合所有数据组成的新的集合 remove() 移除指定的值格式:集合.remove(值)返回值：无注意：直接改变原有集合，如果要删除的值不存在，就报错 discard()移除集合中指定的值格式:集合.discard(值)返回值：无注意：直接改变原有集合，如果要删除的值不存在，就不作任何操作 pop() 随机移除一个元素格式：集合.pop（）返回值：被移除的元素注意：随机移除元素，没啥规律 intersection() 计算两个值集合之间的交集格式： 集合1.intersection(集合2)返回值：新的集合 difference() 计算两个集合之间的差集格式： 集合1.difference(集合2)返回值:新的集合 union() 计算两个集合之间的并集操作格式：集合1.union（集合2）返回值：新的集合 issubset() 检测一个集合是否是另外一个集合的子集格式：集合1.issubset(集合2)返回值：布尔值 issuperset() 检测一个集合是否是另外一个和集合的超集格式：集合1.issuperset(集合2)返回值：布尔值 difference_update（） 计算集合1和集合2的差集并且将结果赋值给集合1格式：集合1.difference_update(集合2)返回值:无注意：操作结果直接赋值给集合1 intersection_update() 计算集合1和集合2的交集并且将结果赋值给集合1格式：集合1.intersection_update(集合2)返回值：无注意:操作结果直接赋值给集合1 update() 计算集合1和集合2的并集并且将并集结果赋值给集合1格式：集合1.update(集合2)返回值:无注意:操作结果直接赋值给集合1 冰冻集合/固定集合 frozen 冰冻集合就是不可以进行任何修改相关操作的集合 创建冰冻集合创建空的冰冻集合: 变量 = frozenset()创建具有数据的冰冻集合: 变量 = fronzenset(一个序列) 操作方法和函数冰冻集合的操作相关函数和方法同集合类型一样。只是不可以使用修改集合相关的方法和函数。 注意:frozenset 和普通的集合一样没有什么本质区别，能够使用的函数数量不一样，仅此而已哦 数据类型转换自动类型转换类型转换会向着更加精确的类型进行转换 强制类型转换强制类型转换是根据程序需要，由程序员通过操作强制改变数据的类型。 int（) 强制将数据转化为整型纯数字字符串转化为整型时，类型改变，值不变只有纯整数字符串才可以转换，其他均不可以浮点型可以转化为整型，去掉小数点后面的部分 float() 强制将数据转化为浮点型整数字符串和浮点数字符串均可以转化为浮点型转化过程中类型改变，值不变整型也可以用于浮点型转换 complex（） 生成一个复数 bool() 强制将数据转化为布尔值能够转化为布尔值False的情况：① 字符串 空字符串 ② 整型 0 ③浮点型 0.0 ④ 复数 0+0j ⑤ 布尔值 Flase ⑥ 列表 [] 空列表 ⑦ 元组 () 空元组 ⑧ 字典 {} 空字典 ⑨ 集合 set（）空集合 str() 字符串类型转换所有数据类型都可以转换为字符串，转换规则就是在原有数据基础上加了引号变成了字符串的格式。例如：[1，2，3] =“[1，2，3]” list() 将其他数据转换为列表类型能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据） tuple() 将其他数据类型转换为元组类型能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据） dict() 将其他数据转化为字典类型字典类型转换可以转化的类型有三种：list 、tuple 、set以上所有类型的每个数据必须由元组组成，并且每个元组必须有2个值例子：{(‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’)}[(‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’)]((‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’)) set() 集合类型转换能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据） 字符串格式化利用百分号格式化 %d 此处应该放入一个整数12s = \"i am %d years old\"print (s%18) %s 放入一个字符串 123s = \"i am %s\"print (\"i love %s\"%\"KI\")print (s%\"KIOVEN\") 如果出现多个占位符，则相应内容需要用括号括起来 12s = \"i am %s,i am %d years old\"print (s%(\"ouwen\",18)) 利用format格式化 以{}和： 代替%号，后面用format带参数完成12345s = 'i love {}'.format(\"you\")print (s)s = \"i am {1} years old,i love {0} and {1} years old\".format(\"tulingxueyuan\",24)print (s) 表达式、运算符表达式由变量、运算符、数字、数字分组符号（括号）等以能求得数值的有意义排列方法所得的组合。 运算符的分类 算术运算 比较运算/关系运算 赋值运算 逻辑运算 位运算 成员运算 身份运算 算数运算+ - * / %(取余) //(地板除，取商) **幂运算 注意： python中没有自增自减的 ++ 或者– 运算 混合计算时，Python会把整型转换成为浮点数 比较运算== ！= > < >= 移动位数特征：右移N位相当于除以2的N次方，舍弃小数部分。此方法速度远高于除法 成员运算 in 检测一个值在指定的序列类型里面格式： 值 in 可迭代序列 not in 检测一个值是否不再指定的序列里面格式： 值 not in 可迭代序列 身份运算 is 检测值1是不是和值2在内存中是否是同一个值，类似id()功能格式: 数据1 is 数据2 is not 检测值1是不是和值2在内存中是否不是同一个值，类似id()功能格式: 数据1 is not 数据2 检测数据归属 type() 测试时可以使用，开发尽量避免使用格式：type(变量) isinstance() 检测一个数据是否由指定的类型创建格式：isinstance(变量，检测的类型) 运算优先级问题1234567891011121314** 指数 (最高优先级) ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) * / % // 乘，除，取模和取整除 + - 加法减法 >> = 比较运算符 == != 等于运算符 = %= /= //= -= += *= **= 赋值运算符 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 注意：我们并不推荐死记硬背优先级，在实际使用中最好使用()解决优先级问题 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"author":"DU"},{"title":"HTML 前端课程","slug":"Html/01.Html","date":"2019-04-04T10:11:07.000Z","updated":"2019-07-21T01:21:36.743Z","comments":true,"path":"2019/04/04/Html/01.Html/","link":"","permalink":"http://yoursite.com/2019/04/04/Html/01.Html/","excerpt":"","text":"前端介绍1234561.HTML (常用标签 网页的基本结构)2.CSS (常用样式 网页的显示效果)3.JavaScript (用户交互效果 动态效果)4.jQuery (JavaScript库 简化原生js操作)5.Ajax (异步数据交互 在页面不刷新的情况下进行数据交互)6.BootStrap (前段UI框架 快速搭建静态页面并支持不同设备) HTML概述什么是HTMLHTML 是用来描述网页的一种语言。 超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。 HTML 不是一种编程语言，而是一种标记语言 标记语言是一套标记标签 (markup tag) HTML 文档包含了HTML 标签及文本内容 HTML文档也叫做 web 页面 HTML是干嘛的 可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。 建立HTML文件 .html .htm HTML注释1 HTML网页的基本结构12345678910111213# 第一行是声明文档：告诉浏览器以什么html版本解析我们的代码 声明为 HTML5 文档 html是我们网页当中最大的标签,根元素 头，元素包含了文档的元（neta)数据 体，元素包含了可见的页面内容 HTML标签结构HTML 标记标签通常被称为 HTML 标签 (HTML tag)。 HTML 标签是由尖括号包围的关键词 HTML 标签通常是成对出现的 标签对中的第一个标签是开始标签，第二个标签是结束标签 1内容 HTML元素“HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思. 一个 HTML 元素包含了开始标签与结束标签 HTML属性 HTML 元素可以设置属性 属性一般添加在开始标签 () 属性一般以名称/值对的形式出现，比如：name=”value”。 注意： 属性值必须用双引号引起来 标签都用小写字母 双标签必须要写闭合标签 HTML常用标签HTML常用的块级标签（块级元素） 独占一行 有语义的HTML块级元素 有默认样式 标题（Heading） 通过H1～H6 标签来定义的. 段落 通过标签 p 来定义的. 列表无序列表 ul,li 是一个项目的列表,列项目使用粗体圆点（典型的小黑圆圈）进行标记 1234 l列表项1 列表项2 有序列表 ol,li 也是一个项目的列表，列表项目默认使用数字进行标记。有序列表当中有type属性，设置列表的标记类型1234 l列表项1 列表项2 自定义列表 dl,dt,dd（了解）1234 这是自定义标题 这是自定义列表项 注意：列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。 表格 table,tr,tdtable常用属性 border 边框 cellpadding 内容距离表框的距离 cellspacing 单元格和单元格之间的距离 rowspan 垂直合并（跨行显示） colspan 水平合并（跨列显示） anglin 内容水平对其方式 valign 内容垂直对其方式123456789 第一行、第一列 第一行、第二列 第二行、第一列 无意义的块级元素 div123 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示换行。一般与 CSS 一同使用 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。 HTML常用的行级标签（行内元素）不独占一行 有语义的行内元素HTML链接 a标签1链接文本 target属性，定义被链接的文档在何处显示 _blank 新窗口打开 HTML图像1 文本标签 b标签 i标签 strong标签 em标签 无语义的行内元素 span标签 配合css使用 常用的实体字符1&gt;&lt;&copy; 表单标签表单是一个包含表单元素的区域。通过form来定义表单区域 通过type属性定义不同类型的表单控件 text 普通文本输入框 password 密码输入框 radio 单选按钮 checked 多选按钮 select 下拉框 file 文件上传选框 textarea 文本域 submit 提交按钮 reset 充值按钮 hidden 隐藏域，要和表单单一其提交的信息 常用属性：123456name 属性：表单项名，用于存储内容值value属性：输入的值disabled属性：禁用属性readonly属性：禁用属性checked属性：选择框指定默认选项placeholder：提示 注意：12345678form 有两个必须存在的属性 action提交地址 metchod提交方式post:通过request body传参，参数不可见，参数没有大小限制get:通url进行传参，参数可见，不安全，大小有限制，如果表单中含有文件上传 method提交方式必须为post form中必须有enctype属性 enctype=\"multipart/form-data\" document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/categories/HTML/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}],"author":"DU"},{"title":"MySQL 语法「四」","slug":"MySQL/04.MySQL","date":"2018-11-15T10:11:07.000Z","updated":"2019-07-21T01:21:36.749Z","comments":true,"path":"2018/11/15/MySQL/04.MySQL/","link":"","permalink":"http://yoursite.com/2018/11/15/MySQL/04.MySQL/","excerpt":"","text":"MySQL 语法「四」 日志 备份 日志分类 错误日志 查询日志 慢查询日志 二进制日志 中继日志 innodb 存储引擎级别的事务日志 错误日志mysql 执行过程中的错误信息、警告信息、event schedule运行时产生的信息、mysql 启动和停止过程的输出信息、主从结构中，从服务器IO复制线程的启动信息。常用 log_error 和 log_warning 来定义。show variables like “%log_errror%”; log_warning: 标识告警信息是否一并记录到错误日志中、为 0 表示不记录告警信息 、为1表示告警信息一并记录到错误日志中。大于1 表示失败的连接 的信息和创建新连接时 拒绝访问类的错误信息也会被记录到错误日志。show variables like “%log_warning%”; 查询日志12345678mysql> show variables where variable_name like \"%general_log%\" or variable_name=\"log_output\";+------------------+----------------------------------+| Variable_name | Value |+------------------+----------------------------------+| general_log | OFF || general_log_file | /var/lib/mysql/VM_0_2_centos.log || log_output | FILE |+------------------+----------------------------------+ general_log：表示查询日志是否开启。默认为OFF 慢查询日志 show variables like “slow_query_log%”;show variables where variable_name like “%slow_query%” or variable_name like “log_output”;show variables like “slow_query_log%”;log_slow_queries： 是否开启慢查询log_output:慢查询开启后以哪种方式存放FILE：表示慢查询日志存放于指定的文件中TABLE：表示慢查询日志存放于mysql库的slow_log表中FILE,TABLE：同时存放于指定文件和slow_log 表中NONE：不记录查询日志slow_query_log_file:log_output设置为FILE时，指定慢查询日志存储于哪个日志文件中。默认文件名为 “ 主机名-slow.log” ，位置为datadir参数。long_query_time:认定的慢查询时间log_queries_not_using_indexes:如果运行的sql语句没有使用到索引，是否也被当做慢查询记录到慢查询日志中，OFF 表示不记录，ON 表示记录。set global slow_query_log=ON;show variables where variable_name like “%slow_query%” or variable_name like “log_output”;show variables like “slow_query_log%”;set global long_query_time=3;select @@global.long_query_time;举例：select sleep(5);tail -fn6 /var/lib/mysql/show global status like ‘%slow_queries%’; mysqldumpslow 命令mysql自带的对慢查询日志的统计分析工具。只能作用于慢查询日志文件，不会统计slow_log表。mysqldumpslow -s t /var/lib/mysql/cos72ini-slow.logmysqldumpslow -s r /var/lib/mysql/DU-HOST-slow.logc :执行计数i:锁定时间r:返回记录t:执行时间al：平均锁定时间ar:平均返回记录数mysqldumpslow -s r -t 2 /var/lib/mysql/DU-HOST-slow.log -t 指明查看多少条统计信息。查看两条统计信息。 其他选项mysqldumpslow –help 二进制日志 binlog ：记录所有修改数据的语句、有可能改变数据库的语句—–主要用于时间点恢复（备份恢复），以及主从复制结构。 三种模式：statement模式：记录对数据库修改的语句。row模式：记录对数据库做出修改的语句所影响的数据行以及这些行的修改。mixed模式：混合以上两种模式，一般语句使用statement模式，特殊函数使用row模式记录。my.cnf 配置binlog.format=row 二进制日志相关参数：log_bin:控制是否开启二进制日志。只读变量，只能通过修改my.cnf，设置log_bin的值sql_log_bin: 当前会话的操作是否会被记录于二进制中binlog_format:二进制日志的记录方式max_binlog_size:设置单个二进制日志文件的最大大小sync_binlog：show binary log;show master logs; 查看二进制日志文件①show binlog events in ‘二进制文件名’;指定位置查看：②show binlog events in ‘二进制文件名’ from 24 ;limit 3 ;limit 100,10;③show master status;查看当前使用的二进制文件，以及位置。 滚动二进制日志flush logs; 备份 备份相关术语：全量备份：对某个时间点的数据完全的备份差异备份：增量备份：对上一次备份后的变化的数据的备份时间点恢复热备：在数据库正常运行的情况下备份温备：备份期间数据库只能进行读。不能进行写操作冷备：备份期间。读写均不可操作物理备份：直接备份数据库对应的数据文件逻辑备份：建数据从数据导出，并且将导出的数据进行存档备份 常用的备份工具：mysqldumpxtrabackupselect 语句进行部分备份cp、tar命令。适于冷备。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}],"author":"DU"},{"title":"MySQL 语法「三」","slug":"MySQL/03.MySQL","date":"2018-11-14T10:11:07.000Z","updated":"2019-07-21T01:21:36.747Z","comments":true,"path":"2018/11/14/MySQL/03.MySQL/","link":"","permalink":"http://yoursite.com/2018/11/14/MySQL/03.MySQL/","excerpt":"","text":"MySQL 语法「三」 增、删、改、查等 查询缓存 存储引擎 增、删、改、查 等 insert① insert into tb1（name,age) values(‘tom’,33);insert into tb1(name,age) values(‘jerry’,33),(‘naruto’，28）；insert into tb1 values(4,’sasuke’,28),(5,’hinata’,25);② insert into tbl set id=2,name=’test’,age=18; deletedelete from tb1;delete from tb1 where age=22;delete from tb1 where name like ‘k.*’;delete from tb1 where age > 30 order by age desc limit 1; updateupdate tb1 set age=28;update tb1 set name=’kkkk’ where id=3;update tb1 set name=’xxxx’,age=22 where id=5; select① select from tb1 limit 3;select from tb1 where age>=25 and age 20;⑦ 多表查询：select * fomr t1,t2; 查询缓存 查看当前服务是否开启缓存show variables like ‘%query_cache%’;mysql> show variables like ‘%query_cache%’;+——————————+———+| Variable_name | Value |+——————————+———+| have_query_cache | YES | YES 支持缓存| query_cache_limit | 1048576 | 单挑查询缓存的最大值，默认1M。超过大小结果不会被缓存。| query_cache_min_res_unit | 4096 | 缓存存储于内存的最小单元，默认4K。| query_cache_size | 1048576 | 查询缓存的总大小| query_cache_type | OFF | ON、OFF、DEMAND 分别表示启用、禁用、按需缓存| query_cache_wlock_invalidate | OFF |+——————————+———+6 rows in set (0.00 sec) 使用：① 在开启缓存（query_cache_type=ON) 指定对应的查询语句不使用缓存：select sql_no_cache name from stu;②在按需缓存（query_cache_type=DEMAND) 指定对应的查询语句使用缓存：select sql_cache name from stu; 举例：在 my.cnf 设置查询未 按需缓存，缓存空间大小100Mquery_cache_type=DEMANDquery_cache_size=100M 清除查询缓存中已经存在的缓存reset query cache; 存储引擎 存储引擎也称为 “ 表类型”，每张表可以使用不同的存储引擎类型。MYISAM: 支持级锁，不支持行级锁、不支持事务、不支持外部约束，支持全文索引，表空间文件较小INNODB：支持表级锁、行级锁、事务、外检，不支持全文索引，表空间较大。CSV：MRG_MYISAM：BLACKHOLE：MEMORY：PERFORMANCE_SCHEMA：FEDERATED：ARCHIVE：FEDRATED： 查看表类型，查看存储引擎show engines;show create table t1;show table status \\G;show table status like ‘%t1%’ \\G; 设置存储引擎/ 表类型：在创建表的时候指定： create table t1 (id int(10) default null) ENGINE=innodb; 修改表的存储引擎/修改默认表类型：alter talbe t1 ENGINE=myisam; 修改默认的存储引擎vim /etc/my.cnfdefault-storage-engine=innodbinnodb_file_per_table=on 事务 事务： 一组sql语句的集合。当做一个操作单元。（要么都执行成功、要么全部失败）mysql 中，innodb 存储引擎是支持事务的，完全符合ACID 特性。A： atomicity 原子性C: consistency 一致性I: isolation 隔离性D: durability 持久性 redo log ：mysql 会将事务中的sql 语句涉及到的所有数据操作先记录到redo log 中，然后将操作从redo log 中执行。redo log ：包含 redo log buffer(重做日志缓冲）和 redo log file(重做日志文件)redo log buffer :存在于内存中redo log file： 存在于磁盘上 undo log : 数据被修改前的备份。 log group:重做日志组。有多个重做日志文件 事务日志参数： 12345678910111213141516171819show global variables like '%innodb%log%';mysql> show global variables like '%innodb%log%';+----------------------------------+-----------+| Variable_name | Value |+----------------------------------+-----------+| innodb_api_enable_binlog | OFF || innodb_flush_log_at_timeout | 1 || innodb_flush_log_at_trx_commit | 1 | 表示事务提交以后，是否立即将redo log 从内存耍写到redo log file 中。| innodb_locks_unsafe_for_binlog | OFF || innodb_log_buffer_size | 8388608 || innodb_log_compressed_pages | ON || innodb_log_file_size | 50331648 | 每个redo log file 的大小。| innodb_log_files_in_group | 2 | 每个重做日志组中有几个 redo log file| innodb_log_group_home_dir | ./ | 重做日志组文件所在路径，默认为 /var/log/mysql 此目录中的 lib_logfile0 和 lib_logfile1 即为日志组的两个重做日志5M，也对应了innodb_log_file_size 的值。| innodb_mirrored_log_groups | 1 | 一共有几组日志组| innodb_online_alter_log_max_size | 134217728 || innodb_undo_logs | 128 |+----------------------------------+-----------+12 rows in set (0.03 sec) 事务控制语句查看是否开启自动提交功能：show global variables like ‘autocommit%’;show session variables like ‘autocommit%’; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}],"author":"DU"},{"title":"MySQL 语法「二」","slug":"MySQL/02.MySQL","date":"2018-11-12T10:11:07.000Z","updated":"2019-07-21T01:21:36.746Z","comments":true,"path":"2018/11/12/MySQL/02.MySQL/","link":"","permalink":"http://yoursite.com/2018/11/12/MySQL/02.MySQL/","excerpt":"","text":"MySQL 语法「二」 约束、键 索引 视图 约束 常用约束：主键约束、唯一键约束、外键约束、非空约束等主键 primary key ： 一个或多个字段的组合。只能有一个主键唯一键 unique key：字段的数据必须不同于已经存在的其他行上的数据，但可以为空。可以有多个唯一键外键：foreign key。 一个表中的外键字段中所有能插入的数据取值范围，取决于引用的另一个表上主键字段上的已经存在的数据集合检查条件约束：check，自定义的逻辑表达式 非空约束添加非空约束：alter table testtb modify name varchar(100) not null;删除非空约束：alter table testtb modify name varchar(100) null; 自动增长添加自动增长：alter table testtb modify id int auto_increment;alter table testtb change id id int auto_increment;删除自动增长：alter table testtb change id id int;alter table testtb modify id int; 主键约束添加主键约束：alter table testtb add primary key(id);alter table testtb add constraint primary key(id);删除主键约束：alter table testtb drop primary key;注意：如果对应的主键上存在自动增长，则不能直接删除主键，需先删除自动增长后，在删除主键。 唯一性约束添加唯一性约束：alter table testtb add unique key(uid);alter table testtb add unique key uni_test(test);删除唯一键约束：alter table testtb drop index uni_test; 外键约束添加外键约束：alter table testtb add column tid int defalut 0 not null;alter table testtb and constraint testtb_tid_kd foreign key(tid) references testtb2(id);删除外键约束：alter table test4 drop foreign key test_tid_fk; 查看约束select * from information_schema.key_column_usage where table_name=’test1’; 索引 索引管理单纯的值index添加一个单纯的索引：① alter table testtb add index ind_name(name);②create index ind_name on testtb(name);create index ind_name on testtb(name(20);create index ind_name on testtb(name(20) desc); 联合索引create index ind_id_name on test1(id,name);create index ind_id_name on testtb1(id,name(20)); 重建索引repair table table_name quick; 删除索引alter table test2 drop index uu_ttt; 查看索引show index from testtb;show index form testtb key_name like ‘ind%’; 视图 创建视图select create_view_priv,,select_priv from mysql.user where user=’root’ and host=’%’;create_view_priv 的值为Y，表示当前用户拥有创建视图的权利。create view testvi as select from classes where classid { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}],"author":"DU"},{"title":"MySQL 语法「一」","slug":"MySQL/01.MySQL","date":"2018-11-08T10:11:07.000Z","updated":"2019-07-21T01:21:36.752Z","comments":true,"path":"2018/11/08/MySQL/01.MySQL/","link":"","permalink":"http://yoursite.com/2018/11/08/MySQL/01.MySQL/","excerpt":"","text":"MySQL 语法 MySQL 管理 MySQL 用户、授权 MySQL 库 MySQL 表 MySQL 管理启动和关闭 不是通过RPM包安装的MySQL启动： /usr/bin/mysqld_safe &关闭： mysqladmin -uroot shutdown -p MySQL 连接 -D 指定将要登录的具体的数据库mysql -uroot -D test -p123456 本地连接mysql，-S 指定套接字位置mysql -u root -p -S /var/lib/mysql/mysql.sock 远程连接mysql，-P 指定mysql服务对应的端口mysql -u root -p 123456 -h 192.168.1.1 -P 3306 连接数据库的同时执行对应命令，并返回结果，不进入mysql 提示符mysql -uroot -p123456 -e ‘use mysql; select user,host,passwd from user;’mysql -uroot -p123456 -e ‘create database if not exists testdb;show databases;’ Help help create help create databases help contents help ‘Data Types’ mysql的属性、状态、变量 mysql> status 系统变量：配置了mysql的运行环境属性 全局变量：global variables ,作用域为整个mysql服务器show global variables；版本相关： show global variables like ‘%version%’ ;字符集相关： show global variables where variable_name like ‘character%’;日志是否关闭： show global variables where variable_name like ‘%log%’ and value=’off’; 会话变量：session variables，作用域为当前会话show session variables;show variables; 查看单个全局系统变量或者会话系统变量：select @@[global | session].system_var_name;select @@global.pid_file;select @@session.warning_count; 状态变量：mysql运行中的状态信息，不能设置。查询mysql运行中信息和状态：状态变量也分为全局级别与会话级别show status;show global status;show session status;show status where variable_name like ‘Uptime%’; 在写储存过程中，调用系统变量的值：@@GLOBAL.var_name@@SESSION.var_name@@var_name 表示优先从会话级别获取变量值 修改变量值/设定变量值:① 运行时修改：是否立即生效取决于修改的变量的类型，set 命令，运行时修改变量运行时修改global级别的变量：对修改之前建立的会话没有影响，仅对修改后新建立的会话有效运行时修改session级别的变量：仅对当前会话有效，且立即生效② 配置文件修改：重启后生效。例：③ set @@session.autocommit=0;设置系统变量语法总结：set global.var_name = value;set @@global.var_name = value;set session.var_name = value;set @@session.var_name = value;set var_name = value; 不指定级别表示默认为设置会话级别的变量。 MySQL 用户MySQL 用户管理 mysql 的用户格式： usernmae@hosthost: 主机名 或者 IP ，mysql 认为主机名 和 IP地址属于不同的主机。通配符： ： 表示任意单个字符%： 表示任意长度的任意字符root@’10.1.%.%’ root用户可以通过10.1这个网段远程登录 查询用户use mysqlselect user,host,passwd from user; 创建用户① create user ‘zabbix_proxy‘@’localhost’ identified by ‘zabbix_asp_2017’;② 直接在mysql库的user 表中插入一条记录。（设置了严格的sql-mode 后无法使用）insert into mysql.user(user,host,passwd) values(‘pan’,’192.168.%.%’,passwd(‘123456’));③ 在授权数据库的同时，如果对应的用户不存在，那么mysql会自动创建对应的用户。grant all on pan.*to pan@127.0.0.1 identfied by ‘123456’; 删除用户① delete 语句删除mysql.user 表中的用户对应的记录，有相关信息残留。delete from mysql.user where user=’pan’ and host=’127.0.0.1’;② drop user pan@127.0.0.1 用户与用户对应的所有权限将被删除。 重命名用户：rename user oldname to newname; MySQL 密码管理 更改用户名密码，官方推荐使用alterALTER USER test@’%’ IDENTIFIED BY ‘123456’; update mysql.user set authentication_string=password(“新密码”) where User=”test” and Host=”localhost”;flush privileges; 忘记root密码① vi /etc/my.cnf，在[mysqld]中添加skip-grant-tables② 重启mysql : systemctl restart mysqld.service③ mysql -uroot -p④ use mysql;⑤ 修改root密码：update user set authentication_string=password(‘123456’) where user=’root’;flush privileges;⑥ 删除第1部增加的配置信息skip-grant-tables⑦ 重启mysql ： systemctl restart mysqld.service 授权管理 授权命令：GRANT ALL privileges on db.tbl to ‘username‘@’host’ identified by ‘passwd’;db 数据库名 tbl 表名 可以使用通配。示例：给本地用户授权某个数据库的所有权限grant all privileges on pandb. to pan@localhost identified by ‘123456’;grant all on pandb.* to pan@localhost identified by ‘123456’; privileges 关键字可省 给远程用户授权grant all privileges on panthink.* to pan@’192.168.%.%’ identified by ‘123456’;flush privileges; 授权用户某个数据库的某个权限，比如，只授权用户对于某个数据grant select privileges on panthink.* to pan@’192.168.%.%‘； 授权某个数据库多个权限：grant insert,delete,update,select on panthink.* to pan@’192.168.%.%’; 授权给多个用户：grant select on mydb.* to pan@locakhost,pan2@localhost; 对某张表的某个字段授权：grant select(name,age) on pan.students to pan@localhost; 授权test函数，用function关键字指明被操作的对象是函数：grant execute on fuction panthink.test to pan@’192.168.%.%’; 强制用户使用ssl建立会话grant useage on . to ‘zabbix‘@’222.222.222.222’ require ssl;取消ssl 连接限制grant useage on . to ‘zabbix‘@’222.222.222.222’ require none; 赋予用户授权的权限授权zabbix用户db01 的 select权限，同时zabbix 用户也能将此权限授予给其他用户grant select on db01.* to ‘zabbix‘@’192.168.%.%’ with grant option; 查看授权：从用户： show grants for 用户名；从数据库：select * from mysql.db where db=”要查看的数据库“； 删除授权：revoke ‘要删除的权限’ on db.tb from user@host;删除zabbix@192.168.1.1 用户对于word数据库的所有权限:revoke all on word.* from zabbix@192.168.1.1; 库管理 创建数据库create database if not exists testdb charaacter set utf16; 查看数据库show databases;show create database testdb;查看可用的字符集的命令show character set;查看排序方式的命令show collation； 修改数据库alter database testdb character set utf 8;修改数据库的字符集，并设置为默认字符集，数据库中的表都会继承此字符集。alter database testdb default character set utf8; 删除数据库drop database if exists testdb; 数据库导出mysqldump -u user_name -p database_name > 导出的文件名 导出一个数据库结构（不包含数据）mysqldump -u user_name -p -d –add-drop-table database_name > outfile_name.sql 带语言参数导出mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name > outfile_name.sql 表管理 查看表的状态show table status where name like ‘%tt%’;desc table_name;查看某张表创建时对应的sql 语句show create table table_name;复制表，但字段的约束和表的索引会丢失。create table testtb2 select * from students;完全的复制表结构create table testdb3 like students; 修改表：重命名表alter table test1 rename as test2;为表添加字段alter table ttt add cloumn age int;alter table ttt add age int; // 省略cloumn 默认为操作列。添加字段设定相应的约束：alter table ttt add age int not null default 0;alter table ttt add cloumn age int not null default 0;添加字段，指定字段在表中的位置：alter table ttt add id int first;alter table hosts add categoryof varchar(200) DEFAULT NULL after templateid;删除字段：alter table ttt drop stuname;重命名字段：alter table tsettb4 change name name1 char(20);修改字段类型：alter table testtb change age age char(20);alter table testtb modify age int; // modify 不能修改字段名称。 导出单个数据表结构和数据mysqldump -u user_name -p database_name table_name > outfile_name.sql 导出单个数据表结构（不包含数据）mysqldump -h localhost -uroot -p123456 -d database table > dump.sql document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/categories/MySQL/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}],"author":"DU"},{"title":"Linux Awk","slug":"Linux/04.Awk","date":"2018-11-06T10:11:07.000Z","updated":"2019-07-21T01:21:36.745Z","comments":true,"path":"2018/11/06/Linux/04.Awk/","link":"","permalink":"http://yoursite.com/2018/11/06/Linux/04.Awk/","excerpt":"","text":"概述awk是linux环境下的一个命令行工具，但是由于awk强大的能力，我们可以为awk工具传递一个字符串，该字符串的内容类似一种编程语言的语法，我们可以称其为Awk语言，而awk工具本身则可以看作是Awk语言的解析器。就好比python解析器与Python语言的关系。我们一般使用awk来做什么，awk又适合做什么工作呢。由于awk天生提供对文件中文本分列进行处理。所以如果一个文件中的每行都被特定的分隔符(常见的是空格)隔开，我们可以将这个文件看成是由很多列的文本组成，这样的文件最适合用awk进行处理，其实awk在工作中很多时候被用来处理log文件，进行一些统计工作等。 awk 基础awk [options] ‘Pattern{Action}’ file BEGIN、ENDawk ‘BEGIN{print “aaa”,”bbb”} { print $1,$2}’ testawk ‘{print $1,$2} END{print “ccc”,”ddd”}’ test awk 分隔符： 输入分割符：FSawk -F# ‘{print $1,$2}’ testawk -v FS=’#’ ‘{print $1,$2}’ test 输出分隔符:OFSawk -v OFS=”+++” ‘{print $1,$2}’ testawk -v FS=”#” -v OFS=”—“ ‘{print $1,$2}’ test awk 变量： awk常用的内置变量：FS ： 输入字段分割符OFS： 输出字段分隔符RS：输入换行符ORS：输出换行符NF：字段数量NR：行号FNR：各文件分别计数的行号FILENAME: 当前文件名ARGC：命令行参数的个数ARGV：数组 NR、FNRawk ‘{print NR,$0}’ testawk ‘{print FNR,$0}’ test 内置变量RSawk -v RS=” “ ‘{print NR,$0}’ test 内置变量 ORSawk -v ORS=”+++” ‘{print NR,$0}’ test 内置变量FILENAMEawk ‘{print FILENAME,$0}’ test 自定义变量awk -v myvar=”test” ‘BEGIN{print myvar}’awk ‘BEGIN{myvar=”ttt”;print myvar}‘awk ’BEGIN{myvar1=”111”;myvar2=”222”;print myvar1,myvar2}’ awk 格式化：awk中如果输出字符的话，有两种处理方式。printf和printprintf：可以自定义输出的模式，另外输出内容之后不自动换行print：输出内容之后自动换行awk ‘{printf “第一列：%s 第二列 %s\\n”,$1,$2}’ testawk ‘BEGIN{printf “%s\\n%s\\n%s\\n%s\\n%s\\n”,1,2,3,4,5}’总结：使用printf 动作输出的文本不会换行，如果需要换行，可以在对应的格式替换符 后 加入 \\n 进行转义。使用printf 动作时，格式中的格式替换符必须与被格式化的文本一 一 对应。 awk 模式： 正则模式：awk ‘/^root/{print $0}’ /etc/passwdawk ‘/\\/bin\\/bash$/ {print $0}’ /etc/passwd 转义使用（x，y） 这种次数匹配的正则表达式时，需要配合 –posix 或者 –re-interval 选项。字母e最少连续出现两次，最多只能连续出现三次:awk –posix ‘/he(2,3)y/ {print $0}’ test正则模式：awk ‘/正则1/{动作}’ /some/file 行范围模式：awk ‘/LEE/,/KEKEK/{print $0}’ testawk ‘/正则1/,/正则2/{动作}’ /some/fileawk ‘NR>= 3 && NR","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"DU"},{"title":"Linux Sed","slug":"Linux/03.Sed","date":"2018-11-05T10:11:07.000Z","updated":"2019-07-21T01:21:36.744Z","comments":true,"path":"2018/11/05/Linux/03.Sed/","link":"","permalink":"http://yoursite.com/2018/11/05/Linux/03.Sed/","excerpt":"","text":"概述Linux sed 命令是利用脚本来处理文本文件。sed 可依照脚本的指令来处理、编辑文本文件。Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。 sed 命令的选项sed [选项] [动作] 选项与参数12345-e或--expression= 以选项中指定的script来处理输入的文本文件。-f或--file= 以选项中指定的script文件来处理输入的文本文件。-h或--help 显示帮助。-n或--quiet或--silent 仅显示script处理后的结果。-V或--version 显示版本信息。 动作说明：a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ：取代， 以行为单位的替换，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作哩！ 增、删 在testfile文件的第四行后添加一行，并将结果输出到标准输出：[root@www ~]# sed -e ‘4a\\newLine’ testfile 以行为单位的新增/删除[root@www ~]# nl /etc/passwd | sed ‘2,5d’ 只要删除第 2 行nl /etc/passwd | sed ‘2d’ 要删除第 3 到最后一行nl /etc/passwd | sed ‘3,$d’ 在第二行后加上『drink tea?』字样！[root@www ~]# nl /etc/passwd | sed ‘2a drink tea’ 12341 root:x:0:0:root:/root:/bin/bash2 bin:x:1:1:bin:/bin:/sbin/nologindrink tea3 daemon:x:2:2:daemon:/sbin:/sbin/nologin 在第二行前新增[root@www ~]# nl /etc/passwd | sed ‘2i drink tea’ 增加两行以上，在第二行后面加入两行字，例如 Drink tea or ….. 与 drink beer?[root@www ~]# nl /etc/passwd | sed '2a Drink tea or ......\\ drink beer ?' 替换、显示 以行为单位的替换将第2-5行的内容取代成为『No 2-5 number』呢？ 1234[root@www ~]# nl /etc/passwd | sed '2,5c No 2-5 number'1 root:x:0:0:root:/root:/bin/bashNo 2-5 number6 sync:x:5:0:sync:/sbin:/bin/sync 仅列出 /etc/passwd 文件内的第 5-7 行[root@www ~]# nl /etc/passwd | sed -n ‘5,7p’ 1235 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin6 sync:x:5:0:sync:/sbin:/bin/sync7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown 数据的搜寻并显示搜索 /etc/passwd有root关键字的行[root@www ~]# nl /etc/passwd | sed ‘/root/p’ 数据的搜寻并删除删除/etc/passwd所有包含root的行，其他行输出[root@www ~]# nl /etc/passwd | sed ‘/root/d’ 数据的搜寻并替换sed 's/要被取代的字串/新的字串/g'仅仅对第一行进行了替换操作：sed ‘1s/aa/AA/g’ test.txt使用m,n的限定，例如：sed ‘5,$s/aa/AA/g’ test.txt使用正则表达式限定符合条件的行：sed ‘/^[0-9]/s/aa/AA/g’ test.txt注意：s/待替换的字符串/新字符串/ 这种格式中 / 作为分隔符并不是一定的，当使用s命令时候，我们可以使用别的分隔符，实际上s后面紧接着的字符就是分隔符，所以不一定是 / 符号。例如：echo ‘aabbccaadd’ | sed s#aa#AA#g输出：AAbbccAAdd这里s命令后面跟着的#符号被当作分隔符了 多点编辑 删除/etc/passwd第三行到末尾的数据，并把bash替换为blueshell 123[root@www ~]# nl /etc/passwd | sed -e '3,$d' -e 's/bash/blueshell/'1 root:x:0:0:root:/root:/bin/blueshell2 daemon:x:1:1:daemon:/usr/sbin:/bin/sh -e表示多点编辑，第一个编辑命令删除/etc/passwd第三行到末尾的数据，第二条命令搜索bash替换为blueshell。 将修改应用到文件中 利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 ![root@www ~]# sed -i ‘s/.$/!/g’ regular_express.txt 利用 sed 直接在 regular_express.txt 最后一行加入 # This is a test:[root@www ~]# sed -i ‘$a # This is a test’ regular_express.txt$ 代表的是最后一行，而 a 的å¨作是新增 sed正则中的元字符12345678910$ 表示行尾 ^ 表示行首[a-z0-9]表示字符范围[^]表示除了字符集中的字符以外的字符 sed的正则中 \\(\\) 和 \\{m,n\\} 需要转义 . 表示任意字符 * 表示零个或者多个 \\+ 一次或多次 \\? 零次或一次 \\| 表示或语法 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"DU"},{"title":"Linux Grep","slug":"Linux/02.Grep","date":"2018-11-04T10:11:07.000Z","updated":"2019-07-21T01:21:36.766Z","comments":true,"path":"2018/11/04/Linux/02.Grep/","link":"","permalink":"http://yoursite.com/2018/11/04/Linux/02.Grep/","excerpt":"","text":"简介 grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。 Unix的grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。 grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。 命令格式：grep [option] pattern file grep 选项grep的常用选项：1234-V： 打印grep的版本号 -E： 解释PATTERN作为扩展正则表达式，也就相当于使用egrep。 或操作 -F : 解释PATTERN作为固定字符串的列表，由换行符分隔，其中任何一个都要匹配。也就相当于使用fgrep。 -G: 将范本样式视为普通的表示法来使用。这是默认值。加不加都是使用grep。 匹配控制选项：1234567-e : 使用PATTERN作为模式。这可以用于指定多个搜索模式，或保护以连字符（ - ）开头的图案。指定字符串做为查找文件内容的样式。 -f : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 -i : 搜索时候忽略大小写 -v: 反转匹配，选择没有被匹配到的内容。 -w：匹配整词，精确地单词,单词的两边必须是非字符符号(即不能是字母数字或下划线) -x：仅选择与整行完全匹配的匹配项。精确匹配整行内容(包括行首行尾那些看不到的空格内容都要完全匹配) -y：此参数的效果和指定“-i”参数相同。 一般输出控制选项：12345678-c： 抑制正常输出;而是为每个输入文件打印匹配线的计数。 --color [= WHEN]：让关键字高亮显示，如--color=auto -L：列出文件内容不符合指定的范本样式的文件名称 -l : 列出文件内容符合指定的范本样式的文件名称。 -m num：当匹配内容的行数达到num行后,grep停止搜索,并输出停止前搜索到的匹配内容 -o: 只输出匹配的具体字符串,匹配行中其他内容不会输出 -q：安静模式,不会有任何输出内容,查找到匹配内容会返回0,未查找到匹配内容就返回非0 -s：不会输出查找过程中出现的任何错误消息，-q和-s选项因为与其他系统的grep有兼容问题，shell脚本应该避免使用-q和-s，并且应该将标准和错误输出重定向到/dev/null 代替。 输出线前缀控制：123456-b：输出每一个匹配行(或匹配的字符串)时在其前附加上偏移量(从文件第一个字符到该匹配内容之间的字节数) -H：在每一个匹配行之前加上文件名一起输出(针对于查找单个文件),当查找多个文件时默认就会输出文件名 -h：禁止输出上的文件名的前缀。无论查找几个文件都不会在匹配内容前输出文件名 --label = LABEL：显示实际来自标准输入的输入作为来自文件LABEL的输入。这是特别在实现zgrep等工具时非常有用，例如gzip -cd foo.gz | grep --label = foo -H的东西。看到 也是-H选项。 -n：输出匹配内容的同时输出其所在行号。 -T：初始标签确保实际行内容的第一个字符位于制表位上，以便对齐标签看起来很正常。在匹配信息和其前的附加信息之间加入tab以使格式整齐。 上下文线控制选项：123-A num：匹配到搜索到的行以及该行下面的num行 -B num：匹配到搜索到的行以及该行上面的num行 -C num：匹配到搜索到的行以及上下各num行 文件和目录选择选项：12345678910111213141516-a： 处理二进制文件，就像它是文本;这相当于--binary-files = text选项。不忽略二进制的数据。 --binary-files = TYPE：如果文件的前几个字节指示文件包含二进制数据，则假定该文件为类型TYPE。默认情况下，TYPE是二进制的，grep通常输出一行消息二进制文件匹配，或者如果没有匹配则没有消息。如果TYPE不匹配，grep假定二进制文件不匹配;这相当于-I选项。如果TYPE是文本，则grep处理a二进制文件，如果它是文本;这相当于-a选项。警告：grep --binary-files = text可能会输出二进制的垃圾，如果输出是一个终端和如果可能有讨厌的副作用终端驱动程序将其中的一些解释为命令。-D：如果输入文件是设备，FIFO或套接字，请使用ACTION处理。默认情况下，读取ACTION，这意味着设备被读取，就像它们是普通文件一样。如果跳过ACTION，设备为 默默地跳过。 -d: 如果输入文件是目录，请使用ACTION处理它。默认情况下，ACTION是读的，这意味着目录被读取，就像它们是普通文件一样。如果跳过ACTION，目录将静默跳过。如果ACTION是recurse，grep将递归读取每个目录下的所有文件;这是相当于-r选项。 --exclude=GLOB：跳过基本名称与GLOB匹配的文件（使用通配符匹配）。文件名glob可以使用*，？和[...]作为通配符，和\\引用通配符或反斜杠字符。搜索其文件名和GLOB通配符相匹配的文件的内容来查找匹配使用方法:grep -H --exclude=c* \"old\" ./* c*是通配文件名的通配符./* 指定需要先通配文件名的文件的范围,必须要给*,不然就匹配不出内容,(如果不给*,带上-r选项也可以匹配) --exclude-from = FILE：在文件中编写通配方案,grep将不会到匹配方案中文件名的文件去查找匹配内容 --exclude-dir = DIR：匹配一个目录下的很多内容同时还要让一些子目录不接受匹配,就使用此选项。 --include = GLOB：仅搜索其基本名称与GLOB匹配的文件（使用--exclude下所述的通配符匹配）。 -R ,-r :以递归方式读取每个目录下的所有文件; 这相当于-d recurse选项。 其他选项：1234--line-buffered： 在输出上使用行缓冲。这可能会导致性能损失。 --mmap：启用mmap系统调用代替read系统调用 -U：将文件视为二进制。 -z：将输入视为一组行，每一行由一个零字节（ASCII NUL字符）而不是a终止新队。与-Z或--null选项一样，此选项可以与排序-z等命令一起使用来处理任意文件名。 选项简述123456789101112131415161718192021222324252627-a --text #不要忽略二进制的数据。 将 binary 文件以 text 文件的方式搜寻数据 -A --after-context= #除了显示符合范本样式的那一列之外，并显示该行之后的内容。 -b --byte-offset #在显示符合样式的那一行之前，标示出该行第一个字符的编号。 -B --before-context= #除了显示符合样式的那一行之外，并显示该行之前的内容。 -c --count #计算符合样式的行数。 -C --context=或- #除了显示符合样式的那一行之外，并显示该行之前后的内容。 -d --directories= #当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。 -e --regexp= #指定字符串做为查找文件内容的样式。 -E --extended-regexp #将样式为延伸的普通表示法来使用。 -f --file= #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 -F --fixed-regexp #将样式视为固定字符串的列表。 -G --basic-regexp #将样式视为普通的表示法来使用。 -h --no-filename #在显示符合样式的那一行之前，不标示该行所属的文件名称。 -H --with-filename #在显示符合样式的那一行之前，表示该行所属的文件名称。 -i --ignore-case #忽略字符大小写的差别。 -l --file-with-matches #列出文件内容符合指定的样式的文件名称。 -L --files-without-match #列出文件内容不符合指定的样式的文件名称。 -n --line-number #在显示符合样式的那一行之前，标示出该行的列数编号。 -q --quiet或--silent #不显示任何信息。 -r --recursive #此参数的效果和指定“-d recurse”参数相同。 -s --no-messages #不显示错误信息。 -v --revert-match #显示不包含匹配文本的所有行。 -V --version #显示版本信息。 -w --word-regexp #只显示全字符合的列。 -x --line-regexp #只显示全列符合的列。 -y #此参数的效果和指定“-i”参数相同。--color=auto ：可以将找到的关键词部分加上颜色的显示 使用实例常用用法1234567891011121314151617181920212223242526272829303132333435grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，grep -l pattern files ：只列出匹配的文件名，grep -L pattern files ：列出不匹配的文件名，grep -w pattern files ：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），grep -C number pattern files ：匹配的上下文分别显示[number]行，grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2 的行，grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。这里还有些用于搜索的特殊符号：< 和 > 分别标注单词的开始与结尾。例如：grep man * 会匹配 ‘Batman’、‘manic’、‘man’等，grep \\''匹配包含以grep结尾的单词的行。 x\\{m\\} #重复字符x，m次，如：'0\\{5\\}'匹配包含5个o的行。 x\\{m,\\} #重复字符x,至少m次，如：'o\\{5,\\}'匹配至少有5个o的行。 x\\{m,n\\} #重复字符x，至少m次，不多于n次，如：'o\\{5,10\\}'匹配5--10个o的行。 \\w #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。 \\W #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。 \\b #单词锁定符，如: '\\bgrep\\b'只匹配grep。 POSIX字符:[:alnum:] #文字数字字符 [:alpha:] #文字字符 [:digit:] #数字字符 [:graph:] #非空字符（非空格、控制字符） [:lower:] #小写字符 [:cntrl:] #控制字符 [:print:] #非空字符（包括空格） [:punct:] #标点符号 [:space:] #所有空白字符（新行，空格，制表符） [:upper:] #大写字符 [:xdigit:] #十六进制数字（0-9，a-f，A-F） 通过管道过滤ls -l输出的内容，只显示以a开头的行。 123456首与行尾字节 ^ $，^ 符号，在字符类符号(括号[])之内与之外是不同的！ 在 [] 内代表『反向选择』，在 [] 之外则代表定位在行首的意义！$ ls -l | grep \\'^a\\'$ ls -l | grep ^a$ ls -l | grep ^[^a] #输出非a开头的行，反向选择$ grep -n '^$' express.txt #找出空白行，因为只有行首跟行尾 (^$) 显示所有以d开头的文件中包含test的行。$ grep \\'test\\' d* 输出以hat结尾的行内容$ cat test.txt |grep hat$ 显示在aa，bb，cc文件中匹配test的行。$ grep \\'test\\' aa bb cc 显示所有包含每个字符串至少有5个连续小写字符的字符串的行。 123456$ grep \\'[a-z]{5}\\' aa$ grep -n '[0-9]' regular_express.txt #取得有数字的那一行$ grep -n '^[a-z]' regular_express.txt #只输出开头是小写字母的那一行$ grep -n '^[^a-zA-Z]' regular_express.txt #不输出开头是英文的$ grep -n '\\.$' regular_express.txt #只输出行尾结束为小数点 (.) 的那一行注意：小数点具有其他意义，所以必须要使用转义字符(\\)来加以解除其特殊意义！ 显示包含ed或者at字符的内容行命令：cat test.txt |grep -E “ed|at” 显示当前目录下面以.txt 结尾的文件中的所有包含每个字符串至少有7个连续小写字符的字符串的行命令：grep ‘[a-z]{7}‘ *.txt 查询IP地址、邮箱、手机号也就是说-o，只显示匹配行中匹配正则表达式的那部分，-P，作为Perl正则匹配命令（IP）：grep -oP “([0-9]{1,3}.){3}[0-9]{1,3}” file.txt命令（邮箱）：grep -oP “[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+” file.txt手机号码是1[3|4|5|8]后面接9位数字:命令（手机号）：grep -E “\\“ file.txt 任意一个字节 . 与重复字节 * 12345678. (小数点)：代表『一定有一个任意字节』的意思；* (星号)：代表『重复前一个字符， 0 到无穷多次』的意思，为组合形态$ grep -n '[0-9][0-9]*' regular_express.txt #找出『任意数字』的行$ grep -n 'g.*g' regular_express.txt #找出以g行首与行尾的行，当中的字符可有可无这个 .* 的 RE 表示任意字符是很常见的. 限定连续 RE 字符范围 {} 123456利用 . 与 RE 字符及 * 来配置 0 个到无限多个重复字节打算找出两个到五个 o 的连续字串，该如何作？这时候就得要使用到限定范围的字符 {} 了。 但因为 { 与 } 的符号在 shell 是有特殊意义的，因此， 我们必须要使用字符 \\ 来让他失去特殊意义才行。 $ grep -n 'o\\{2\\}' regular_express.txt$ grep -n 'go\\{2,5\\}g' regular_express.txt #要找出 g 后面接 2 到 5 个 o ，然后再接一个 g 的字串$ grep -n 'go\\{2,\\}g' regular_express.txt #想要的是 2 个 o 以上的 goooo....g 呢？除了可以是 gooo*g document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"DU"},{"title":"Linux Ftp","slug":"Linux/05.Ftp_Sftp","date":"2018-10-20T10:11:07.000Z","updated":"2019-07-21T01:21:36.746Z","comments":true,"path":"2018/10/20/Linux/05.Ftp_Sftp/","link":"","permalink":"http://yoursite.com/2018/10/20/Linux/05.Ftp_Sftp/","excerpt":"","text":"Linux Ftp、Sftpsftp命令可以通过ssh来上传和下载文件，是常用的文件传输工具，它的使用方式与ftp类似，但它使用ssh作为底层传输协议，所以安全性比ftp要好得多。 Ftp常见命令详解登录Ftp服务器格式：直接输入ftp加ip地址:ftp 192.168.10.xxx格式：直接输入ftp，进入ftp服务后输入open加ip地址:open 192.168.10.xxx 查看Ftp服务器上的文件（一般情况下用户都会被限制目录的访问权限，只可在当前目录下进行操作）dir：显示服务器目录和文件列表ls：显示服务器简易的文件列表cd：进入服务器指定的目录 dir命令可以使用通配符“”和“?”，比如，显示当前目录中所有扩展名为jpg的文件，可使用命令 dir .jpg。cd命令中必须带目录名。比如 cd main 表示进入当前目录下的main子目录 下载文件上传和下载文件时应该使用正确的传输类型，FTP的传输类型分为ASCII码方式和二进制方式两种，对.txt、.htm等文件应采用ASCII码方式传输，对.exe或图片、视频、音频等文件应采用二进制方式传输。在默认情况下，FTP为ASCII码传输方式。 type：查看当前的传输方式ascii：设定传输方式为ASCII码方式binary：设定传输方式为二进制方式 get：下载指定文件get filename [newname]mget：下载多个文件mget filename [filename ….]（mget命令支持通配符“”和“?”，比如：mget .mp3 表示下载FTP服务器当前目录下的所有扩展名为mp3的文件。） 上传文件put：上传指定文件put filename [newname]send：上传指定文件send filename [newname] 这里的send和put方法用法都基本相同，但是上传速度send却要比put快很多 结束并退出Ftpclose：结束与服务器的FTP会话quit：结束与服务器的FTP会话并退出FTP环境 其它Ftp命令pwd：查看Ftp服务器上的当前工作目录rename filename newfilename：重命名FTP服务器上的文件deletefilename：删除FTP服务器上的文件help[cmd]：显示FTP命令的帮助信息，cmd是命令名，如果不带参数，则显示所有FTP命令 Sftp常见命令详解登录Sftp服务器1234567891011格式：sftp 通过sftp连接，端口为默认的22，用户为Linux当前登录用户。格式：sftp -oPort= 通过sftp连接，指定端口，用户为Linux当前登录用户。格式：sftp @通过sftp连接，端口为默认的22，指定用户。格式：sftp -oPort= @通过sftp连接，端口为，用户为。 查看Sftp 服务器上的文件12345678910111213help/? 打印帮助信息 pwd 查看远程服务器当前目录 lpwd 查看本地系统的当前目录 cd 将远程服务器的当前目录更改为 lcd 将本地系统的当前目录更改为 ls 显示远程服务器上当前目录的文件名 ls -l 显示远程服务器上当前目录的文件详细列表； ls 显示远程服务器上符合指定模式的文件名； ls -l 显示远程服务器上符合指定模式的文件详细列表 lls 显示本地系统上当前目录的文件名,lls的其他参数与ls命令的类似 下载文件get 下载指定文件get 下载符合指定模式的文件 上传文件put 上传指定文件；get 上传符合指定模式的文件。 创建目录123progress 切换是否显示文件传输进度mkdir 在远程服务器上创建目录lmkdir 在本地系统上创建目录 结束并退出Sftpexit/quit/bye 退出sftp 其他Sftp 命令其他命令还有：chgrp, chmod, chown, ln, lumask, rename, rm, rmdir, symlink, version。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"DU"},{"title":"Linux 常用命令","slug":"Linux/01.Linux常用命令","date":"2018-10-04T10:11:07.000Z","updated":"2019-07-21T01:21:36.751Z","comments":true,"path":"2018/10/04/Linux/01.Linux常用命令/","link":"","permalink":"http://yoursite.com/2018/10/04/Linux/01.Linux常用命令/","excerpt":"","text":"环境变量设置变量的三种方法 在/etc/profile文件中添加变量【对所有用户生效（永久的）】 123# vi /etc/profileexport PATH=/home/kylin : $PATH # source /etc/profile 在用户目录下的.bash_profile文件中增加变量【对单一用户生效（永久的）】 1234$ vi /home/guok/.bash.profile添加如下内容：export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib$ source /home/guok/.bash_profile 直接运行export命令定义变量【只对当前shell（BASH）有效（临时的）】在shell的命令行下直接使用[export 变量名=变量值] PATH声明，其格式为：PATH=$PATH::::------: 你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效。 如果想立刻生效，则可执行下面的语句：$source .bash_profile 需要注意的是，最好不要把当前路径”./”放到PATH里，这样可能会受到意想不到的攻击。 完成后，可以通过$ echo $PATH查看当前的搜索路径。这样定制后，就可以避免频繁的启动位于shell搜索的路径之外的程序了。 常用的环境变量 PATH 决定了shell将到哪些目录中寻找命令或程序 HOME 当前用户主目录 HISTSIZE 历史记录数 LOGNAME 当前用户的登录名 HOSTNAME 指主机的名称 SHELL 当前用户Shell类型 LANGUGE 语言相关的环境变量，多语言可以修改此环境变量 MAIL 当前用户的邮件存放目录 PS1 基本提示符，对于root用户是#，对于普通用户是$ 常用的环境变量相关命令 显示环境变量HOME 设置一个新的环境变量hellofs@ubuntu:~$ export HELLO=”Hello”fs@ubuntu:~$ echo $HELLO 使用env命令显示所有的环境变量 使用set命令显示所有本地定义的Shell变量 fs@ubuntu:~$ set 使用unset命令来清除环境变量set可以设置某个环境变量的值。清除环境变量的值用unset命令。如果未指定值，则该变量值将被设为NULL。fs@ubuntu:~$ unset $TEST \\删除环境变量TEST 使用readonly命令设置只读变量如果使用了readonly命令的话，变量就不可以被修改或清除了。fs@ubuntu:~$ export TEST=”Test” \\增加一个环境变量TESTfs@ubuntu:~$ readonly TEST \\将环境变量TEST设为只读fs@ubuntu:~$ unset TEST \\此变量无法删除bash: unset: TEST: cannot unset: readonly variablefs@ubuntu:~$ TEST=”NEW” \\此变量不可更改bash: TEST: readonly variable RPMrpm的一般格式：rpm [选项] [rpm软件包] 初始化rpm 数据库（可以省略）rpm –initdbrpm –rebuilddb 注：这个要花好长时间。注：有时rpm系统出了问题，不能安装和查询，大多是这里出了问题 RPM软件包管理的查询功能：rpm -q [select-options] [query-options] 查询系统已安装的软件语法：rpm -q 软件名例：rpm -q mplayer查看系统中所有已经安装的包，要加 -a 参数rpm -qa 查询一个已经安装的文件属于哪个软件包语法： rpm -qf 文件名注： 文件名所在的绝对路径要指出例：rpm -qf /usr/lib/libacl.la 查询已安装软件都安装到何处语法：rpm -ql 软件包名例：rpm -ql mplayer 查询一个已安装包的信息语法: rpm -qi 软件包名例： rpm -qi mplayer 查看一下已安装软件的配置文件语法： rpm -qc 软件名 查看一个已安装软件的文档安装位置语法： rpm -qd 软件名 查看一下已安装软件所依赖的软件包及文件rpm -qR 软件名 进程管理PS、TOP进程的属性：进程ID（PID） 、父进程和父进程ID（PPID）、启动进程的用户ID（UID）和所归属的组ID（GID）、进程状态：R S Z 、进程执行优先级、进程连接的终端名、进程资源占用：内存、CPU占用量 PS TOP 管理进程 PS 静态 当前的状态参数说明：l ：长格式输出u ：按用户名和启动时间顺序显示f :树形格式显示a ：显示所有用户的所以进程r :运行中的进程e ：显示所有进程，包括没有控制终端的进程x : 显示没有控制终端的进程 PS -aux 输出的解释USER 进程的属主；PID 进程的IDPPID 父进程%CPU 占用的CPU百分比%MEM 占用的内存百分比NI 进程的NICE值VSZ 占用虚拟内存大小RSS 实际使用内存大小TTY 进程启动的终端IDSTAT 进程状态 R S T Z N L sSTART 启动进程的时间TIME 进程消耗CPU的时间 COMMAND 命令的名称和参数PS -AUX BSD格式显示PS -ef 标准格式显示 TOP 动态查看进程统计信息区前5行是系统整体的统计信息。图 。。。。系统信息解释：任务队列信息（第一行）：当前时间 系统运行时间 当前登陆用户数 系统负载，即任务队列平均长度，三个数值分别为1分钟、5分钟、15分钟前到现在的平均值。进程和CPU的信息（第二、三行）：进程总数 正在运行的进程数 睡眠的进程数 停止的进程数 僵尸进程数 系统用户进程使用CPU百分比 内核中的进程占用CPU百分比（sy） 用户进程空间内改变过优先级的进程占用CPU百分比（ni） 空闲CPU百分比（id）内存信息（第四五行）：物理内存总量 空闲内存总量 使用的物理内存总量 用作内核缓存的内存量（和free -k 一个意思） 交换区总量 使用的交换区总量 空闲交换区总量总的可以利用内存 TOP快捷键默认3s 刷新一次、空格 立即刷新q 退出M 按内存排序P 按CPU排序 YUM 配置yum源的配置文件12345[base-yum]name=rhel7-sourcebaseurl=file:///mntenabled=1gpgcheck=0 清空yum 缓存 yum clean all生成列表 yum list安装 yum install -y检测升级 yum check-update升级 yum update软件包查询 yum list软件包信息 yum info 源码包安装：编译 make -j 4 使用4个进程同编译123--prefix 指定安装的位置--user 指定运行的用户--group 。 制定运行的组 du、dfdu 统计文件大小相加df 统计数据块使用情况 [root@bsso yayu]# du -h –max-depth=1 work/testing27M work/testing/logs35M work/testing 查看linux文件目录的大小和文件夹包含的文件数统计总数大小du -sh xmldb/ 统计当前目录大小 并安大小 排序du -sm | sort -ndu -sk | sort -n 看一个的大小du -sk * | grep guojf 文件查找 which 可执行文件位置 whereis 可执行文件的位置及相关文件 find 目录结构中搜索文件。格式： find 路径 选项 选项： -name -perm -user -mtime -n +n-type 查找某一类型。 b c p d f l例：find /etc/ -name “host*”find . -perm 755find /home/kylin -user kylinfind /home/kylin -group kylinfind /root -mtime -5find /root -mtime +3 计划任务计划任务：在某个时段自动执行某个任务。 at 只能执行一次systemctl status atdctrl +D 结束 at -l 查看计划任务 任务编号 、执行时间 、执行者at 20:00 2017-4-12at now +10min 在10分钟后执行删除at 计划任务：atrm + 计划任务的编号 周期行计划任务：cron 主程序 、 Crond 服务：1.系统级别 2.用户级别的计划任务 主文件： /etc/crontab针对用户级别的计划任务：对于root用户：命令：crontab -e 创建一个计划任务 crontab -l 显示 crontab -r 删除计划任务 crontab -e # 写法分 时 日 月 星 谁做后面的事情 命令123456每月 9,18,22 这几天的凌晨1点1分，执行一个备份脚本1 1 9,18,22 * * /root/backup.sh每月 9-22号这几天的凌晨1点1分，执行一个备份脚本1 1 9-22 * * /root/backup.sh每5分钟，执行一次*/5 * * * * /root/backup.sh anacron ：解决cront 错过时间后，不执行cron计划任务的问题。anacron的作用：机器重启后，侦测在关机的这一段时间期间，有没有cron每有执行的计划任务， 如果有，开机后，anacron会立即执行没有执行的任务。 Curlcurl模拟Http 的get 或 post请求 查看网页源码$ curl www.sina.com1234567 301 Moved Permanently Moved Permanently The document has moved here. 保存下来，可以使用-o参数$ curl -o [文件名] www.sina.com 自动跳转有的网址是自动跳转的。使用-L参数，curl就会跳转到新的网址。$ curl -L www.sina.com 显示头信息-i参数可以显示http response的头信息，连同网页代码一起。$ curl -i www.sina.com -I参数则是只显示http response的头信息。 显示通信过程-v参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。$ curl -v www.sina.com1234567891011121314151617181920212223242526272829 * About to connect() to www.sina.com port 80 (#0) * Trying 61.172.201.195... connected * Connected to www.sina.com (61.172.201.195) port 80 (#0) > GET / HTTP/1.1 > User-Agent: curl/7.21.3 (i686-pc-linux-gnu) libcurl/7.21.3 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18 > Host: www.sina.com > Accept: */* > * HTTP 1.0, assume close after body < HTTP/1.0 301 Moved Permanently < Date: Sun, 04 Sep 2011 00:42:39 GMT < Server: Apache/2.0.54 (Unix) < Location: http://www.sina.com.cn/ < Cache-Control: max-age=3600 < Expires: Sun, 04 Sep 2011 01:42:39 GMT < Vary: Accept-Encoding < Content-Length: 231 < Content-Type: text/html; charset=iso-8859-1 < X-Cache: MISS from sh201-19.sina.com.cn < Connection: close < 301 Moved Permanently Moved Permanently The document has moved here. * Closing connection #0 如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。$ curl –trace output.txt www.sina.com或者 $ curl –trace-ascii output.txt www.sina.com 发送表单信息发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。$ curl example.com/form.cgi?data=xxx POST方法必须把数据和网址分开，curl就要用到–data参数。 $ curl -X POST –data “data=xxx” example.com/form.cgi 如果你的数据没有经过表单编码，还可以让curl为你编码，参数是–data-urlencode。 $ curl -X POST–data-urlencode “date=April 1” example.com/form.cgi HTTP动词curl默认的HTTP动词是GET，使用-X参数可以支持其他动词。 $ curl -X POST www.example.com $ curl -X DELETE www.example.com 文件上传假定文件上传的表单是下面这样： 你可以用curl这样上传文件： $ curl –form upload=@localfilename –form press=OK [URL] Referer字段有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。 $ curl –referer http://www.example.com http://www.example.com 九、User Agent字段这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。iPhone4的User Agent是 Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7 curl可以这样模拟： $ curl –user-agent “[User Agent]” [URL] 十、cookie使用–cookie参数，可以让curl发送cookie。 $ curl –cookie “name=xxx” www.example.com 至于具体的cookie的值，可以从http response头信息的Set-Cookie字段中得到。-c cookie-file可以保存服务器返回的cookie到文件，-b cookie-file可以使用这个文件作为cookie信息，进行后续的请求。 $ curl -c cookies http://example.com $ curl -b cookies http://example.com 十一、增加头信息有时需要在http request之中，自行增加一个头信息。–header参数就可以起到这个作用。 $ curl –header “Content-Type:application/json” http://example.com 十二、HTTP认证有些网域需要HTTP认证，这时curl需要用到–user参数。 $ curl –user name:password example.com 十三、get请求curl “ { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"DU"},{"title":"next主题配置","slug":"Hexo/02.hexo","date":"2018-10-03T10:11:07.000Z","updated":"2019-07-21T01:21:36.742Z","comments":true,"path":"2018/10/03/Hexo/02.hexo/","link":"","permalink":"http://yoursite.com/2018/10/03/Hexo/02.hexo/","excerpt":"","text":"主题配置 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}],"author":"DU"},{"title":"基于Hexo+Github+Coding搭建个人博客","slug":"Hexo/01.hexo","date":"2018-10-01T10:11:07.000Z","updated":"2019-07-21T01:21:36.740Z","comments":true,"path":"2018/10/01/Hexo/01.hexo/","link":"","permalink":"http://yoursite.com/2018/10/01/Hexo/01.hexo/","excerpt":"","text":"前言 Hexo博客搭建的基础大致流程为:安装Node.js →安装Git → 安装Hexo → 安装主题 → 本地测试运行 → 注册给github与coding并创建pages仓库 → 部署 对于使用windows的童鞋, 可参考文章末尾处的参考链接, 步骤大同小异以下提到的站点配置文件指的是博客文件根目录下的 _config.yml, 主题配置文件是主题文件夹下的 _config.yml, 童鞋们不要混淆了 安装Node.jsNode.js的安装有很多种方式, Hexo的官方文档 建议是用nvm 安装, 但好多人都说不行, 所以找了另外两种方式安装windows的童鞋可参考安装Node.js 方法一: 二进制包直接解压配置在node.js的官网 下载二进制包来安装的, 下载过后, 解压, 设置软链接, 要不然每次都执行命令都要加上路径, 好麻烦cp /home/ybd/Data/soft/application/node-v6.2.0-linux-x64/bin/node /usr/local/bin/nodecp /home/ybd/Data/soft/application/node-v6.2.0-linux-x64/bin/npm /usr/local/bin/npm检查：node -vnpm -v 方法二: 换源下载安装 8.x 版本:curl -sL https://rpm.nodesource.com/setup_8.x | sudo -E bash -sudo yum install -y nodejsnpm 更换淘宝镜像:npm config set registry https://registry.npm.taobao.org/ 方法三: 源文件编译安装在安装前, 首先需要配置安g++编译器sudo yum install build-essential去官网 下载源代码, 选择最后一项, Source Code解压到某一目录, 然后进入此目录,依次执行以下3条命令./configuremakesudo make install执行以下命令, 检测是否已经装好node.jsnode -v npm安装, 一条命令即可解决curl http://npmjs.org/install.sh | sudo sh 1234[root@VM_0_2_centos ]# node -vv10.15.3[root@VM_0_2_centos ]# npm -v6.4.1 安装Git linux系统下安装Git非常简单, 只需一条命令:sudo yum install gitwindows下就直接到Git官网 下载安装即可然后终端执行 git –version 查看是否安装成功1git version 1.8.3.1 安装Hexo什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架. Hexo 使用 Markdown（或其他渲染引擎）解析文章, 在几秒内, 即可利用靓丽的主题生成静态网页. 所有以上必备的应用程序安装完成后, 无论是在哪个操作系统, 之后的操作都一样安装Hexo的非常简单, 只要一条命令, 前提是安装好Node.js与Git npm install -g hexo-cli 本地启动Hexo 初始化随便建一个文件夹, 名字随便取, 博主取其名为hexo, cd 到文件夹里, 先安装必要的文件, 执行以下命令:hexo init # hexo会在目标文件夹建立网站所需要的所有文件npm install # 安装依赖包 本地启动有了必要的各种配置文件之后就可以在本地预览效果了hexo g # 等同于hexo generate, 生成静态文件hexo s # 等同于hexo server, 在本地服务器运行之后打开浏览器并输入IP地址 http://localhost:4000/ 查看, 效果如下: 安装主题（以NexT为例） 复制主题Hexo 安装主题的方式非常简单, 只需要将主题文件拷贝至站点目录的 themes 目录下, 然后修改下配置文件即可cd your-hexo-sitegit clone https://github.com/iissnan/hexo-theme-next themes/next 启用主题打开站点配置文件_config.yml, 找到 theme 字段, 并将其值更改为 nexttheme: next然后 hexo s 即可预览主题效果 更换主题外观博主用的是 Muse, 直接更改主题配置文件./next/_config.yml的 scheme 参数即可: 12345# Schemes#scheme: Muse #这是 Nex默认版本，黑白主调，大量留白#scheme: Mist #Muse 的紧凑版本，整洁有序的单栏外观#scheme: Pisces #双栏 Scheme，小家碧玉似的清新scheme: Gemini #双子座，也是双栏形式，和Pisces类似 再次执行 hexo clean 和 heox s 可预览效果大部分的设定都能在NexT的官方文档 里面找到, 如侧栏、头像、打赏、评论等等, 在此就不多讲了, 照着文档走就行了, 接下只是个性定制的问题 Github、Coding注册Github和Coding并分别创建Pages在本地运行没有问题的话, 那么可以部署到外网去, 在此之前, 先得有服务器让你的项目可以托管, 那么Github Page与Coding Page就是个很好的东西, 它们可以让我们访问静态文件, 而Hexo生成的恰恰是静态文件 那为什么要注册两个网站呢？因为Github是国外的服务器, 访问速度比较慢, 而Coding是国内的, 速度相对来说比较快, 在后面DNS解析的时候可以把国内的解析到Coding, 国外的解析到Github, 相当的完美 GitHub 注册Github帐号进入Github 首页进行注册, 用户名、邮箱和密码之后都需要用到, 自己记好, 不知道怎么注册的童鞋去问问度娘 创建Repository(Github Pages)Repository相当于一个仓库, 用来放置你的代码文件. 首先, 登陆进入Github, 选择首页中的 New repository 按钮创建时, 只需要填写Repository name即可, 可以顺便创建README文件, 就是红色那个钩, 当然这个名字的格式必须为{user_name}.github.io, 其中{user_name}必须与你的用户名一样, 这是github pages的特殊命名规范![VetYIf.md.png](https://s2.ax1x.com/2019/05/28/VetYIf.md.png Coding 注册Coding帐号国内的网站, 绝大部分都是中文的, 注册什么的就不说了,进入Coding 滚键盘就是了= = 创建项目(Coding Pages)Coding Pages请看 Coding Pages注册之后进入主页, 点击项目, 点击+, 项目名为你的用户名 查看Pages 服务是否开启: 点击项目 -> 代码 -> Pages 服务, 若没有开启则点开启 配置SSH与Git那么我们有了两个免费的服务器之后, 就要绑定个人电脑与它们联系, 那就是SSH与Git绑定之后我们每次部署项目就不用输入帐号和密码 生成SSH Keyssh-keygen -t rsa -C your_email@youremail.com后面的 your_email@youremail.com 改为你的邮箱, 之后会要求确认路径和输入密码, 我们这使用默认的一路回车就行. 成功的话会在~/下生成 .ssh 文件夹, 进去, 打开 id_rsa.pub, 复制里面的key 添加SSH Key首先是Github, 登录Github, 右上角 头像 -> Settings —> SSH nd GPG keys —> New SSH key . 把公钥粘贴到key中, 填好title并点击 Add SSH key至于Coding, 登录进入主页, 点击 账户 —> SSH公钥 —> 输入key再点击 添加 验证成功与否验证github:ssh -T git@github.com如果是第一次的会提示是否continue, 输入yes就会看到: You’ve successfully authenticated, but GitHub does not provide shell access . 这就表示已成功连上github!之前博主就是因为没有输入yes, 导致几次失败, 粗心地一路回车= =验证coding:ssh -T git@git.coding.net同上, 按yes 设置username和email因为github每次commit都会记录他们git config –global user.name your namegit config –global user.email your_email@youremail.com 部署到Github与Coding 先安装Git部署插件npm install hexo-deployer-git –save 打开站点配置文件, 修改部署配置: 1234567# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: github: git@github.com:airpan/airpan.github.io.git,master coding: git@git.dev.tencent.com:AIRPAN/AIRPAN.coding.me.git,master 注意冒号后面是网站对应的用户名, 接着就是/, 然后再是你的项目名加上 .git保存后终端执行hexo cleanhexo ghexo d访问:https://yourname.coding.mehttps://yourname.github.io document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}],"author":"DU"},{"title":"Linux 系统运维","slug":"Linux/01.Linux系统运维","date":"2018-10-01T10:11:07.000Z","updated":"2019-07-21T01:21:36.751Z","comments":true,"path":"2018/10/01/Linux/01.Linux系统运维/","link":"","permalink":"http://yoursite.com/2018/10/01/Linux/01.Linux系统运维/","excerpt":"","text":"Linux 系统运维系统状态监控系统状态 w uptime vmstatvmstat 1vmstat 1 10vmstat各指标含义：r ：表示运行和等待cpu时间片的进程数，如果长期大于服务器cpu的个数，则说明cpu不够用了；b ：表示等待资源的进程数，比如等待I/O, 内存等，这列的值如果长时间大于1，则需要关注一下了si ：由交换区进入内存的数量；so ：由内存进入交换区的数量；bi ：从块设备读取数据的量（读磁盘）；bo： 从块设备写入数据的量（写磁盘）；wa ：表示I/O等待所占用cpu时间百分比. top用于动态监控进程所占系统资源，每隔3秒变一次。RES 这一项为进程所占内存大小，而 %MEM 为使用内存百分比。在 top状态下，按 “shift + m”, 可以按照内存使用大小排序。按数字 ‘1’ 可以列出各颗cpu的使用状态。top -bn1 它表示非动态打印系统资源使用情况，可以用在shell脚本中 sar没有这个命令，使用yum install -y sysstat网卡流量 sar -n DEV, sar -n DEV 1 10sar -n DEV -f /var/log/sa/sa24查看历史负载 sar -q查看磁盘读写 sar -b PM free查看系统内存使用情况free以k为单位显示 -m以M为单位 -g以G为单位mem(total):内存总数;mem(used):已经分配的内存;mem(free):未分配的内存;mem(buffers):系统分配但未被使用的buffers；mem(cached)系统分配但未被使用的cachebuffers/cache(used):实际使用的buffers与cache 总量，也是实际使用的内存；buffers/cache(free):未被使用的buffers与cache和未被分配的内存之和，这就是系统当前实际可用内存buffers是即将要被写入磁盘的，cache是被从磁盘中读出来的 ps 查看系统进程ps aux / ps -elfPID ：进程的id，这个id很有用，在linux中内核管理进程就得靠pid来识别和管理某一个程，比如我想终止某一个进程，则用 ‘kill 进程的pid’ 有时并不能杀掉，则需要加一个-9选项了 kill -9 进程pidSTAT ：表示进程的状态，进程状态分为以下几种D 不能中断的进程（通常为IO）R 正在运行中的进程S 已经中断的进程，系统中大部分进程都是这个状态T 已经停止或者暂停的进程，如果我们正在运行一个命令，比如说 sleep 10 如果我们按一下ctrl -z 让他暂停，那么我们用ps查看就会显示T这个状态X 已经死掉的进程（这个从来不会出现）Z 僵尸进程，杀不掉，打不死的垃圾进程，占系统一小点资源，不过没有关系。如果太多，就有问题了。< 高优先级进程N 低优先级进程L 在内存中被锁了内存分页s 主进程l 多线程进程 在前台的进程 网络管理网络状态 netstat 查看网络状况netstat -lnp 查看当前系统开启的端口以及socketnetstat -an 查看当前系统所有的连接 curlcurl -xip:port www.baidu.com # -x可以指定ip和端口，省略写hosts，方便实用curl -Iv http://www.qq.com # -I 可以把访问的内容略掉，只显示状态码,-v可以显示详细过程curl -u user:password http://123.com # -u可以指定用户名和密码curl http://study.lishiming.net/index.html -O #可以下载，还可以使用 -o 自定义名字 curl -o index2.htmlhttp://study.lishiming.net/index.html nc -z -w2 www.baidu.com 1-1024 # -w2 表示 2s超时 port 这里可以只写一个端口，也可以写一个范围。 使用nc扫描端口时，必须要加 -z 否则不显示结果。另外，如果想把不开放的端口也显示出来，可以加一个 -v tcpdump 系统自带抓包工具tcpdump -nn -i eth0 tcp and host 192.168.0.1 and port 80tcpdump -nn -vs0 tcp and port not 22 -c 100 -w 1.capwireshark 在linux下也可以安装 yum install -y wireshark抓包分析http请求：tshark -n -t a -R http.request -T fields -e “frame.time” -e “ip.src” -e “http.host” -e “http.request.method” -e “http.request.uri” Selinux、Iptables Selinux配置文件 /etc/selinux/config三种形式：enforcing, permissive, disabled SELINUX=disabledsetenforce 0/1getenforce netfilter – iptablesiptables -nvL 查看规则iptables -F 清除当前的规则iptables -Z 计数器清零service iptables save 保存规则 保存的规则文件为：/etc/sysconfig/iptablesservice iptables stop 可以暂停防火墙，但是重启后它会读取/etc/sysconfig/iptables 从而启动防火墙，另外即使我们停止防火墙，但一旦我们添加任何一条规则，它也会开启iptables -t 指定表名，默认不加-t则是filter表filter 这个表主要用于过滤包的，是系统预设的表,内建三个链INPUT、OUTPUT以及FORWARD。INPUT作用于进入本机的包；OUTPUT作用于本机送出的包；FORWARD作用于那些跟本机无关的包。nat 主要用处是网络地址转换，也有三个链。PREROUTING 链的作用是在包刚刚到达防火墙时改变它的目的地址，如果需要的话。OUTPUT链改变本地产生的包的目的地址。POSTROUTING链在包就要离开防火墙之前改变其源地址。mangle 这个表主要是用于给数据包打标记，然后根据标记去操作哪些包。这个表几乎不怎么用。 iptables规则相关：查看规则 iptables -t nat -nvL清除规则 iptables -t nat -F增加/删除规则 iptables -A/-D INPUT -s 10.72.11.12 -p tcp –sport 1234 -d 10.72.137.159 –dport 80 -j DROP插入规则 iptables -I INPUT -s 1.1.1.1 -j DROP/ACCEPT/REJECTiptables -nvL –line-numbers 查看规则带有id号iptables -D INPUT 1 根据规则的id号删除对应规则iptables -P INPUT DROP 用来设定默认规则，默认是ACCEPT ，一旦设定为DROP后，只能使用 iptables -P ACCEPT 才能恢复成原始状态，而不能使用-F参数示例：针对filter表，预设策略INPUT链DROP，其他两个链ACCEPT，然后针对192.168.0.0/24开通22端口，对所有网段开放80端口，对所有网段开放21端口。 脚本如下：#! /bin/bashipt=”/sbin/iptables”$ipt -F; $ipt -P INPUT DROP;$ipt -P OUTPUT ACCEPT; $ipt -P FORWARD ACCEPT;$ipt -A INPUT -s 192.168.0.0/24 -p tcp –dport 22 -j ACCEPT$ipt -A INPUT -p tcp –dport 80 -j ACCEPT$ipt -A INPUT -p tcp –dport 21 -j ACCEPTicmp的包有常见的应用,本机ping通外网，外网ping不通本机 iptables -I INPUT -p icmp –icmp-type 8 -j DROP nat表应用：路由器就是使用iptables的nat原理实现假设您的机器上有两块网卡eth0和eth1，其中eth0的IP为192.168.10.11，eth1的IP为172.16.10.11 。eth0连接了intnet 但eth1没有连接，现在有另一台机器(172.16.10.12)和eth1是互通的，那么如何设置也能够让连接eth1的这台机器能够连接intnet?echo “1” > /proc/sys/net/ipv4/ip_forwardiptables -t nat -A POSTROUTING -s 172.16.10.0/24 -o eth0 -j MASQUERADE iptables规则备份与恢复：service iptables save 这样会保存到/etc/sysconfig/iptablesiptables-save > myipt.rule 可以把防火墙规则保存到指定文件中iptables-restore < myipt.rule 这样可以恢复指定的规则 计划任务 Linux系统任务计划/etc/crontab cron的主配置文件，可以定义PATH12345678910cron格式如下：# .----------------分钟 (0 - 59)# | .------------- 小时 (0 - 23)# | | .---------- 日 (1 - 31)# | | | .------- 月 (1 - 12)# | | | | .---- 周 (0 - 6) (周日=0 or 7) # | | | | |# * * * * * user-name command to be executedcron 也是一个服务，所以需要先启动服务才能生效：service crond start; service crond status Linux 系统管理 Linux系统服务管理工具ntsysv 类似图形界面管理工具，如果没有该命令使用 yum install -y ntsysv 安装常用服务：crond, iptables, network, sshd, syslog, irqbalance, sendmail, microcode_ctlchkconfig –listchkconfig –add/del servicenamechkconfig –level [345] servicename on/off Linux系统日志/var/log/messages核心系统日志文件每周归档一个日志 messages-20130901/etc/logrotate.confmessages由syslogd这个守护进程产生的，如果停掉这个服务则系统不会产生/var/log/messages/var/log/wtmp 查看用户登录历史 last/var/log/btmp lastb 查看无效登录历史/var/log/maillog/var/log/securedmesg/var/log/dmesg exec与xargsexec 和find同时使用查找当前目录创建时间大于10天的文件并删除 ：find . -mtime +10 -exec rm -rf {} \\;批量更改文件名: find ./ -exec mv {} {}_bak \\;xargs 用在管道符号后面find . -mtime +10 |xargs rm -rfls -d ./ |xargs -n1 -i{} mv {} {}_bakxargs 可以把多行变成一行 cat 1.txt|xargs screen 工具介绍screen相当于一个虚拟终端，它不会因为网络中断而退出，每次登录都可以进入那个screen使用方法：直接输入screen命令screen -ls 查看已经开启的screenCtrl +a 再按d退出该screen会话，只是退出，并没有结束。结束的话输入Ctrl +d 或者输入exit退出后还想再次登录某个screen会话，使用sreen -r screenid 若只有一个screen 直接screen -rscreen -S aming ； 登录的话 screen -r aming document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}],"author":"DU"},{"title":"CentOS7 快速安装Zabbix3.4","slug":"Zabbix/01.ZabbixInstall","date":"2018-09-25T10:11:07.000Z","updated":"2019-07-21T01:21:36.764Z","comments":true,"path":"2018/09/25/Zabbix/01.ZabbixInstall/","link":"","permalink":"http://yoursite.com/2018/09/25/Zabbix/01.ZabbixInstall/","excerpt":"","text":"关于zabbix zabbix一开强大的开源监控工具，同类型还有nagios，ganglia，cacti等监控工具，通过过去一年Google趋势就知道zabbix全球的相对热度： 安装平台（摘自官网） Linux / IBM AIX / FreeBSD / NetBSD / OpenBSD / HP-UX / Mac OS X / Solaris //能够部署server和agent Windows: all desktop and server versions since XP (Zabbix agent only) //windows平台只能安装agent，也就是“被监控”。 搭建LAMP 环境这一部分介绍如何在Centos7 上配置Apache+MySQL+PHP7 安装Apacheyum install httpd httpd-devel 安装MySQL在CentOS7 中默认安装有MariaDB，这个是MySQL的分支，还是要在系统中安装MySQL，而且安装完成之后可以直接覆盖掉MariaDB。 下载MySQL官方的 Yum Repository 并安装MySQL。[root@localhost ~]# wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm[root@localhost ~]# yum -y install mysql57-community-release-el7-10.noarch.rpm[root@localhost ~]# yum -y install mysql-community-server MySQL 设置找出初始的root用户的密码，通过如下命令可以在日志文件中找出密码：[root@localhost ~]# grep “password” /var/log/mysqld.log2019-05-19T00:42:03.830587Z 1 [Note] A temporary password is generated for root@localhost: 5&vPo_Vej1GZ如下命令进入数据库：[root@localhost ~]# mysql -uroot -p输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库：mysql> ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘new password’; 安装PHP 安装php检查当前安装的PHP包：yum list installed | grep php如果有安装的PHP包，先删除他们更新yum 源：rpm -Uvh http://mirror.webtatic.com/yum/el5/latest.rpm ##CentOs 5.xrpm -Uvh http://mirror.webtatic.com/yum/el6/latest.rpm ##CentOs 6.xrpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm ##CentOs 7.Xrpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm安装：yum install php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_64 测试PHP[root@nmserver-7 ~]# cd /var/www/html/[root@nmserver-7 html]# vi info.php 12345678910[root@localhost html]# curl -I http://localhost/info.phpHTTP/1.1 200 OKDate: Sat, 25 May 2019 01:06:40 GMTServer: Apache/2.4.6 (CentOS) PHP/7.0.33X-Powered-By: PHP/7.0.33Content-Type: text/html; charset=UTF-8 Zabbix 安装Zabbix3.4 安装 安装zabbix的Repo 1rpm -i http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm 安装zabbix的服务端、界面端、监控端yum install zabbix-server-mysql zabbix-web-mysql zabbix-agent 创建zabbix数据库 1234mysql> create database zabbix character set utf8 collate utf8_bin; mysql> grant all on zabbix.* to zabbix@'localhost' identified by 'zabbix'; mysql> flush privileges; mysql> \\q //退出 导入表结构和数据~]# zcat /usr/share/doc/zabbix-server-mysql-4.2.2/create.sql.gz | mysql -uzabbix -p’Zbx4.2.2_asp_2019’ -D zabbix_server 配置修改 zabbix server配置数据库信息~]# vim /etc/zabbix/zabbix_server.conf开启或修改以下关键字： 1234DBHost=localhostDBName=zabbixDBUser=zabbixDBPassword=zabbix //根据自己定义的信息修改 修改zabbix前端配置中的时区信息~]# vim /etc/httpd/conf.d/zabbix.conf 1234567891011 php_value max_execution_time 300 php_value memory_limit 128M php_value post_max_size 16M php_value upload_max_filesize 2M php_value max_input_time 300 php_value max_input_vars 10000 php_value always_populate_raw_post_data -1 # php_value date.timezone Europe/Riga php_value date.timezone Asia/Shanghai 启动服务~]# systemctl start httpd~]# systemctl start zabbix-server~]# systemctl start zabbix-agent 配置web界面先访问http://SERVER_IP/zabbix ，跳出如下： document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"监控","slug":"监控","permalink":"http://yoursite.com/categories/监控/"}],"tags":[{"name":"Zabbix","slug":"Zabbix","permalink":"http://yoursite.com/tags/Zabbix/"}],"author":"DU"}]}