<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AIR PAN</title>
  
  <subtitle>NOTE</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-21T01:21:36.763Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>DuKe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WordPress个人博客搭建「一」</title>
    <link href="http://yoursite.com/2019/05/25/WordPress/01.WordPress/"/>
    <id>http://yoursite.com/2019/05/25/WordPress/01.WordPress/</id>
    <published>2019-05-25T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.763Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一步一步教你基于WordPress搭建自己的个人博客，WordPress作为成熟的CMS框架，美观，方便，插件多，更新频繁，非常适合个人博客与网站的搭建，无需太多的代码基础。</p><h1 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h1><h2 id="购买云服务器"><a href="#购买云服务器" class="headerlink" title="购买云服务器"></a>购买云服务器</h2><p>为了搭建个人网站，首先肯定需要一个云服务器<br>国内的推荐腾讯云，毕竟大公司，工单服务贼及时！还送免费的CDN加速流量  </p><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>有了云服务器，还需要一个域名。国内的域名需要备案，购买的话阿里云腾讯云都可以。</p><h1 id="搭建Apache-MySQL-PHP7环境"><a href="#搭建Apache-MySQL-PHP7环境" class="headerlink" title="搭建Apache+MySQL+PHP7环境"></a>搭建Apache+MySQL+PHP7环境</h1><p>这一部分介绍如何在Centos7 上配置Apache+MySQL+PHP7.</p><h2 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h2><p> yum install httpd httpd-devel  </p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>在CentOS7 中默认安装有MariaDB，这个是MySQL的分支，还是要在系统中安装MySQL，而且安装完成之后可以直接覆盖掉MariaDB</p><ul><li>下载MySQL官方的 Yum Repository 并安装MySQL。<br>[root@localhost ~]# wget -i -c <a href="http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm" target="_blank" rel="noopener">http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</a><br>[root@localhost ~]# yum -y install mysql57-community-release-el7-10.noarch.rpm<br>[root@localhost ~]# yum -y install mysql-community-server</li><li>MySQL 设置<br>找出初始的root用户的密码，通过如下命令可以在日志文件中找出密码：<br>[root@localhost ~]# grep “password” /var/log/mysqld.log<br>2019-05-19T00:42:03.830587Z 1 [Note] A temporary password is generated for root@localhost: 5&vPo_Vej1GZ<br>如下命令进入数据库：<br>[root@localhost ~]# mysql -uroot -p<br>输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库：<br>mysql> ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘new password’;</li></ul><h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><ul><li><p>安装php</p><h1 id="检查当前安装的PHP包"><a href="#检查当前安装的PHP包" class="headerlink" title="检查当前安装的PHP包"></a>检查当前安装的PHP包</h1><p>yum list installed | grep php<br>如果有安装的PHP包，先删除他们</p><h1 id="更新yum-源"><a href="#更新yum-源" class="headerlink" title="更新yum 源"></a>更新yum 源</h1><p>rpm -Uvh <a href="http://mirror.webtatic.com/yum/el5/latest.rpm" target="_blank" rel="noopener">http://mirror.webtatic.com/yum/el5/latest.rpm</a>    ##CentOs 5.x<br>rpm -Uvh <a href="http://mirror.webtatic.com/yum/el6/latest.rpm" target="_blank" rel="noopener">http://mirror.webtatic.com/yum/el6/latest.rpm</a>    ##CentOs 6.x<br>rpm -Uvh <a href="https://mirror.webtatic.com/yum/el7/epel-release.rpm" target="_blank" rel="noopener">https://mirror.webtatic.com/yum/el7/epel-release.rpm</a>   ##CentOs 7.X<br>rpm -Uvh <a href="https://mirror.webtatic.com/yum/el7/webtatic-release.rpm" target="_blank" rel="noopener">https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>yum install php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_64</p></li><li><p>测试PHP<br>[root@localhost ~]# cd  /var/www/html/<br>[root@localhost html]# vi info.php</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><?php</span><br><span class="line">        phpinfo();</span><br><span class="line">?></span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line">curl -I http://localhost/info.php</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 25 May 2019 01:06:40 GMT</span><br><span class="line">Server: Apache/2.4.6 (CentOS) PHP/7.0.33</span><br><span class="line">X-Powered-By: PHP/7.0.33</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="基于LAMP-部署WordPress"><a href="#基于LAMP-部署WordPress" class="headerlink" title="基于LAMP 部署WordPress"></a>基于LAMP 部署WordPress</h1><h2 id="安装WordPress"><a href="#安装WordPress" class="headerlink" title="安装WordPress"></a>安装WordPress</h2><ul><li>下载WordPress<br>直接通过wget命令去它官网下载最新的版本（英文）：<br>wget <a href="http://wordpress.org/latest.tar.gz" target="_blank" rel="noopener">http://wordpress.org/latest.tar.gz</a><br>下载中文wordpress-5.0.3:<br>wget <a href="https://cn.wordpress.org/wordpress-5.0.3-zh_CN.tar.gz" target="_blank" rel="noopener">https://cn.wordpress.org/wordpress-5.0.3-zh_CN.tar.gz</a><br>tar -xzvf wordpress-5.0.3-zh_CN.tar.gz</li></ul><h2 id="创建WordPress操作的数据库和用户"><a href="#创建WordPress操作的数据库和用户" class="headerlink" title="创建WordPress操作的数据库和用户"></a>创建WordPress操作的数据库和用户</h2><ul><li><p>创建数据库：<br>CREATE DATABASE wordpress;</p></li><li><p>配置权限：<br>GRANT ALL PRIVILEGES ON wordpress.* TO wordpress@localhost IDENTIFIED BY ‘your password’;<br>FLUSH PRIVILEGES;</p></li></ul><h2 id="配置WordPress"><a href="#配置WordPress" class="headerlink" title="配置WordPress"></a>配置WordPress</h2><ul><li><p>修改配置文件wordpress/wp-config-sample.php<br>修改的内容包括DB_NAME，DB_USER，DB_PASSWORD以及下面的唯一key</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define( 'DB_NAME', 'wordpress' );</span><br><span class="line">define( 'DB_USER', 'wordpress' );</span><br><span class="line">define( 'DB_PASSWORD', 'WordPress@1234' );</span><br><span class="line">define( 'DB_HOST', 'localhost' );</span><br></pre></td></tr></tbody></table></figure></li><li><p>拷贝WordPress源码至网站根目录<br>rm -rf /var/www/html<br>cp -r wordpress/* /var/www/<br>mv wordpress html</p></li><li><p>安装WordPress<br>访问你的ip或者是域名应该就是这样子的了：<br><a href="http://x.x.x.x/wp-admin/install.php" target="_blank" rel="noopener">http://x.x.x.x/wp-admin/install.php</a><br><img src="https://s2.ax1x.com/2019/05/25/VkkWx1.png" alt="VkkWx1.png"></p></li><li><p>根据提示安装并登录<br>安装WordPress -> 数据库信息 -> 站点、用户、邮箱 ->登陆</p></li><li><p>后台管理<br>输入“域名/wp-admin/”或“公网ip/wp-admin/”，就可以进入网站的后台管理页面了：<br><img src="https://s2.ax1x.com/2019/05/25/VkkBrV.md.png" alt="VkkBrV.md.png"></p></li><li><p>访问你的IP或者域名，一个初始的博客就搭建好了~：<br><img src="https://s2.ax1x.com/2019/05/25/VkZkzd.md.png" alt="VkZkzd.md.png"></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「WordPress」
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Wordpress" scheme="http://yoursite.com/tags/Wordpress/"/>
    
  </entry>
  
  <entry>
    <title>Python 的常用模块</title>
    <link href="http://yoursite.com/2019/05/20/Python/03.High-level/03.Pyhton%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/05/20/Python/03.High-level/03.Pyhton的常用模块/</id>
    <published>2019-05-20T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h1><ul><li>calendar</li><li><a href="https://www.runoob.com/python/python-date-time.html" target="_blank" rel="noopener">time</a></li><li><a href="https://www.cnblogs.com/tkqasn/p/6001134.html" target="_blank" rel="noopener">datetime</a></li><li>timeit</li><li><a href="https://www.runoob.com/python3/python3-os-file-methods.html" target="_blank" rel="noopener">os</a></li><li>shutil</li><li>归档</li><li>zip</li><li>random</li><li>string</li><li>上述所有模块使用理论上都应该先导入，string是特例</li></ul><h2 id="calendar"><a href="#calendar" class="headerlink" title="calendar"></a>calendar</h2><ul><li>跟日历相关的模块</li></ul><h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><ul><li><p>时间戳<br>一个时间表示，根据不同语言，可以是整数或者浮点数<br>是从1970年1月1日0时0分0秒到现在经历的秒数<br>如果表示的时间是1970年以前或者太遥远的未来，可能出现异常<br>32位操作系统能够支持到2038年</p></li><li><p>UTC时间<br>UTC又称为世界协调时间，以英国的格林尼治天文所在地区的时间作为参考的时间，也叫做世界标准时间。<br>中国时间是 UTC+8 东八区</p></li><li><p>夏令时<br>夏令时就是在夏天的时候将时间调快一小时，本意是督促大家早睡早起节省蜡烛！ 每天变成25个小时，本质没变还是24小时</p></li></ul><h3 id="时间元组"><a href="#时间元组" class="headerlink" title="时间元组"></a>时间元组</h3><ul><li><p>一个包含时间内容的普通元组</p><pre><code>索引      内容    属性            值0       年       tm_year     20151       月       tm_mon      1～122       日       tm_mday     1～313       时       tm_hour     0～234       分       tm_min      0～595       秒       tm_sec      0～61  60表示闰秒  61保留值6       周几     tm_wday     0～67       第几天    tm_yday     1～3668       夏令时    tm_isdst    0，1，-1（表示夏令时）</code></pre></li></ul><h3 id="时间模块的属性"><a href="#时间模块的属性" class="headerlink" title="时间模块的属性"></a>时间模块的属性</h3><ul><li>timezone: 当前时区和UTC时间相差的秒数，在没有夏令时的情况下的间隔,东八区的是 -28800</li><li>altzone  获取当前时区与UTC时间相差的秒数，在有夏令时的情况下，</li><li>daylight 测当前是否是夏令时时间状态, 0 表示是。time.daylight</li></ul><h3 id="时间模块的方法"><a href="#时间模块的方法" class="headerlink" title="时间模块的方法"></a>时间模块的方法</h3><ul><li><p>time.time()<br>返回值: 时间戳</p></li><li><p>localtime() 得到当前时间的时间结构<br>t = time.localtime()<br>print(t.tm_hour)</p></li><li><p>asctime() 返回元组的正常字符串化之后的时间格式<br>格式：time.asctime（时间元组）<br>返回值:字符串 Tue Jun  6 11:11:00 2017<br>t = time.localtime()<br>tt = time.asctime(t)</p></li><li><p>ctime: 获取字符串化的当前时间<br>格式：time.ctime()<br>返回值：字符串 Mon Mar 26 20:46:30 2018<br>t = time.ctime()</p></li><li><p>mktime() 使用时间元组获取对应的时间戳<br>格式：time.mktime（时间元组）<br>返回值：浮点数时间戳<br>lt = time.localtime()<br>ts = time.mktime(lt)</p></li><li><p>sleep: 使程序进入睡眠，n秒后继续<br>格式：sleep(5)</p></li><li><p>clock() 获取CPU时间<br>格式：time.clock()</p></li><li><p>strftime:将时间元组转化为自定义的字符串格式</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">格式  含义  备注</span><br><span class="line">%a  本地（locale）简化星期名称    </span><br><span class="line">%A  本地完整星期名称    </span><br><span class="line">%b  本地简化月份名称    </span><br><span class="line">%B  本地完整月份名称    </span><br><span class="line">%c  本地相应的日期和时间表示    </span><br><span class="line">%d  一个月中的第几天（01 - 31）   </span><br><span class="line">%H  一天中的第几个小时（24 小时制，00 - 23）   </span><br><span class="line">%I  一天中的第几个小时（12 小时制，01 - 12）   </span><br><span class="line">%j  一年中的第几天（001 - 366）  </span><br><span class="line">%m  月份（01 - 12） </span><br><span class="line">%M  分钟数（00 - 59）    </span><br><span class="line">%p  本地 am 或者 pm 的相应符    注1</span><br><span class="line">%S  秒（01 - 61）  注2</span><br><span class="line">%U  一年中的星期数（00 - 53 星期天是一个星期的开始）第一个星期天之前的所有天数都放在第 0 周   注3</span><br><span class="line">%w  一个星期中的第几天（0 - 6，0 是星期天） 注3</span><br><span class="line">%W  和 %U 基本相同，不同的是 %W 以星期一为一个星期的开始  </span><br><span class="line">%x  本地相应日期  </span><br><span class="line">%X  本地相应时间  </span><br><span class="line">%y  去掉世纪的年份（00 - 99）    </span><br><span class="line">%Y  完整的年份   </span><br><span class="line">%z  用 +HHMM 或 -HHMM 表示距离格林威治的时区偏移（H 代表十进制的小时数，M 代表十进制的分钟数）      </span><br><span class="line">%%  %号本身</span><br><span class="line"></span><br><span class="line"># 把时间表示成: 2018年3月26日 21:05</span><br><span class="line">t = time.localtime()</span><br><span class="line">ft = time.strftime("%Y年%m月%d日 %H:%M" , t)</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="datetime-模块"><a href="#datetime-模块" class="headerlink" title="datetime 模块"></a>datetime 模块</h2><ul><li>datetinme 提供日期和时间的运算和表示</li></ul><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><ul><li><p>datetime.today()<br>返回当前本地datetime.</p></li><li><p>datetime.fromtimestamp(time.time()). </p></li><li><p>datetime.now([tz])<br>返回当前本地日期和时间,如果可选参数tz为None或没有详细说明,这个方法会像today().  </p></li><li><p>datetime.utcnow()<br>返回当前的UTC日期和时间, 如果tzinfo None ,那么与now()类似.</p></li><li><p>datetime.fromtimestamp(timestamp[, tz])<br>根据时间戳返回本地的日期和时间.tz指定时区.</p></li><li><p>datetime.utcfromtimestamp(timestamp)<br>根据时间戳返回 UTC datetime.</p></li><li><p>datetime.fromordinal(ordinal)<br>根据Gregorian ordinal 返回datetime.</p></li><li><p>datetime.combine(date, time)<br>根据date和time返回一个新的datetime.</p></li><li><p>datetime.strptime(date_string, format)<br>根据date_string和format返回一个datetime.</p></li></ul><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul><li><p>datetime.date()<br>返回相同年月日的date对象.</p></li><li><p>datetime.time()<br>返回相同时分秒微秒的time对象.</p></li><li><p>datetime.replace(kw)<br>kw in [year, month, day, hour, minute, second, microsecond, tzinfo], 与date类似.</p></li></ul><h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><ul><li>datetime.min: datetime(MINYEAR, 1, 1).</li><li>datetime.max: datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999).</li></ul><h3 id="实例属性-read-only"><a href="#实例属性-read-only" class="headerlink" title="实例属性(read-only)"></a>实例属性(read-only)</h3><ul><li>datetime.year: 1 至 9999</li><li>datetime.month: 1 至 12</li><li>datetime.day: 1 至 n</li><li>datetime.hour: In range(24). 0 至 23</li><li>datetime.minute: In range(60).</li><li>datetime.second: In range(60).</li><li>datetime.microsecond: In range(1000000).</li></ul><h2 id="timeit-时间测量工具"><a href="#timeit-时间测量工具" class="headerlink" title="timeit-时间测量工具"></a>timeit-时间测量工具</h2><ul><li><p>测量程序运行时间间隔实验</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import timeit</span><br><span class="line"></span><br><span class="line"># 生成列表两种方法的比较</span><br><span class="line"># 如果单纯比较生成一个列表的时间，可能很难实现</span><br><span class="line">c = '''</span><br><span class="line">sum = []</span><br><span class="line">for i in range(1000):</span><br><span class="line">    sum.append(i)</span><br><span class="line"> </span><br><span class="line"># 利用timeit调用代码，执行100000次，查看运行时间</span><br><span class="line">t1= timeit.timeit(stmt="[i for i in range(1000)]", number=100000 )</span><br><span class="line"></span><br><span class="line"># 测量代码c执行100000次运行结果</span><br><span class="line">t2 = timeit.timeit(stmt=c, number=100000)</span><br><span class="line">print(t1)</span><br><span class="line">print(t2)</span><br><span class="line"></span><br><span class="line">2.6834080209991953</span><br><span class="line">6.945136217000254</span><br></pre></td></tr></tbody></table></figure></li><li><p>timeit 可以执行一个函数，来测量一个函数的执行时间 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def doIt():</span><br><span class="line">    num = 3</span><br><span class="line">    for i in range(num):</span><br><span class="line">        print("Repeat for {0}".format(i))</span><br><span class="line">       </span><br><span class="line"># 执行函数，重复10次</span><br><span class="line">t = timeit.timeit(stmt=doIt, number=10)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">s = '''</span><br><span class="line">def doIt(num):</span><br><span class="line">    for i in range(num):</span><br><span class="line">        print("Repeat for {0}".format(i))</span><br><span class="line">'''</span><br><span class="line"></span><br><span class="line"># 执行doIt(num)</span><br><span class="line"># setup负责把环境变量准备好</span><br><span class="line"># 实际相当于给timeit创造了一个小环境</span><br><span class="line"># 在创作的小环境中， 代码执行的顺序大致是</span><br><span class="line"></span><br><span class="line">'''</span><br><span class="line">def doIt(num):</span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">num = 3</span><br><span class="line"></span><br><span class="line">doIt(num)</span><br><span class="line">'''</span><br><span class="line"></span><br><span class="line">t = timeit.timeit("doIt(num)", setup=s+"num=3", number=10)</span><br><span class="line">print(t)</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="os-操作系统相关"><a href="#os-操作系统相关" class="headerlink" title="os - 操作系统相关"></a>os - 操作系统相关</h2><ul><li>跟操作系统相关，主要是文件操作</li><li>于系统相关的操作，主要包含在三个模块里<ul><li>os， 操作系统目录相关</li><li>os.path, 系统路径相关操作</li><li>shutil， 高级文件操作，目录树的操作，文件赋值，删除，移动</li></ul></li><li>路径：<ul><li>绝对路径： 总是从根目录上开始</li><li>相对路径： 基本以当前环境为开始的一个相对的地方</li></ul></li><li>import os</li></ul><h3 id="os-模块"><a href="#os-模块" class="headerlink" title="os 模块"></a>os 模块</h3><ul><li><p>getcwd() 获取当前的工作目录<br>格式：os.getcwd()<br>返回值：当前工作目录的字符串</p></li><li><p>chdir() 改变当前的工作目录<br>格式：os.chdir（路径）<br>返回值：无</p></li><li><p>listdir() 获取一个目录中所有子目录和文件的名称列表<br>格式:os.listdir(路径)<br>返回值：所有子目录和文件名称的列表</p></li><li><p>makedirs（） 递归创建文件夹<br>格式：os.makedirs(递归路径)<br>返回值：无<br>递归路径：多个文件夹层层包含的路径就是递归路径 例如 ‘a/b/c…’</p></li></ul><ul><li><p>system() 运行系统shell命令<br>格式：os.system(系统命令)<br>返回值：打开一个shell或者终端界面<br>一般推荐使用subprocess代替</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rst = os.system("ls")</span><br><span class="line">print(rst)</span><br></pre></td></tr></tbody></table></figure></li><li><p>getenv() 获取指定的系统环境变量值<br>相应的还有putenv<br>格式：os.getenv(‘环境变量名’)<br>返回值：指定环境变量名对应的值</p></li></ul><h3 id="值部分"><a href="#值部分" class="headerlink" title="值部分"></a>值部分</h3><ul><li>os.curdir: curretn dir,当前目录</li><li>os.pardir: parent dir， 父亲目录</li><li>os.sep: 当前系统的路径分隔符<ul><li>windows: “\”</li><li>linux: “/“</li></ul></li><li>os.linesep: 当前系统的换行符号<ul><li>windows: “\r\n”</li><li>unix,linux,macos: “\n”</li></ul></li><li>os.name： 当前系统名称<ul><li>windows： nt</li><li>mac，unix，linux： posix</li></ul></li></ul><h3 id="os-path-模块-路径相关的模块"><a href="#os-path-模块-路径相关的模块" class="headerlink" title="os.path 模块,路径相关的模块"></a>os.path 模块,路径相关的模块</h3><ul><li><p>abspath() 将路径转化为绝对路径<br>格式:os.path.abspath(‘路径’)<br>返回值：路径的绝对路径形式</p></li><li><p>basename() 获取路径中的文件名部分<br>格式:os.path.basename(路径)<br>返回值：文件名字符串</p></li><li><p>join() 将多个路径拼合成一个路径<br>格式：os.path.join(路径1，路径2….)<br>返回值：组合之后的新路径字符串</p></li><li><p>split() 将路径切割为文件夹部分和当前文件部分<br>格式:os.path.split（路径）<br>返回值：路径和文件名组成的元组</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t = op.split("/home/tlxy/dana.haha")</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">d,p = op.split("/home/tlxy/dana.haha")</span><br><span class="line">print(d, p)</span><br><span class="line"></span><br><span class="line">('/home/tlxy', 'dana.haha')</span><br><span class="line">/home/tlxy dana.haha</span><br></pre></td></tr></tbody></table></figure></li><li><p>isdir() 检测是否是目录<br>格式：os.path.isdir(路径)<br>返回值：布尔值</p></li><li><p>jexists() 检测文件或者目录是否存在<br>格式：os.path.exists(路径)<br>返回值:布尔值</p></li></ul><h2 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h2><ul><li><p>copy() 复制文件<br>格式：shutil.copy(来源路径，目标路径)<br>返回值：返回目标路径<br>拷贝的同时，可以给文件重命名</p></li><li><p>copy2() 复制文件,(保留元数据文件信息）<br>格式：shutil.copy2(来源路径，目标路径)<br>返回值：返回目标路径<br>注意：copy和copy2的唯一区别在于copy2复制文件时尽量保留元数据</p></li><li><p>copyfile()将一个文件中的内容复制到另外一个文件当中<br>格式：shutil.copyfile（’源路径’,’目标路径’)<br>返回值：无</p></li><li><p>move() 移动文件/文件夹<br>格式：shutil.move(源路径，目标路径)<br>返回值：目标路径</p></li></ul><h2 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h2><ul><li><p>归档： 把多个文件或者文件夹合并到一个文件当中</p></li><li><p>make_archive() 归档操作<br>格式:shutil.make_archive(‘归档之后的目录和文件名’,’后缀’,’需要归档的文件夹’)<br>返回值：归档之后的地址</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#help(shutil.make_archive)</span><br><span class="line"></span><br><span class="line"># 是想得到一个叫做tuling.zip的归档文件</span><br><span class="line">rst = shutil.make_archive("/home/tlxy/tuling", "zip", "/home/tlxy/dana")</span><br><span class="line">print(rst) # /home/tlxy/tuling.zip</span><br></pre></td></tr></tbody></table></figure></li><li><p>unpack_archive() 解包操作<br>格式：shutil.unpack_archive(‘归档文件地址’,’解包之后的地址’)<br>返回值：解包之后的地址</p></li></ul><h2 id="zip-压缩包"><a href="#zip-压缩包" class="headerlink" title="zip - 压缩包"></a>zip - 压缩包</h2><ul><li>压缩： 用算法把多个文件或者文件夹无损或者有损合并到一个文件当中</li><li><p>模块名称叫 zipfile</p></li><li><p>zipfile.ZipFile(file[, mode[, compression[, allowZip64]]])</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个ZipFile对象，表示一个zip文件。参数file表示文件的路径或类文件对象(file-like object)；参数mode指示打开zip文件的模式，默认值为’r’，表示读已经存在的zip文件，也可以为’w’或’a’，’w’表示新建一个zip文档或覆盖一个已经存在的zip文档，’a’表示将数据附加到一个现存的zip文档中。参数compression表示在写zip文档时使用的压缩方法，它的值可以是zipfile. ZIP_STORED 或zipfile. ZIP_DEFLATED。如果要操作的zip文件大小超过2G，应该将allowZip64设置为True。</span><br><span class="line"></span><br><span class="line"># 对/home/tlxy/tuling.zip压缩</span><br><span class="line">zf = zipfile.ZipFile("/home/tlxy/tuling.zip")</span><br></pre></td></tr></tbody></table></figure></li><li><p>ZipFile.getinfo(name):<br>获取zip文档内指定文件的信息。返回一个zipfile.ZipInfo对象，它包括文件的详细信息。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rst = zf.getinfo("dana.haha")</span><br><span class="line">print(rst)</span><br><span class="line"></span><br><span class="line"><ZipInfo filename='dana.haha' compress_type=deflate filemode='-rw-rw-r--' file_size=41 compress_size=46></span><br></pre></td></tr></tbody></table></figure></li><li><p>ZipFile.namelist()<br>获取zip文档内所有文件的名称列表。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nl = zf.namelist()</span><br><span class="line"></span><br><span class="line"># ZipFile.extractall([path[, members[, pwd]]])</span><br><span class="line">#  解压zip文档中的所有文件到当前目录。参数members的默认值为zip文档内的所有文件名称列表，也可以自己设置，选择要解压的文件名称。</span><br><span class="line"></span><br><span class="line">rst = zf.extractall("/home/tlxy/dana")</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><ul><li>随机数</li><li><p>所有的随机模块都是伪随机</p></li><li><p>random() 获取0-1之间的随机小数<br>格式：random.random()<br>返回值：随机0-1之间的小数</p></li><li><p>choice() 随机返回序列中的某个值<br>格式：random.choice(序列)<br>返回值：序列中的某个值</p></li></ul><ul><li><p>shuffle() 随机打乱列表<br>格式：random.shuffle(列表)<br>返回值：打乱顺序之后的列表</p></li><li><p>randint(a,b): 返回一个a到b之间的随机整数，包含a和b</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「常用模块」
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 的异常处理</title>
    <link href="http://yoursite.com/2019/05/14/Python/03.High-level/02.Python%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/14/Python/03.High-level/02.Python的异常处理/</id>
    <published>2019-05-14T10:11:07.000Z</published>
    <updated>2019-07-21T07:00:42.611Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul><li>异常的分类</li><li>异常处理</li><li>异常手动抛出</li><li>自定义异常</li></ul><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><pre><code>AssertError 断言语句（assert）失败AttributeError 尝试访问未知的对象属性EOFError 用户输入文件末尾标志EOF（Ctrl+d）FloatingPointError 浮点计算错误GeneratorExit generator.close()方法被调用的时候ImportError 导入模块失败的时候IndexError 索引超出序列的范围KeyError 字典中查找一个不存在的关键字KeyboardInterrupt 用户输入中断键（Ctrl+c）MemoryError 内存溢出（可通过删除对象释放内存）NameError 尝试访问一个不存在的变量NotImplementedError 尚未实现的方法OSError 操作系统产生的异常（例如打开一个不存在的文件）OverflowError 数值运算超出最大限制ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象RuntimeError 一般的运行时错误StopIteration 迭代器没有更多的值SyntaxError Python的语法错误IndentationError 缩进错误TabError Tab和空格混合使用SystemError Python编译器系统错误SystemExit Python编译器进程被关闭TypeError 不同类型间的无效操作UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）UnicodeError Unicode相关的错误（ValueError的子类）UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）ValueError 传入无效的参数ZeroDivisionError 除数为零</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li>不能保证程序永远正确运行</li><li>但是，必须保证程序在最坏的情况下得到的问题被妥善处理</li><li><p>python的异常处理模块全部语法为：</p><pre><code>try:    尝试实现某个操作，    如果没出现异常，任务就可以完成    如果出现异常，将异常从当前代码块扔出去尝试解决异常except 异常类型1:    解决方案1：用于尝试在此处处理异常解决问题except 异常类型2：    解决方案2：用于尝试在此处处理异常解决问题except (异常类型1,异常类型2...)    解决方案：针对多个异常使用相同的处理方式excpet:    解决方案：所有异常的解决方案else:    如果没有出现任何异常，将会执行此处代码finally:    管你有没有异常都要执行的代码</code></pre></li></ul><ul><li>流程</li></ul><ol><li>执行try下面的语句</li><li>如果出现异常，则在except语句里查找对应异常病进行处理</li><li>如果没有出现异常，则执行else语句内容</li><li>最后，不管是否出现异常，都要执行finally语句</li></ol><ul><li>除except(最少一个)以外，else和finally可选<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"># 简单异常案例1:</span><br><span class="line">try:</span><br><span class="line">    num = int(input("Plz input your number:"))</span><br><span class="line">    rst = 100/num</span><br><span class="line">    print("计算结果是： {0}".format(rst))</span><br><span class="line">except:</span><br><span class="line">    print("你特娘的输入的啥玩意儿")</span><br><span class="line">    # exit是退出程序的意思</span><br><span class="line">    exit()</span><br><span class="line">  </span><br><span class="line">Plz input your number:0</span><br><span class="line">你特娘的输入的啥玩意儿  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 简单异常案例2:</span><br><span class="line"># 给出提示信息</span><br><span class="line">try:</span><br><span class="line">    num = int(input("Plz input your number:"))</span><br><span class="line">    rst = 100/num</span><br><span class="line">    print("计算结果是： {0}".format(rst))</span><br><span class="line"># 捕获异常后，把异常实例化，出息信息会在实例里</span><br><span class="line"># 注意以下写法</span><br><span class="line"># 以下语句是捕获ZeroDivisionError异常并实例化实例e</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print("你特娘的输入的啥玩意儿")</span><br><span class="line">    print(e)</span><br><span class="line">    # exit是退出程序的意思</span><br><span class="line">    exit()</span><br><span class="line">    </span><br><span class="line">Plz input your number:0</span><br><span class="line">你特娘的输入的啥玩意儿</span><br><span class="line">division by zero</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 简单异常案例3:</span><br><span class="line"># 给出提示信息</span><br><span class="line">try:</span><br><span class="line">    num = int(input("Plz input your number:"))</span><br><span class="line">    rst = 100/num</span><br><span class="line">    print("计算结果是： {0}".format(rst))</span><br><span class="line"></span><br><span class="line"># 如果是多种error的情况</span><br><span class="line"># 需要把越具体的错误，越往前放</span><br><span class="line"># 在异常类继承关系中，越是子类的异常，越要往前放，</span><br><span class="line"># 越是父亲类的异常，越要往后放</span><br><span class="line"></span><br><span class="line"># 在处理异常的时候，一旦拦截到某一个异常，则不在继续往下查看，直接进行下一个</span><br><span class="line"># 代码，即有finally则执行finally语句块，否则就执行下一个大的语句</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print("你特娘的输入的啥玩意儿")</span><br><span class="line">    print(e)</span><br><span class="line">    # exit是退出程序的意思</span><br><span class="line">    exit()</span><br><span class="line">except NameError as e:</span><br><span class="line">    print("名字起错了")</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">except AttributeError as e:</span><br><span class="line">    print("好像属性有问题")</span><br><span class="line">    print(e)</span><br><span class="line">    exit()</span><br><span class="line">   </span><br><span class="line"># 所有异常都是继承自Exception</span><br><span class="line"># 如果写上下面这句话，任何异常都会拦截住</span><br><span class="line"># 而且，下面这句话一定是最后一个exception</span><br><span class="line">except Exception as e:</span><br><span class="line">    print("我也不知道就出错了")</span><br><span class="line">    print(e)</span><br><span class="line">    </span><br><span class="line">except ValueError as e:</span><br><span class="line">    print("NO>>>>>>>>>>>>>>>>>>") </span><br><span class="line"></span><br><span class="line">Plz input your number:rerer</span><br><span class="line">我也不知道就出错了</span><br><span class="line">invalid literal for int() with base 10: 'rerer'</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="用户手动引发异常"><a href="#用户手动引发异常" class="headerlink" title="用户手动引发异常"></a>用户手动引发异常</h2><ul><li>当某些情况，用户希望自己引发一个异常的时候，可以使用</li><li>raise 关键字来引发异常<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># raise案例-1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 手动引发一个异常</span></span><br><span class="line">    <span class="comment">#　注意语法：　raise　errorclassname</span></span><br><span class="line">    <span class="keyword">raise</span> ValueError</span><br><span class="line">    print(<span class="string">"还没完呀"</span>)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"NameError"</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"ValueError"</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"有异常"</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">"我肯定会被执行的"</span>)</span><br><span class="line">    </span><br><span class="line">ValueError</span><br><span class="line">我肯定会被执行的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># raise案例-2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自己定义异常</span></span><br><span class="line"><span class="comment"># 需要注意：　自定义异常必须是系统异常的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DanaValueError</span><span class="params">(ValueError)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 手动引发一个异常</span></span><br><span class="line">    <span class="comment">#　注意语法：　raise　errorclassname</span></span><br><span class="line">    <span class="keyword">raise</span> DanaValueError</span><br><span class="line">    print(<span class="string">"还没完呀"</span>)</span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"NameError"</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"ValueError"</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"有异常"</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">"我肯定会被执行的"</span>)</span><br><span class="line">    </span><br><span class="line">ValueError</span><br><span class="line">我肯定会被执行的    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># else语句案例:</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    num = int(input(<span class="string">"Plz input your number:"</span>))</span><br><span class="line">    rst = <span class="number">100</span>/num</span><br><span class="line">    print(<span class="string">"计算结果是： {0}"</span>.format(rst))</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"Exception"</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"No Exception"</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">"反正我会被执行"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Plz input your number:ghhj</span><br><span class="line">Exception</span><br><span class="line">反正我会被执行</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="关于自定义异常"><a href="#关于自定义异常" class="headerlink" title="关于自定义异常"></a>关于自定义异常</h2><ul><li>只要是raise异常，则推荐自定义异常</li><li>在自定义异常的时候，一般包含以下内容：<ul><li>自定义发生异常的异常代码</li><li>自定义发生异常后的问题提示</li><li>自定义发生异常的行数</li></ul></li><li>最终的目的是，一旦发生异常，方便程序员快速定位错误现场</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「异常」
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 的模块和包</title>
    <link href="http://yoursite.com/2019/05/10/Python/03.High-level/01.Python%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"/>
    <id>http://yoursite.com/2019/05/10/Python/03.High-level/01.Python的模块和包/</id>
    <published>2019-05-10T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.769Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-的模块和包"><a href="#Python-的模块和包" class="headerlink" title="Python 的模块和包"></a>Python 的模块和包</h1><ul><li>模块</li><li>包  </li><li>命名空间</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul><li>一个模块就是一个包含pytho代码的文件， 后缀名成是.py就可以，模块就是个python文件</li><li><p>为什么我们用模块<br>程序太大，编写维护非常不方便，需要拆分<br>模块可以增加代码重复利用的方式<br>当做命名空间使用，避免命名冲突</p></li><li><p>如何定义模块<br>模块就是一个普通文件，所以任何代码可以直接书写<br>不过根据模块的规范，最好在模块中编写以下内容：<br>函数（单一功能）<br>类（相似功能的组合，或者类似业务模块）<br>测试代码</p></li><li><p>如何使用模块<br>模块直接导入</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import module_name</span><br><span class="line">module_name.function_name</span><br><span class="line">module_name.class_name</span><br></pre></td></tr></tbody></table></figure></li><li><p>假如模块名称直接以数字开头，借助importlib帮助</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 借助于importlib包可以实现导入以数字开头的模块名称</span><br><span class="line">import importlib</span><br><span class="line"></span><br><span class="line"># 相当于导入了一个叫01的模块并把导入模块赋值给了tuling</span><br><span class="line">tuling = importlib.import_module("01")</span><br><span class="line"></span><br><span class="line">stu = tuling.Student()</span><br><span class="line">stu.say()</span><br></pre></td></tr></tbody></table></figure></li><li><p>import 模块 as 别名<br>from module_name import func_name, class_name<br>按上述方法有选择性的导入<br>使用的时候可以直接使用导入的内容，不需要前缀</p></li><li><p>from module_name import *<br>导入模块所有内容</p></li><li><p><code>if __name__ == "__main__</code> 的使用<br>可以有效避免模块代码被导入的时候被动执行的问题<br>建议所欲程序的入口都以此代码为入口</p></li></ul><h3 id="模块的搜索路径和存储"><a href="#模块的搜索路径和存储" class="headerlink" title="模块的搜索路径和存储"></a>模块的搜索路径和存储</h3><ul><li><p>什么是模块的搜索路径：<br>加载模块的时候，系统会在那些地方寻找此模块</p></li><li><p>系统默认的模块搜索路径</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path 属性可以获取路径列表</span><br></pre></td></tr></tbody></table></figure></li><li><p>添加搜索路径: sys.path.append(dir)</p></li><li><p>模块的加载顺序<br>搜索内存中已经加载好的模块<br>搜索python的内置模块<br>搜索sys.path路径 </p></li></ul><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul><li>包是一种组织管理代码的方式，包里面存放的是模块<br>-　用于将模块包含在一起的文件夹就是包  </li><li>自定义包的结构</li></ul><pre><code>|---包|---|--- __init__.py  包的标志文件|---|--- 模块1|---|--- 模块2|---|--- 子包(子文件夹)|---|---|--- __init__.py  包的标志文件|---|---|--- 子包模块1|---|---|--- 子包模块2</code></pre><ul><li><p>包的导入操作<br>import package_name<br>直接导入一个包，可以使用<strong>init</strong>.py中的内容<br>使用方式是：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package_name.func_name</span><br><span class="line">package_name.class_name.func_name()</span><br></pre></td></tr></tbody></table></figure></li><li><p>import package_name as p<br>注意:此种方法是默认对<strong>init</strong>.py内容的导入    </p></li><li><p>import package.module<br>导入包中某一个具体的模块<br>使用方法</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package.module.func_name</span><br><span class="line">package.module.class.fun()</span><br><span class="line">package.module.class.var</span><br></pre></td></tr></tbody></table></figure></li><li><p>import package.module as pm </p></li><li><p>from … import 导入<br>from package import module1, module2, module3<br>此种导入方法不执行<code>__init__</code>的内容</p></li><li><p>from package import *<br>导入当前包 <code>__init__.py</code>文件中所有的函数和类<br>使用方法</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func_name()</span><br><span class="line">class_name.func_name()</span><br><span class="line">class_name.var</span><br></pre></td></tr></tbody></table></figure></li><li><p>from package.module import *<br>导入包中指定的模块的所有内容<br>使用方法</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func_name()</span><br><span class="line">class_name.func_name()</span><br></pre></td></tr></tbody></table></figure></li><li><p>在开发环境中经常会所以用其他模块，可以在当前包中直接导入其他模块中的内容</p></li><li><p>import 完整的包或者模块的路径</p></li><li><p><code>__all__</code> 的用法<br>在使用from package import <em> 的时候， </em> 可以导入的内容  </p></li><li><p><code>__init__.py</code>中如果文件为空， 或者没有 <code>__all__</code>， 那么只可以把<code>__init__</code>中的内容导入</p></li><li><p><code>__init__</code> 如果设置了<code>__all__</code>的值，那么则按照<code>__all__</code> 指定的子包或者模块进行加载<br>  如此则不会载入<code>__init__</code>中的内容</p></li><li><p><code>__all__=['module1', 'module2', 'package1'.........]</code></p></li></ul><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul><li>用于区分不同位置不同功能但相同名称的函数或者变量的一个特定前缀</li><li>作用是防止命名冲突<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setName()</span><br><span class="line">Student.setName()</span><br><span class="line">Dog.setName()</span><br></pre></td></tr></tbody></table></figure></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「Python 的模块和包」
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Ansible 基础 「一」</title>
    <link href="http://yoursite.com/2019/05/08/Ansible/01.ansible/"/>
    <id>http://yoursite.com/2019/05/08/Ansible/01.ansible/</id>
    <published>2019-05-08T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.765Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ansible-简介"><a href="#ansible-简介" class="headerlink" title="ansible 简介"></a>ansible 简介</h1><h2 id="ansible-系统架构"><a href="#ansible-系统架构" class="headerlink" title="ansible 系统架构"></a>ansible 系统架构</h2><h3 id="ansible简介"><a href="#ansible简介" class="headerlink" title="ansible简介"></a>ansible简介</h3><p>ansible是新出现的自动化运维工具，ansible是一个配置管理和应用部署工具,基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric.SaltStack   ）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。ansible是基于模块工作的，本身没有批量部署的能力。真正具有批量部署的是ansible所运行的模块，ansible只是提供一种框架,根据官方提供的信息，当前使用ansible的用户有:<br>美国国家航空航天局（NASA /ˈnæsə/）<br>evernote(印象笔记),rackspace(全球三大云计算中心之一),atlassian,twitter(全球互联网上访问量最大的十个网站之一)等</p><h3 id="ansible在生产环境当中的应用"><a href="#ansible在生产环境当中的应用" class="headerlink" title="ansible在生产环境当中的应用"></a>ansible在生产环境当中的应用</h3><p>自动化部署应用<br>自动化管理配置<br>自动化持续交付<br>自动化(aws)云服务器管理</p><h3 id="ansible的优点"><a href="#ansible的优点" class="headerlink" title="ansible的优点"></a>ansible的优点</h3><ul><li>ansible糅合了众多老牌运维工具的优点，基本上pubbet和saltstack能实现的功能全部能实现</li><li>轻量级，无需在客户端安装agent，更新时，只需在操作机上进行一次更新即可；</li><li>ansible是一个工具，ansible不需要启动服务，仅仅只是一个工具，可以轻松的实现分布式扩展</li><li>批量任务执行可以写成脚本，而且不用分发到远程就可以执行</li><li>ansible是一致性，高可靠性，安全性设计的轻量级自动化工具</li><li>使用python编写，维护更简单，ruby语法过于复杂；</li></ul><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>no agents：不需要在被管控主机上安装任何客户端；</li><li>no server：无服务器端，使用时直接运行命令即可；</li><li>modules in any languages：基于模块工作，可使用任意语言开发模块；</li><li>yaml，not code：使用yaml语言定制剧本playbook；</li><li>ssh by default：基于SSH工作；</li><li>strong multi-tier solution：可实现多级指挥。</li></ul><h3 id="ansible的基本架构"><a href="#ansible的基本架构" class="headerlink" title="ansible的基本架构"></a>ansible的基本架构</h3><ul><li>连接插件(connectior plugins) 用于连接主机 用来连接被管理端</li><li>核心模块(core modules) 连接主机实现操作， 它依赖于具体的模块来做具体的事情</li><li>自定义模块(custom modules) 根据自己的需求编写具体的模块</li><li>插件(plugins) 完成模块功能的补充</li><li>playbooks(剧本) ansible的配置文件,将多个任务定义在剧本中，由ansible自动执行</li><li>host inventory（主机清单）定义ansible需要操作主机的范围</li><li>最重要的一点是 ansible是模块化的 它所有的操作都依赖于模块<br>比如我需要创建一个文件 那么我就需要调用file模块 我需要copy文件，那么我就需要copy模块<br>我需要测试机器的存活率，那么就需要ping模块，例如：ansible all -m ping</li></ul><h2 id="ansible安装"><a href="#ansible安装" class="headerlink" title="ansible安装"></a>ansible安装</h2><p>ansible只是一个进程  不需要添加数据库也不需要启动和运行守护进程它只是一个进程你可以轻松使用它安装在任何一点主机上面（除了windows）ansible管理机不能安装到windows上面<br>版本的选择 因为2.0有非常大的改进  一般都会使用2.0以上的版本<br>控制机的要求  因为ansible是python写的  所以需要在安装了python2.6或者2.7以上的python版本才可以安装<br>管理节点的要求  需要安装ssh python版本在2.5以上</p><h3 id="安装有3个方式"><a href="#安装有3个方式" class="headerlink" title="安装有3个方式"></a>安装有3个方式</h3><ul><li><p>yum -y install ansible<br>wget -O /etc/yum.repos.d/epel.repo <a href="http://mirrors.aliyun.com/repo/epel-6.repo（下载yum源）" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/epel-6.repo（下载yum源）</a></p></li><li><p>pip install ansible</p></li><li><p>从github下载</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git：//github.com/ansible/ansible.git --recursive</span><br><span class="line">$ cd ./ansible</span><br><span class="line">$ make rpm</span><br><span class="line">$ sudo rpm -Uvh ./rpm-build/ansible-*.noarch.rpm</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="任务执行模式"><a href="#任务执行模式" class="headerlink" title="任务执行模式"></a>任务执行模式</h3><p>ansible系统由控制主机对被管节点的操作方式有两种ad_hoc和playbook</p><ul><li><p>ad_hoc单命令模式 可以对多台主机执行单个命令<br>ansible all -a “/bin/echo hello”</p></li><li><p>playbook通过多个tasks的集合完成一类功能如web的安装部署，数据库服务器的批量备份等</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: webservers</span><br><span class="line">  vars:</span><br><span class="line">    http_port: 80</span><br><span class="line">    max_clients: 200</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">  - name: ensure apache is at the latest version</span><br><span class="line">    yum: name=httpd state=latest</span><br><span class="line">  - name: write the apache config file</span><br><span class="line">    template: src=/srv/httpd.j2 dest=/etc/httpd.conf</span><br><span class="line">    notify:</span><br><span class="line">    - restart apache</span><br><span class="line">  - name: ensure apache is running (and enable it at boot)</span><br><span class="line">    service: name=httpd state=started enabled=yes</span><br><span class="line">  handlers:</span><br><span class="line">    - name: restart apache</span><br><span class="line">      service: name=httpd state=restarted</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="ansible的七个指令："><a href="#ansible的七个指令：" class="headerlink" title="ansible的七个指令："></a>ansible的七个指令：</h2><p>ansible、ansible-doc、ansible-galaxy、ansible-lint、ansible-playbook、ansible-pull、ansible-vault 。这里我们只查看usage部分，详细部分可以通过 “指令 -h”  的方式获取。</p><h3 id="ansible"><a href="#ansible" class="headerlink" title="ansible"></a>ansible</h3><p>[root@localhost ~]# ansible -h<br>Usage: ansible <host-pattern> [options]<br>ansible是指令核心部分，其主要用于执行ad-hoc命令，即单条命令。默认后面需要跟主机和选项部分，默认不指定模块时，使用的是command模块。<br>如：<br>[root@VM_0_2_centos ~]# ansible 127.0.0.1 -a “date”<br>127.0.0.1 | CHANGED | rc=0 >><br>Sun Jun  2 18:32:30 CST 2019</host-pattern></p><p>默认使用的模块是可以在ansible.cfg 中进行修改的。<br>ansible命令下的参数部分解释如下<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">参数：</span><br><span class="line"> -a ‘Arguments‘, --args=‘Arguments‘ 命令行参数</span><br><span class="line"> -m NAME, --module-name=NAME 指定执行的模块，默认使用 command 模块</span><br><span class="line">-i PATH, --inventory=PATH 指定库存主机文件的路径,默认为/etc/ansible/hosts. </span><br><span class="line">-u Username， --user=Username 执行用户，使用这个远程用户名而不是当前用户 </span><br><span class="line">-U --sud-user=SUDO_User sudo到哪个用户，默认为 root -k --ask-pass 登录密码，提示输入SSH密码而不是假设基于密钥的验证 </span><br><span class="line">-K --ask-sudo-pass 提示密码使用sudo -s --sudo sudo运行 </span><br><span class="line">-S --su 用 su 命令 </span><br><span class="line">-l --list 显示所支持的所有模块 </span><br><span class="line">-f --forks=NUM 并行任务数。NUM被指定为一个整数,默认是5。 </span><br><span class="line">#ansible testhosts -a "/sbin/reboot" -f 10 重启testhosts组的所有机器，每次重启10台</span><br><span class="line"></span><br><span class="line"> --private-key=PRIVATE_KEY_FILE 私钥路径，使用这个文件来验证连接</span><br><span class="line">-v --verbose 详细信息 </span><br><span class="line">-M MODULE_PATH, --module-path=MODULE_PATH 要执行的模块的路径，默认为/usr/share/ansible/ </span><br><span class="line">--list-hosts 只打印有哪些主机会执行这个 playbook 文件，不是实际执行该 playbook 文件 </span><br><span class="line">-o --one-line 压缩输出，摘要输出.尝试一切都在一行上输出。 </span><br><span class="line">-t Directory, --tree=Directory 将内容保存在该输出目录,结果保存在一个文件中在每台主机上。 </span><br><span class="line">-B 后台运行超时时间 -P 调查后台程序时间 -T Seconds, --timeout=Seconds 时间，单位秒s </span><br><span class="line">-P NUM, --poll=NUM 调查背景工作每隔数秒。需要- b </span><br><span class="line">-c Connection, --connection=Connection 连接类型使用。可能的选项是paramiko(SSH),SSH和地方。当地主要是用于crontab或启动。 </span><br><span class="line">--tags=TAGS 只执行指定标签的任务 例子:ansible-playbook test.yml --tags=copy 只执行标签为copy的那个任务 </span><br><span class="line">--list-hosts 只打印有哪些主机会执行这个 playbook 文件，不是实际执行该 playbook 文件</span><br><span class="line">--list-tasks 列出所有将被执行的任务 </span><br><span class="line">-C, --check 只是测试一下会改变什么内容，不会真正去执行;相反,试图预测一些可能发生的变化 </span><br><span class="line">--syntax-check 执行语法检查的剧本,但不执行它 </span><br><span class="line">-l SUBSET, --limit=SUBSET 进一步限制所选主机/组模式 --limit=192.168.0.15 只对这个ip执行 </span><br><span class="line">--skip-tags=SKIP_TAGS 只运行戏剧和任务不匹配这些值的标签 --skip-tags=copy_start </span><br><span class="line">-e EXTRA_VARS, --extra-vars=EXTRA_VARS 额外的变量设置为键=值或YAML / JSON </span><br><span class="line">#cat update.yml </span><br><span class="line">--- </span><br><span class="line">- hosts: {{ hosts }} </span><br><span class="line">  remote_user: {{ user }} </span><br><span class="line">  .............. </span><br><span class="line">  #ansible-playbook update.yml --extra-vars "hosts=vipers user=admin" 传递{{hosts}}、{{user}}变量,hosts可以是 ip或组名 </span><br><span class="line">-l,--limit 对指定的 主机/组 执行任务 --limit=192.168.0.10，192.168.0.11 或 -l 192.168.0.10，192.168.0.11 只对这个2个ip执行任务</span><br></pre></td></tr></tbody></table></figure><p></p><h3 id="ansible-doc"><a href="#ansible-doc" class="headerlink" title="ansible-doc"></a>ansible-doc</h3><p>[root@VM_0_2_centos ~]# ansible-doc -h<br>Usage: ansible-doc [-l|-F|-s] [options] [-t <plugin type> ] [plugin]</plugin></p><ul><li><p>列出所有已安装的模块<br>[root@VM_0_2_centos ~]# ansible-doc -l</p></li><li><p>查看具体某模块的用法，这里查看command模块<br>[root@VM_0_2_centos ~]# ansible-doc -s command</p></li></ul><h3 id="ansible-galaxy"><a href="#ansible-galaxy" class="headerlink" title="ansible-galaxy"></a>ansible-galaxy</h3><p>ansible-galaxy 指令用于方便的从<a href="https://galaxy.ansible.com/" target="_blank" rel="noopener">https://galaxy.ansible.com/</a> 站点下载第三方扩展模块，我们可以形象的理解其类似于centos下的yum、python下的pip或easy_install 。<br>如下示例：<br>[root@localhost ~]# ansible-galaxy install aeriscloud.docker<br>downloading role ‘docker‘ owned by aeriscloud- downloading role from <a href="https://github.com/AerisCloud/ansible-docker/archive/v1.0.0.tar.gz-" target="_blank" rel="noopener">https://github.com/AerisCloud/ansible-docker/archive/v1.0.0.tar.gz-</a> extracting aeriscloud.docker to /etc/ansible/roles/aeriscloud.docker- aeriscloud.docker was installed successfully</p><p>这个安装了一个aeriscloud.docker组件，前面aeriscloud是galaxy上创建该模块的用户名，后面对应的是其模块。在实际应用中也可以指定txt或yml 文件进行多个组件的下载安装。这部分可以参看<a href="https://link.jianshu.com/?t=http://docs.ansible.com/galaxy.html" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="ansible-lint"><a href="#ansible-lint" class="headerlink" title="ansible-lint"></a>ansible-lint</h3><p>ansible-lint是对playbook的语法进行检查的一个工具。<br>用法:ansible-lint playbook.yml 。</p><h3 id="ansible-playbook"><a href="#ansible-playbook" class="headerlink" title="ansible-playbook"></a>ansible-playbook</h3><p>该指令是使用最多的指令，其通过读取playbook 文件后，执行相应的动作，这个后面会做为一个重点来讲。</p><h3 id="ansible-pull"><a href="#ansible-pull" class="headerlink" title="ansible-pull"></a>ansible-pull</h3><p>该指令使用需要谈到ansible的另一种模式－－－pull 模式，这和我们平常经常用的push模式刚好相反<br>其适用于以下场景：你有数量巨大的机器需要配置，即使使用非常高的线程还是要花费很多时间；你要在一个没有网络连接的机器上运行Anisble，比如在启动之后安装。这部分也会单独做一节来讲。</p><h3 id="ansible-vault"><a href="#ansible-vault" class="headerlink" title="ansible-vault"></a>ansible-vault</h3><p>ansible-vault主要应用于配置文件中含有敏感信息，又不希望他能被人看到，vault可以帮你加密/解密这个配置文件，属高级用法。<br>主要对于playbooks里比如涉及到配置密码或其他变量时，可以通过该指令加密，这样我们通过cat看到的会是一个密码串类的文件，编辑的时候需要输入事先设定的密码才能打开。这种playbook文件在执行时，需要加上 –ask-vault-pass参数，同样需要输入密码后才能正常执行。具体该部分可以参查<a href="https://link.jianshu.com/?t=http://www.ansible.com/blog/2014/02/19/ansible-vault" target="_blank" rel="noopener">官方博客</a>。</p><h2 id="ansible配置文件-ansible-cfg"><a href="#ansible配置文件-ansible-cfg" class="headerlink" title="ansible配置文件 ansible.cfg"></a>ansible配置文件 ansible.cfg</h2><p>查看配置文件设置<br><a href="http://docs.ansible.com/ansible/intro_configuration.html#poll-interval" target="_blank" rel="noopener">http://docs.ansible.com/ansible/intro_configuration.html#poll-interval</a><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">* inventory–这个参数表示资源清单inventory文件配置，资源清单就是一些ansible需要链接管理的主机列表。安装完ansible之后默认所在的inventory列表配置如下：  </span><br><span class="line"></span><br><span class="line">inventory = /etc/ansible/hosts    </span><br><span class="line"></span><br><span class="line">* library–Ansible的操作动作，无论是本地或远程，都使用一小段代码来执行。这小段代码成为模块，这个library参数就是只想存放在Ansible模块的目录。Ansible支持多个目录方式，只要用冒号（：）隔开就可以，同时也会检查当前执行playbook位置下的./library位置。默认的配置如下：</span><br><span class="line"></span><br><span class="line">library = /usr/share/ansible  </span><br><span class="line"></span><br><span class="line">* forks–设置默认情况下Ansible最多能有多少个进程同时工作，默认设置最多5个进程并行处理。具体需要设置多少个，可以根据控制主机的性能和被管理节点的数量来确定。默认参数配置如下： forks=20 你没有优化的优化的情况下执行比较慢</span><br><span class="line"></span><br><span class="line">forks = 5</span><br><span class="line"></span><br><span class="line">* sudo_user–这个设置默认执行命令的用户，在playbook中重新设置这个参数。默认参数配置如下：</span><br><span class="line"></span><br><span class="line">sudo_user = root  </span><br><span class="line"></span><br><span class="line">* remote_port–这个是指定链接被管节点的管理端口，默认22。除非设置了特殊的SSH端口，不然这个参数一般是不需要修改的。默认配置如下：</span><br><span class="line"></span><br><span class="line">remote_port = 22</span><br><span class="line"></span><br><span class="line">* host_key_checking–这个设置是否检查SSH主机的秘钥。可以设置为True或者False。默认配置如下：</span><br><span class="line"></span><br><span class="line">host_key_checking = false  </span><br><span class="line"></span><br><span class="line">* timeout–这是设置SSH链接的超时间隔，单位是秒。默认配置实例如下：</span><br><span class="line"></span><br><span class="line">timeout = 60</span><br><span class="line"></span><br><span class="line">* log_path–Ansible系统默认是不记录日志的，如果想把Ansible系统的输出记录到日志文件中，需要设置log\_path来指定一个存储Ansible日志的文件。配置实例如下：</span><br><span class="line"></span><br><span class="line">log_path = /var/log/ansible.log  </span><br><span class="line">poll_interval 异步执行任务的时候多久检查一次任务装填</span><br><span class="line">poll_interval = 15</span><br><span class="line"></span><br><span class="line">选择远程的工具   默认情况下就是smart(智能)模式  自动选择连接方式</span><br><span class="line">只有当你需要优化执行速度的时候才需要修改这个选项</span><br><span class="line">transport = smart </span><br><span class="line"></span><br><span class="line">module_set_locale  设置本地的环境变量  </span><br><span class="line">inventory      = /etc/ansible/hosts     这个是默认库文件位置,脚本,或者存放可通信主机的目录  </span><br><span class="line">#library        = /usr/share/my_modules/   Ansible默认搜寻模块的位置  </span><br><span class="line">remote_tmp     = $HOME/.ansible/tmp   Ansible 通过远程传输模块到远程主机,然后远程执行,执行后在清理现场.在有些场景下,你也许想使用默认路径希望像更换补丁一样使用  </span><br><span class="line">pattern        = *    如果没有提供“hosts”节点,这是playbook要通信的默认主机组.默认值是对所有主机通信  </span><br><span class="line">forks          = 5    在与主机通信时的默认并行进程数 ，默认是5d  </span><br><span class="line">poll_interval  = 15    当具体的poll interval 没有定义时,多少时间回查一下这些任务的状态, 默认值是5秒  </span><br><span class="line">sudo_user      = root   sudo使用的默认用户 ，默认是root  </span><br><span class="line">#ask_sudo_pass = True   用来控制Ansible playbook 在执行sudo之前是否询问sudo密码.默认为no  </span><br><span class="line">#ask_pass      = True    控制Ansible playbook 是否会自动默认弹出密码  </span><br><span class="line">transport      = smart   通信机制.默认 值为’smart’。如果本地系统支持   ControlPersist技术的话,将会使用(基于OpenSSH)‘ssh’,如果不支持讲使用‘paramiko’.其他传输选项包括‘local’, ‘chroot’,’jail’等等  </span><br><span class="line">#remote_port    = 22    远程SSH端口。 默认是22  </span><br><span class="line">module_lang    = C   模块和系统之间通信的计算机语言，默认是C语言  </span><br><span class="line">gathering = implicit   控制默认facts收集（远程系统变量）. 默认值为’implicit’, 每一次play,facts都会被收集</span><br><span class="line">#roles_path    = /etc/ansible/roles   roles 路径指的是’roles/’下的额外目录,用于playbook搜索Ansible roles</span><br><span class="line">#host_key_checking = False    检查主机密钥</span><br><span class="line">sudo_exe = sudo     如果在其他远程主机上使用另一种方式执sudu操作.可以使用该参数进行更换</span><br><span class="line">#what flags to pass to sudo   传递sudo之外的参数</span><br><span class="line">#sudo_flags = -H</span><br><span class="line"></span><br><span class="line">#SSH timeout    SSH超时时间</span><br><span class="line">timeout = 10</span><br><span class="line">#remote_user = root   使用/usr/bin/ansible-playbook链接的默认用户名，如果不指定，会使用当前登录的用户名</span><br><span class="line">#log_path = /var/log/ansible.log     日志文件存放路径</span><br><span class="line">#module_name = command     ansible命令执行默认的模块</span><br><span class="line">#executable = /bin/sh     在sudo环境下产生一个shell交互接口. 用户只在/bin/bash的或者sudo限制的一些场景中需要修改</span><br><span class="line">#jinja2_extensions = jinja2.ext.do,jinja2.ext.i18n      允许开启Jinja2拓展模块</span><br><span class="line">#private_key_file = /root/.ssh/id_rsa        私钥文件存储位置</span><br><span class="line">ansible_managed = Ansible managed: {file} modified on %Y-%m-%d %H:%M:%S by {uid} on {host}   这个设置可以告知用户,Ansible修改了一个文件,并且手动写入的内容可能已经被覆盖.</span><br><span class="line">#display_skipped_hosts = True     显示任何跳过任务的状态 ，默认是显示</span><br><span class="line">#error_on_undefined_vars = False      如果所引用的变量名称错误的话, 将会导致ansible在执行步骤上失败</span><br><span class="line">#system_warnings = True    允许禁用系统运行ansible相关的潜在问题警告</span><br><span class="line">#deprecation_warnings = True     允许在ansible-playbook输出结果中禁用“不建议使用”警告</span><br><span class="line">#command_warnings = False    当shell和命令行模块被默认模块简化的时,Ansible 将默认发出警告</span><br><span class="line">#nocows = 1    默认ansible可以调用一些cowsay的特性   开启/禁用：0/1</span><br><span class="line">#nocolor = 1  输出带上颜色区别， 开启/关闭：0/1</span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「Ansible简介」「命令」「选项」「参数」
    
    </summary>
    
      <category term="Ansible" scheme="http://yoursite.com/categories/Ansible/"/>
    
    
      <category term="Ansible" scheme="http://yoursite.com/tags/Ansible/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus</title>
    <link href="http://yoursite.com/2019/05/01/Prometheus/01.pro/"/>
    <id>http://yoursite.com/2019/05/01/Prometheus/01.pro/</id>
    <published>2019-05-01T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.753Z</updated>
    
    <content type="html"><![CDATA[<script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script&gt;
        document.querySelectorAll(&#39;.github-emoji&#39;)
          .forEach(el =&gt; {
            if (!el.dataset.src) { return; }
        
      
    
    </summary>
    
      <category term="Prometheus" scheme="http://yoursite.com/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="http://yoursite.com/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Python 的面向对象</title>
    <link href="http://yoursite.com/2019/05/01/Python/02.Oop/01.Python%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/05/01/Python/02.Oop/01.Python的面向对象/</id>
    <published>2019-05-01T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python的面向对象"><a href="#Python的面向对象" class="headerlink" title="Python的面向对象"></a>Python的面向对象</h1><pre><code>- OO- 类的基本实现- 类和对象的成员分析- self</code></pre><h2 id="面向对象概述（ObjectOriented，OO）"><a href="#面向对象概述（ObjectOriented，OO）" class="headerlink" title="面向对象概述（ObjectOriented，OO）"></a>面向对象概述（ObjectOriented，OO）</h2><ul><li><p>OOP思想<br>接触到任意一个任务，首先想到的是任务这个世界的构成，是由模型构成的<br>OO:面向对象<br>OOA：面向对象的分析<br>OOD：面向对象的设计<br>OOI：xxx的实现<br>OOP：xxx的编程<br>OOA->OOD->OOI: 面向对象的实现过程</p></li><li><p>类和对象的概念<br>类：抽象名词，代表一个集合，共性的事物<br>对象：具象的事物，单个个体<br>类跟对象的关系<br>一个具象，代表一类事物的某一个个体<br>一个是抽象，代表的是一大类事物</p></li><li><p>类中的内容，应该具有两个内容<br>表明事物的特征，叫做属性(变量)<br>表明事物功能或动作， 称为成员方法(函数)</p></li></ul><h2 id="类的基本实现"><a href="#类的基本实现" class="headerlink" title="类的基本实现"></a>类的基本实现</h2><ul><li><p>类的命名<br>遵守变量命名的规范<br>大驼峰（由一个或者多个单词构成，每个单词首字母大写，单词跟单词直接相连）<br>尽量避开跟系统命名相似的命名</p></li><li><p>你如何声明一个类<br>class关键字<br>类由属性和方法构成，其他不允许出现<br>成员属性定义可以直接使用变量赋值，如果没有值，许使用None</p></li><li><p>实例化类</p><pre><code>变量 = 类名() #实例化了一个对象</code></pre></li><li><p>访问对象成员</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.成员属性名称  </span><br><span class="line">obj.成员方法</span><br></pre></td></tr></tbody></table></figure></li><li><p>对象的所有成员</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># dict前后各有两个下划线</span><br><span class="line">obj.__dict__</span><br></pre></td></tr></tbody></table></figure></li><li><p>类的所有成员</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># dict前后各有两个下划线</span><br><span class="line">class_name.__dict__</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="类和对象的成员分析"><a href="#类和对象的成员分析" class="headerlink" title="类和对象的成员分析"></a>类和对象的成员分析</h2><ul><li>类和对象都可以存储成员，成员可以归类所有，也可以归对象所有</li><li>类存储成员时使用的是与类关联的一个对象</li><li>独享存储成员是是存储在当前对象中</li><li>对象访问一个成员时，如果对象中没有该成员，尝试访问类中的同名成员， 如果对象中有此成员，一定使用对象中的成员</li><li><p>创建对象的时候，类中的成员不会放入对象当中，而是得到一个空对象，没有成员 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    name = "kobe"</span><br><span class="line">    number = 24</span><br><span class="line"></span><br><span class="line"># A 称为类实例    </span><br><span class="line">print ("A",A.name,id(A.name))</span><br><span class="line">print ("A",A.number,id(A.number))</span><br><span class="line">print("*" * 20)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print ("a",a.name,id(a.name))</span><br><span class="line">print ("a",a.number,id(a.number))</span><br><span class="line"></span><br><span class="line"># 查看所有的属性</span><br><span class="line">print ("A",A.__dict__)</span><br><span class="line">print ("a",a.__dict__)  #{} 空  </span><br><span class="line"></span><br><span class="line"># 在不对对象的实例属性赋值的前提下，类实例的属性和其对象实例的属性指向同一个变量</span><br><span class="line"></span><br><span class="line">A kobe 140589649254976</span><br><span class="line">A 24 9306720</span><br><span class="line">********************</span><br><span class="line">a kobe 140589649254976</span><br><span class="line">a 24 9306720</span><br><span class="line">A {'__module__': '__main__', 'name': 'kobe', 'number': 24, '__dict__': <attribute '__dict__' of 'A' objects>, '__weakref__': <attribute '__weakref__' of 'A' objects>, '__doc__': None}</span><br><span class="line">a {}</span><br></pre></td></tr></tbody></table></figure></li><li><p>通过对象对类中成员重新赋值或者通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">案例:</span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    name = "kobe"</span><br><span class="line">    number = 24</span><br><span class="line">    </span><br><span class="line"># A 称为类实例    </span><br><span class="line">print ("A",A.name,id(A.name))</span><br><span class="line">print ("A",A.number,id(A.number))</span><br><span class="line">print("*" * 20)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print ("a",a.name,id(a.name))</span><br><span class="line">print ("a",a.number,id(a.number))</span><br><span class="line"></span><br><span class="line">## 查看所有的属性</span><br><span class="line">print ("A",A.__dict__)</span><br><span class="line">print ("a",a.__dict__)  #{}   </span><br><span class="line">print("*" * 20)</span><br><span class="line"></span><br><span class="line">#赋值</span><br><span class="line">a.name  =  "Owen"</span><br><span class="line">a.number = 11</span><br><span class="line"></span><br><span class="line">print ("a",a.name,id(a.name))</span><br><span class="line">print ("a",a.number,id(a.number))</span><br><span class="line">print ("a",a.__dict__)</span><br><span class="line"></span><br><span class="line">#通过对象对类中成员重新赋值或者通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员</span><br><span class="line"></span><br><span class="line">A kobe 140589649254976</span><br><span class="line">A 24 9306720</span><br><span class="line">********************</span><br><span class="line">a kobe 140589649254976</span><br><span class="line">a 24 9306720</span><br><span class="line">A {'__module__': '__main__', 'name': 'kobe', 'number': 24, '__dict__': <attribute '__dict__' of 'A' objects>, '__weakref__': <attribute '__weakref__' of 'A' objects>, '__doc__': None}</span><br><span class="line">a {}</span><br><span class="line">********************</span><br><span class="line">a Owen 140589649496696</span><br><span class="line">a 11 9306304</span><br><span class="line">a {'name': 'Owen', 'number': 11}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="self"><a href="#self" class="headerlink" title="self"></a>self</h2><ul><li>self在对象的方法中表示当前对象本身，如果通过对象调用一个方法，那么该对象会自动传入到当前方法的第一个参数中 </li><li><p>self并不是关键字，只是一个用于接受对象的普通参数，理论上可以用任何一个普通变量名代替</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">案例:</span><br><span class="line">class Student():</span><br><span class="line">    name = "dana"</span><br><span class="line">    age = 18</span><br><span class="line">    </span><br><span class="line">    # 注意say的写法，参数有一个self</span><br><span class="line">    def say(self):</span><br><span class="line">        self.age = 200</span><br><span class="line">        print("My age is {0}".format(self.age))</span><br><span class="line">    # 任何一个普通变量名代替self    </span><br><span class="line">    def sayAgain(s):</span><br><span class="line">        print("My age is {0}".format(s.age))</span><br><span class="line">          </span><br><span class="line">yueyue = Student()</span><br><span class="line">yueyue.say()</span><br><span class="line">yueyue.sayAgain()</span><br><span class="line"></span><br><span class="line">My age is 200</span><br><span class="line">My age is 200</span><br></pre></td></tr></tbody></table></figure></li><li><p>方法中有self形参的方法是非绑定类的方法，可以通过对象访问； 没有self的是绑定类的方法，只能通过类访问</p></li><li><p>类方法中需要访问当前类的成员，可以通过 <strong>class</strong>成员名来访问</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Teacher():</span><br><span class="line">    name = "dana"</span><br><span class="line">    age = 19</span><br><span class="line">    </span><br><span class="line">    def say(self):</span><br><span class="line">        self.name = "yaona"</span><br><span class="line">        self.age = 17</span><br><span class="line">        print("My name is {0}".format(self.name))</span><br><span class="line">        # 调用类的成员变量需要用 __class__</span><br><span class="line">        print("My age is {0}".format(__class__.age))</span><br><span class="line">    def sayAgain():</span><br><span class="line">        print(__class__.name)</span><br><span class="line">        print(__class__.age )</span><br><span class="line">        print("Hello, nice to see you again")</span><br><span class="line">        </span><br><span class="line">t = Teacher()</span><br><span class="line">t.say()</span><br><span class="line"></span><br><span class="line"># 调用绑定类函数使用类名</span><br><span class="line">Teacher.sayAgain()</span><br><span class="line"></span><br><span class="line"># 如果类方法中需要访问当前类的成员，可以通过 __class__成员名来访问</span><br><span class="line"></span><br><span class="line">My name is yaona</span><br><span class="line">My age is 19</span><br><span class="line">dana</span><br><span class="line">19</span><br><span class="line">Hello, nice to see you again</span><br></pre></td></tr></tbody></table></figure></li><li><p>关于self的案例</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 案例:</span><br><span class="line">class A():</span><br><span class="line">    name = " liuying"</span><br><span class="line">    age = 18</span><br><span class="line">    </span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = "aaaa"</span><br><span class="line">        self.age = 200</span><br><span class="line">        </span><br><span class="line">    def say(self):</span><br><span class="line">        print(self.name)</span><br><span class="line">        print(self.age)</span><br><span class="line">        </span><br><span class="line">class B():</span><br><span class="line">    name = "bbbb"</span><br><span class="line">    age = 90</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"># 此时，系统会默认把对象a作为第一个参数传入函数</span><br><span class="line">a.say()</span><br><span class="line">   </span><br><span class="line">A.say()    #错误，类实例不会自动传入第一个参数，需要手动传入一个</span><br><span class="line"># 此时，self被a替换</span><br><span class="line">A.say(a)</span><br><span class="line"># 同样可以把A作为参数传入</span><br><span class="line">A.say(A)</span><br><span class="line"></span><br><span class="line"># 此时，传入的是类实例B，因为B具有name和age属性，所以不会报错</span><br><span class="line">A.say(B)</span><br><span class="line"></span><br><span class="line"># 以上代码，利用了鸭子模型</span><br><span class="line"></span><br><span class="line">aaaa</span><br><span class="line">200</span><br><span class="line">aaaa</span><br><span class="line">200</span><br><span class="line">liuying</span><br><span class="line">18</span><br><span class="line">bbbb</span><br><span class="line">90</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><pre><code>- 封装- 继承- 多态、Mixin- 类的相关函数- 类的成员描述符- 类的内置属性- 魔法函数- 类和对象的三种方法- 抽象类- 自定义类</code></pre><ul><li>面向对象的三大特性：封装、继承、多态</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li>将属性和方法封装到一个抽象的类中</li><li><p>封装的三个级别：<br>公开，public<br>受保护的，protected<br>私有的，private<br>public，private，protected不是关键字</p></li><li><p>判别对象的位置<br>对象内部<br>对象外部<br>子类中</p></li><li><p><a href="http://blog.csdn.net/handsomekang/article/details/40303207" target="_blank" rel="noopener">python中下划线使用</a></p></li><li><p>私有<br>私有成员是最高级别的封装，只能在当前类或对象中访问<br>在成员前面添加两个两个下划线即可: __age<br>Python的私有不是真私有，是一种成为name mangling的改名策略<br>可以使用:对象._classname_attributename访问</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 案例:</span><br><span class="line"></span><br><span class="line"># __age是私有变量,不能直接访问。</span><br><span class="line">print(p.__age)  #注意报错信息</span><br><span class="line">        </span><br><span class="line"># name mangling技术     </span><br><span class="line">print(Person.__dict__)</span><br><span class="line">p._Person__age = 19</span><br><span class="line">print(p._Person__age)</span><br><span class="line">        </span><br><span class="line">{'__module__': '__main__', 'name': 'liuying', '_Person__age': 18, '__dict__': <attribute '__dict__' of 'Person' objects>, '__weakref__': <attribute '__weakref__' of 'Person' objects>, '__doc__': None}</span><br><span class="line">19</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>受保护的封装  protected<br>受保护的封装是将对象成员进行一定级别的封装，然后，在类中或者子类中都可以进行访问，但是在外部不可以<br>封装方法： 在成员名称前添加一个下划线即可<br>name mangling的改名策略<br>可以使用:对象._classname_attributename访问</p></li><li><p>公开的，公共的 public<br>公共的封装实际对成员没有任何操作，任何地方都可以访问  </p></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>继承就是一个类可以获得另外一个类中的成员属性和成员方法</li><li><p>作用： 减少代码，增加代码的复用功能， 同时可以设置类与类直接的关系</p></li><li><p>继承与被继承的概念：<br>被继承的类叫父类，也叫基类，也叫超类<br>用于继承的类，叫子类，也叫派生类<br>继承与被继承一定存在一个 is-a 关系</p></li><li><p>继承的语法:</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#父类写在括号内</span><br><span class="line">class Teacher(Person):</span><br></pre></td></tr></tbody></table></figure></li><li><p>继承的特征<br>所有的类都继承自object类，即所有的类都是object类的子类<br>子类一旦继承父类，则可以使用父类中除私有成员外的所有内容<br>子类继承父类后并没有将父类成员完全赋值到子类中，而是通过引用关系访问调用<br>子类中可以定义独有的成员属性和方法<br>子类中定义的成员和父类成员如果相同，则优先使用子类成员<br>子类如果想扩充父类的方法，可以在定义新方法的同时访问父类成员来进行代码重用</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[父类名.父类成员]的格式来调用父类成员</span><br><span class="line">super().父类成员的格式来调用</span><br></pre></td></tr></tbody></table></figure></li><li><p>子类扩充父类功能的案例</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 人由工作的函数， 老师也由工作的函数，但老师的工作需要讲课</span><br><span class="line">class Person():</span><br><span class="line">    name = "NoName"</span><br><span class="line">    age = 18</span><br><span class="line">    __score = 0 # 考试成绩是秘密，只要自己知道</span><br><span class="line">    _petname = "sec" #小名，是保护的，子类可以用，但不能公用</span><br><span class="line">    def sleep(self):</span><br><span class="line">        print("Sleeping ... ...")</span><br><span class="line">    def work(self):</span><br><span class="line">        print("make some money")</span><br><span class="line">        </span><br><span class="line">#父类写在括号内</span><br><span class="line">class Teacher(Person):</span><br><span class="line">    teacher_id = "9527"</span><br><span class="line">    name = "DaNa"</span><br><span class="line">    def make_test(self):</span><br><span class="line">        print("attention")</span><br><span class="line">        </span><br><span class="line">    def work(self):</span><br><span class="line">        # 扩充父类的功能只需要调用父类相应的函数</span><br><span class="line">        #Person.work(self)</span><br><span class="line">        # 扩充父类的另一种方法</span><br><span class="line">        # super代表得到父类</span><br><span class="line">        super().work()</span><br><span class="line">        self.make_test()</span><br><span class="line">        </span><br><span class="line">t = Teacher()</span><br><span class="line">t.work()</span><br><span class="line"></span><br><span class="line">make some money</span><br><span class="line">attention</span><br></pre></td></tr></tbody></table></figure></li><li><p>继承变量函数的查找顺序问题<br>优先查找自己的变量<br>没有则查找父类<br>构造函数如果本类中没有定义，则自动查找调用父类构造函数<br>如果本类有定义，则不在继续向上查找</p></li><li><p>构造函数<br>是一类特殊的函数，在类进行实例化之前进行调用</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line">class Dog():</span><br><span class="line"># __init__就是构造函数</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print("I am init in dog")</span><br><span class="line"></span><br><span class="line"># 实例话的时候，括号内的参数需要跟构造函数参数匹配</span><br><span class="line">kaka = Dog()</span><br><span class="line">    </span><br><span class="line">I am init in dog</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>构造函数查找顺序<br>如果定义了构造函数，则实例化时使用构造函数，不查找父类构造函数<br>如果没定义，则自动查找父类构造函数<br>如果子类没定义，父类的构造函数带参数，则构造对象时的参数应该按父类参数构造 </p></li><li><p>super<br>super不是关键字， 而是一个类<br>super的作用是获取MRO（MethodResolustionOrder）列表中的第一个类<br>super于父类直接没任何实质性关系，但通过super可以调用到父类<br>super使用的两个方法,参见在构造函数中调用父类的构造函数</p></li><li><p>单继承和多继承<br>单继承：每个类只能继承一个类<br>多继承，每个类允许继承多个类</p></li><li><p>单继承和多继承的优缺点<br>单继承：<br>优点：传承有序逻辑清晰语法简单隐患少呀<br>缺点：功能不能无限扩展，只能在当前唯一的继承链中扩展<br>多继承：<br>优点：类的功能扩展方便<br>缺点：继承关系混乱</p></li><li><p>菱形继承/钻石继承问题<br>多个子类继承自同一个父类，这些子类由被同一个类继承，于是继承关系图形成一个菱形图谱<br><a href="https://www.cnblogs.com/whatisfantasy/p/6046991.html" target="_blank" rel="noopener">MRO</a><br>关于多继承的MRO<br>MRO就是多继承中，用于保存继承顺序的一个列表<br>python本身采用C3算法来多多继承的菱形继承进行计算的结果</p></li><li><p>MRO列表的计算原则：<br>子类永远在父类前面<br>如果多个父类，则根据继承语法中括号内类的书写顺序存放<br>如果多个类继承了同一个父类，孙子类中只会选取继承语法括号中第一个父类的父类</p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">案例：扩展构造函数</span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print("A")</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        print("B")</span><br><span class="line">        print(name)</span><br><span class="line">        </span><br><span class="line">class C(B):</span><br><span class="line">    # c中想扩展B的构造函数，</span><br><span class="line">    # 即调用B的构造函数后在添加一些功能</span><br><span class="line">    # 由两种方法实现</span><br><span class="line">    </span><br><span class="line">    '''</span><br><span class="line">    # 第一种是通过父类名调用</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        # 首先调用父类构造函数</span><br><span class="line">        B.__init__(self, name)</span><br><span class="line">        # 其次，再增加自己的功能</span><br><span class="line">        print("这是C中附加的功能")</span><br><span class="line">    '''  </span><br><span class="line">        </span><br><span class="line">    # 第二种，使用super调用</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        # 首先调用父类构造函数</span><br><span class="line">        super(C, self).__init__(name)</span><br><span class="line">        # 其次，再增加自己的功能</span><br><span class="line">        print("这是C中附加的功能")</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"># 此时，首先查找C的构造函数</span><br><span class="line"># 如果没有，则向上按照MRO顺序查找父类的构造函数，知道找到为止</span><br><span class="line"># 此时，会出现参数结构不对应错误</span><br><span class="line">c = C("我是C")</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B</span><br><span class="line">我是C</span><br><span class="line">这是C中附加的功能</span><br></pre></td></tr></tbody></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>不同的子类对象调用相同的父类方法，产生不同的执行结果</li><li>以继承和重写父类方法为前提</li><li>多态性：同一种调用方式，产生不同的执行效果</li><li><a href="https://www.cnblogs.com/luchuangao/p/6739557.html" target="_blank" rel="noopener">多态和多态性</a></li><li>Mixin设计模式<br>主要采用多继承方式对类的功能进行扩展<br><a href="https://www.zhihu.com/question/20778853" target="_blank" rel="noopener">Mixin概念</a><br><a href="http://blog.csdn.net/robinjwong/article/details/48375833" target="_blank" rel="noopener">MRO and Mixin</a><br><a href="https://www.cnblogs.com/xybaby/p/6484262.html" target="_blank" rel="noopener">Mixin模式</a><br><a href="http://runforever.github.io/2014-07-19/2014-07-19-python-mixin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">Mixin MRO</a><br><a href="http://xiaocong.github.io/blog/2012/06/13/python-mixin-and-mro/" target="_blank" rel="noopener">MRO</a>    </li><li>我们使用多继承语法来实现Minxin</li><li>使用Mixin实现多继承的时候非常小心<br>首先他必须表示某一单一功能，而不是某个物品<br>职责必须单一，如果由多个功能，则写多个Mixin<br>Mixin不能依赖于子类的实现<br>子类及时没有继承这个Mixin类， 也能照样工作，只是缺少了某个功能</li><li>优点<br>使用Mixin可以在不对类进行任何修改的情况下，扩充功能<br>可以方便的组织和维护不同功能组件的划分<br>可以根据需要任意调整功能类的组合<br>可以避免创建很多新的类，导致类的继承混乱</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># Mixin案例</span><br><span class="line"></span><br><span class="line">class Person():</span><br><span class="line">                name = "liuying"</span><br><span class="line">                age = 18</span><br><span class="line"></span><br><span class="line">                def eat(self):</span><br><span class="line">                    print("EAT.......")</span><br><span class="line">                    </span><br><span class="line">                def drink(self):</span><br><span class="line">                    print("DRINK......")</span><br><span class="line">                    </span><br><span class="line">                def sleep(self):</span><br><span class="line">                    print("SLEEP.....")</span><br><span class="line">                </span><br><span class="line">class Teacher(Person):</span><br><span class="line">                def work(self):</span><br><span class="line">                    print("Work")</span><br><span class="line"></span><br><span class="line">class Student(Person):</span><br><span class="line">                def study(self):</span><br><span class="line">                    print("Study")</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">class Tutor(Teacher, Student):</span><br><span class="line">                pass</span><br><span class="line"></span><br><span class="line">t = Tutor()</span><br><span class="line">             </span><br><span class="line">print(Tutor.__mro__)</span><br><span class="line">print(t.__dict__)</span><br><span class="line">print(Tutor.__dict__)</span><br><span class="line"></span><br><span class="line">print("*"*20)</span><br><span class="line">class TeacherMixin():</span><br><span class="line">                def work(self):</span><br><span class="line">                    print("Work")</span><br><span class="line"></span><br><span class="line">class StudentMixin():</span><br><span class="line">                def study(self):</span><br><span class="line">                    print("Study")</span><br><span class="line">                    </span><br><span class="line">class TutorM(Person, TeacherMixin, StudentMixin):</span><br><span class="line">                pass</span><br><span class="line"></span><br><span class="line">tt = TutorM()</span><br><span class="line">print(TutorM.__mro__)</span><br><span class="line">print(tt.__dict__)</span><br><span class="line">print(TutorM.__dict__)</span><br></pre></td></tr></tbody></table></figure><h2 id="类相关函数"><a href="#类相关函数" class="headerlink" title="类相关函数"></a>类相关函数</h2><ul><li>issubclass:检测一个类是否是另一个类的子类</li><li>isinstance:检测一个对象是否是一个类的实例</li><li>hasattr:检测一个对象是否由成员xxx</li><li>getattr: get attribute</li><li>setattr: set attribute</li><li>delattr: delete attribute</li><li>dir: 获取对象的成员列表</li></ul><h2 id="类的成员描述符（属性）"><a href="#类的成员描述符（属性）" class="headerlink" title="类的成员描述符（属性）"></a>类的成员描述符（属性）</h2><ul><li><p>类的成员描述符是为了在类中对类的成员属性进行相关操作而创建的一种方式<br>get： 获取属性的操作<br>set：修改或者添加属性操作<br>delete： 删除属性的操作</p></li><li><p>如果想使用类的成员描述符，大概有三种方法<br>使用类实现描述器<br>使用属性修饰符<br>使用property函数:property(fget, fset, fdel, doc) </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># peroperty案例</span><br><span class="line"></span><br><span class="line"># 定义一个Person类，具有name，age属性</span><br><span class="line"># 对于任意输入的姓名，我们希望都用大写方式保存</span><br><span class="line"># 年龄，我们希望内部统一用整数保存</span><br><span class="line"># x = property(fget, fset, fdel, doc)</span><br><span class="line">class Person():</span><br><span class="line"></span><br><span class="line">    # 函数的名称可以任意</span><br><span class="line">    def fget(self):</span><br><span class="line">        return self._name * 2</span><br><span class="line">    </span><br><span class="line">    def fset(self, name):</span><br><span class="line">        # 所有输入的姓名以大写形式保存</span><br><span class="line">        self._name = name.upper()</span><br><span class="line">        </span><br><span class="line">    def fdel(self):</span><br><span class="line">        self._name = "NoName"</span><br><span class="line">    </span><br><span class="line">    name2 = property(fget, fset, fdel, "对name进行下下操作啦")</span><br></pre></td></tr></tbody></table></figure></li><li><p>无论哪种修饰符都是为了对成员属性进行相应的控制<br>类的方式： 适合多个类中的多个属性共用用一个描述符<br>property：使用当前类中使用，可以控制一个类中多个属性<br>属性修饰符： 使用于当前类中使用，控制一个类中的一个属性</p></li></ul><h2 id="类的内置属性"><a href="#类的内置属性" class="headerlink" title="类的内置属性"></a>类的内置属性</h2><ul><li><p><strong>dict</strong><br>以字典的方式显示类的成员组成</p></li><li><p><strong>doc</strong>:<br>获取类的文档信息</p></li><li><p><strong>name</strong><br>获取类的名称，如果在模块中使用，获取模块的名称</p></li><li><p><strong>bases</strong><br>获取某个类的所有父类，以元组的方式显示</p></li></ul><h2 id="类的常用魔术方法"><a href="#类的常用魔术方法" class="headerlink" title="类的常用魔术方法"></a>类的常用魔术方法</h2><ul><li>魔术方法就是不需要人为调用的方法，基本是在特定的时刻自动触发</li><li>魔术方法的统一的特征，方法名被前后各两个下滑线包裹</li><li>操作类<br><code>__init__</code>: 构造函数<br><code>__new__</code>: 对象实例化方法，此函数较特殊，一般不需要使用<br><code>__call__</code>: 对象当函数使用的时候触发<br><code>__str__</code>: 当对象被当做字符串使用的时候调用<br><code>__repr__</code>: 返回字符串 </li></ul><ul><li>描述符相关<br><code>__set__</code><br><code>__get__</code><br><code>__delete__</code></li></ul><ul><li><p>属性操作相关<br><code>__getattr__</code>: 访问一个不存在的属性时触发<br><code>__setattr__</code>: 对成员属性进行设置的时候触发<br>参数：<br>self用来获取当前对象<br>被设置的属性名称，以字符串形式出现<br>需要对属性名称设置的值<br>作用：进行属性设置的时候进行验证或者修改<br>注意： 在该方法中不能对属性直接进行赋值操作，否则死循环 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># __setattr__案例</span><br><span class="line"></span><br><span class="line">class Person():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    def __setattr__(self, name, value):</span><br><span class="line">        print("设置属性： {0}".format(name))</span><br><span class="line">        # 下面语句会导致问题，死循环</span><br><span class="line">        #self.name = value</span><br><span class="line">        </span><br><span class="line">        # 此种情况，为了避免死循环，规定统一调用父类魔法函数</span><br><span class="line">        super().__setattr__(name, value)</span><br><span class="line">        </span><br><span class="line">p = Person()</span><br><span class="line">print(p.__dict__)</span><br><span class="line">p.age = 18</span><br></pre></td></tr></tbody></table></figure></li><li><p>运算分类相关魔术方法<br><code>__gt__</code>: 进行大于判断的时候触发的函数<br>参数：<br>self<br>第二个参数是第二个对象<br>返回值:可以是任意值，推荐返回布尔值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># __gt__</span><br><span class="line"></span><br><span class="line">class Student():</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self._name = name</span><br><span class="line">    </span><br><span class="line">    def __gt__(self, obj):</span><br><span class="line">        print("哈哈， {0} 会比 {1} 大吗？".format(self, obj))</span><br><span class="line">        return self._name > obj._name</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">stu1 = Student("one")</span><br><span class="line">stu2 = Student("two")</span><br><span class="line"></span><br><span class="line">print(stu1 > stu2)</span><br><span class="line"></span><br><span class="line">哈哈， <__main__.Student object at 0x7f4aac6b3b00> 会比 <__main__.Student object at 0x7f4aac6b3ac8> 大吗？</span><br><span class="line">False</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="类和对象的三种方法"><a href="#类和对象的三种方法" class="headerlink" title="类和对象的三种方法"></a>类和对象的三种方法</h2><ul><li><p>实例方法<br>需要实例化对象才能使用的方法，使用过程中可能需要截止对象的其他对象的方法完成</p></li><li><p>静态方法<br>不需要实例化，通过类直接访问</p></li><li><p>类方法<br>不需要实例化</p></li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 三种方法的案例</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    # 实例方法</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(self)</span><br><span class="line">        print("Eating.....")</span><br><span class="line">    </span><br><span class="line">    #类方法</span><br><span class="line">    # 类方法的第一个参数，一般命名为cls，区别于self</span><br><span class="line">    @classmethod</span><br><span class="line">    def play(cls):</span><br><span class="line">        print(cls)</span><br><span class="line">        print("Playing.....")</span><br><span class="line">        </span><br><span class="line">    # 静态方法</span><br><span class="line">    # 不需要用第一个参数表示自身或者类</span><br><span class="line">    @staticmethod</span><br><span class="line">    def say():</span><br><span class="line">        print("Saying....")</span><br><span class="line">        </span><br><span class="line">yueyue = Person()</span><br><span class="line"></span><br><span class="line"># 实例方法</span><br><span class="line">yueyue.eat()</span><br><span class="line"># 类方法</span><br><span class="line">Person.play()</span><br><span class="line">yueyue.play()</span><br><span class="line">#静态方法</span><br><span class="line">Person.say()</span><br><span class="line">yueyue.say()</span><br></pre></td></tr></tbody></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>抽象方法：没有具体实现内容的方法成为抽象方法</li><li>抽象方法的主要意义是规范了子类的行为和接口</li><li><p>抽象类的使用需要借助abc模块</p><pre><code>import abc</code></pre></li><li><p>抽象类：包含抽象方法的类叫抽象类，通常成为ABC类</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 抽象类的实现</span><br><span class="line"></span><br><span class="line">import abc</span><br><span class="line"></span><br><span class="line">#声明一个类并且指定当前类的元类</span><br><span class="line">class Human(metaclass=abc.ABCMeta):</span><br><span class="line"></span><br><span class="line">    # 定义一个抽象的方法</span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def smoking(self):</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    # 定义类抽象方法</span><br><span class="line">    @abc.abstractclassmethod</span><br><span class="line">    def drink():</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    # 定义静态抽象方法</span><br><span class="line">    @abc.abstractstaticmethod</span><br><span class="line">    def play():</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    # 定义一个具体方法</span><br><span class="line">    def sleep(self):</span><br><span class="line">        print("Sleeping.......")</span><br></pre></td></tr></tbody></table></figure></li><li><p>抽象类的使用<br>抽象类可以包含抽象方法，也可以包含具体方法<br>抽象类中可以有方法也可以有属性<br>抽象类不允许直接实例化<br>必须继承才可以使用，且继承的子类必须实现所有继承来的抽象方法<br>假定子类没有是现实所有继承的抽象方法，则子类也不能实例化<br>抽象类的主要作用是设定类的标准，以便于开发的时候具有统一的规范</p></li></ul><h2 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 函数名可以当变量使用</span><br><span class="line"></span><br><span class="line">def sayHello(name):</span><br><span class="line">    print("{0}你好 ".format(name))</span><br><span class="line">    </span><br><span class="line">sayHello("月月")</span><br><span class="line"></span><br><span class="line">B = sayHello</span><br><span class="line">B("yueyue")</span><br></pre></td></tr></tbody></table></figure><ul><li>类其实是一个类定义和各种方法的自由组合</li><li><p>可以定义类和函数，然后自己通过类直接赋值</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 组装类 1 </span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def say(self):</span><br><span class="line">    print("Saying... ...")</span><br><span class="line">    </span><br><span class="line">#等同于    </span><br><span class="line">class B():</span><br><span class="line">    def say(self):</span><br><span class="line">        print("Saying......")</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(9)</span><br><span class="line">A.say = say</span><br><span class="line">a = A()</span><br><span class="line">a.say()</span><br></pre></td></tr></tbody></table></figure></li><li><p>可以借助于MethodType实现</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 组装类例子 2</span><br><span class="line"></span><br><span class="line"># 自己组装一个类</span><br><span class="line">from types import MethodType</span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def say(self):</span><br><span class="line">    print("Saying... ...")</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">a = A()</span><br><span class="line"># 通过MethodType 把say组装到A  </span><br><span class="line">a.say = MethodType(say, A)</span><br><span class="line">a.say()</span><br></pre></td></tr></tbody></table></figure></li><li><p>借助于type实现</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 利用type造一个类</span><br><span class="line"></span><br><span class="line"># 先定义类应该具有的成员函数</span><br><span class="line">def say(self):</span><br><span class="line">    print("Saying.....")</span><br><span class="line">    </span><br><span class="line">def talk(self):</span><br><span class="line">    print("Talking .....")</span><br><span class="line">    </span><br><span class="line">#用type来创建一个类</span><br><span class="line">A = type("AName", (object, ), {"class_say":say, "class_talk":talk})</span><br><span class="line"></span><br><span class="line"># 然后可以像正常访问一样使用类</span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line">a.class_say()</span><br><span class="line">a.class_talk()</span><br></pre></td></tr></tbody></table></figure></li><li><p>利用元类实现- MetaClass<br>元类是类<br>被用来创造别的类</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 元类演示</span><br><span class="line"># 元类写法是固定的，必须继承自type</span><br><span class="line"># 元类一般命名以MetaClass结尾</span><br><span class="line"></span><br><span class="line">class TulingMetaClass(type):</span><br><span class="line">    # 注意以下写法</span><br><span class="line">    def __new__(cls, name, bases, attrs):</span><br><span class="line">        #自己的业务处理</span><br><span class="line">        print("哈哈，我是元类呀")</span><br><span class="line">        attrs['id'] = '000000'</span><br><span class="line">        attrs['addr'] = "北京海淀区公主坟西翠路12号"</span><br><span class="line">        return type.__new__(cls, name, bases, attrs)</span><br><span class="line">    </span><br><span class="line"># 元类定义完就可以使用，使用注意写法</span><br><span class="line">class Teacher(object, metaclass=TulingMetaClass):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">t = Teacher()</span><br><span class="line"></span><br><span class="line">t.id</span><br></pre></td></tr></tbody></table></figure></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「面向对象」「面向对象编程」
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 的流程控制</title>
    <link href="http://yoursite.com/2019/04/27/Python/01.Basic-level/02.Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/27/Python/01.Basic-level/02.Python的流程控制/</id>
    <published>2019-04-27T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.767Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ul><li>分支结构</li><li>循环结构</li></ul><h2 id="分支结构-选择结构"><a href="#分支结构-选择结构" class="headerlink" title="分支结构/选择结构"></a>分支结构/选择结构</h2><ul><li>单项分支: <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if 条件表达式：   </span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>双向分支      </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 条件表达式:</span><br><span class="line">    ...</span><br><span class="line">else:</span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure></li><li><p>多项分支</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if 条件表达式：</span><br><span class="line">    ...</span><br><span class="line">elif 条件表达式:</span><br><span class="line">    ... </span><br><span class="line">elif 条件表达式：</span><br><span class="line">    ...</span><br><span class="line">else:</span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure></li><li><p>巢状分支<br>巢状分支就是多个其他if…else分支的嵌套组合  </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if x < 5:</span><br><span class="line">    print('x真的小于5哦')</span><br><span class="line">    if y < 6:</span><br><span class="line">        print('如果y < 6，我会被输出')</span><br><span class="line">    elif y > 6:</span><br><span class="line">        print('如果上y大于6，我会被输出')</span><br><span class="line">elif x > 5:</span><br><span class="line">    print('x大于5')</span><br></pre></td></tr></tbody></table></figure></li></ul><p>注意：：在python中并没有switch…case分支。后期可以使用字典和函数的组合来代替。</p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><ul><li><p>while …: …  </p></li><li><p>while …: …     else: …   </p></li><li><p>while True: …</p></li></ul><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul><li>for … in 循环  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 格式1:  </span><br><span class="line">for 变量 in 序列:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"># 格式2:</span><br><span class="line">for 变量1,变量2.. in 多层序列：</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"># 格式3：</span><br><span class="line">for 变量 in 序列：:</span><br><span class="line">    ...</span><br><span class="line">else:</span><br><span class="line">    ...</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="其他流程控制语句"><a href="#其他流程控制语句" class="headerlink" title="其他流程控制语句"></a>其他流程控制语句</h3><ul><li><p>break 破坏，结束，打破<br>作用：结束程序循环，一旦程序执行了break语句，那么当前break所在的循环就会被终止  </p></li><li><p>continue 继续<br>作用：结束本次循环，开始下一次的循环，他不会终止整个循环，仅对于循环中的某次循环有效  </p></li><li><p>pass 通过，忽略<br>作用：在程序结构中有时不需用写任何python内容，但是如果没有内容，语言结构会出现语法错误！pass可以作为语法占位符使用，pass语句没有任何意义，也不会做任何操作</p></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><h3 id="最基本的函数结构"><a href="#最基本的函数结构" class="headerlink" title="最基本的函数结构"></a>最基本的函数结构</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def 函数名()：</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">调用函数： 函数名()</span><br></pre></td></tr></tbody></table></figure><h3 id="具有参数的函数结构"><a href="#具有参数的函数结构" class="headerlink" title="具有参数的函数结构"></a>具有参数的函数结构</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def 函数名(参数名，参数名...):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">调用函数: 函数名(值,值...)</span><br></pre></td></tr></tbody></table></figure><p>声明函数的()中的参数称之为形参，形参表示形式上的参数<br>调用函数的()中的参数称之为实参，实参表示真实的值<br>注意:实参传递值给形参的过程，本质上就是普通的变量赋值  </p><h3 id="具有默认值参数的函数"><a href="#具有默认值参数的函数" class="headerlink" title="具有默认值参数的函数"></a>具有默认值参数的函数</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def 函数名(形参名 = 默认值,形参名 = 默认值...):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">调用函数1：函数名()</span><br><span class="line">调用函数2:函数名(实参,实参...)</span><br></pre></td></tr></tbody></table></figure><h3 id="函数文档"><a href="#函数文档" class="headerlink" title="函数文档"></a>函数文档</h3><ul><li><p>查看函数文档：<br>使用help(函数名)，可以查看函数文档信息，查看信息时信息会换行<br>使用函数名.<strong>doc</strong>的方式查看，查看信息时信息不会换行，会显示\n  </p></li><li><p>自定义函数文档：<br>在函数内部开始的第一行使用字符串定义文字内容即可</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def 函数名()：</span><br><span class="line"></span><br><span class="line">    '此处书写函数文档信息，单引号中使用\n换行'</span><br><span class="line"></span><br><span class="line">    函数中的其他代码...</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">def 函数名():</span><br><span class="line">    '''</span><br><span class="line">    此处书写函数文档信息</span><br><span class="line">    此处书写函数文档信息</span><br><span class="line">    '''</span><br><span class="line"></span><br><span class="line">    函数中的其他代码...</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><ul><li><p>lambda不是一种函数结构，只是一种表达式而且不需要函数名。（匿名函数）<br>格式：</p><p>  变量 = lambda 形参,形参…： 功能代码</p></li><li><p>案例：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#传入两个参数返回这两个数的乘积  </span><br><span class="line">lambda x,y :x*y </span><br><span class="line"></span><br><span class="line">#根据条件表达式的真假返回值1还是值2  </span><br><span class="line">lambda x： 值1  if 条件表达式 else 值2</span><br></pre></td></tr></tbody></table></figure></li><li><p>优点：<br>lambda表达式书写简单，不用def关键字，可惜要用lambda<br>lambda表达式不需要函数名，省得命名头疼<br>看起来比较装逼！  </p></li><li><p>缺点：<br>lambda表达式功能受限，无法使用循环以及部分流程控制相关语句<br>lambda表达式不适合较为复杂的程序。  </p></li></ul><h3 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h3><ul><li>收集参数1 (专用于收集非关键字参数)<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 「*」 形参格式的收集参数会收集到调用函数时传入的所有没有关键字的形参  </span><br><span class="line">def 函数名(*形参名)：</span><br><span class="line">    ...    </span><br><span class="line"></span><br><span class="line">调用函数： 函数名(实参,实参....)</span><br></pre></td></tr></tbody></table></figure></li></ul><p>注意:<br>1) 收集参数收集到的最终数据是由所有非关键字实参组成的元组。<br>2) 收集参数和普通的参数（关键字参数）可以共存</p><ul><li>收集参数2 (专门用于收集关键字参数)<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#「**」 形参格式会收集调用函数时传入函数的所有关键字参数  </span><br><span class="line">def 函数名(**args):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">调用函数：函数名(形参名 = 值,形参名=值...)</span><br></pre></td></tr></tbody></table></figure></li></ul><p>-注意:<br>1) 收集的所有关键字参数最终组成的数据为字典类型<br>2) 关键字参数收集的方式可以和普通形参共存，但是必须在最后  </p><ul><li>注意：<br>普通形参，非关键字收集形参和关键字收集形参具有顺序关系<br>普通形参放最前面<br>非关键字形参放中间<br>关键字形参放最后<br>所有收集参数只能够收集没有形参接受的实参 </li></ul><h2 id="函数的变量作用域"><a href="#函数的变量作用域" class="headerlink" title="函数的变量作用域"></a>函数的变量作用域</h2><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><ul><li>全局变量: 在函数外部声明的变量就是全局变量   </li><li>局部变量: 在函数内部声明的变量就是局部变量  </li></ul><h3 id="局部变量和全局变量的作用范围"><a href="#局部变量和全局变量的作用范围" class="headerlink" title="局部变量和全局变量的作用范围"></a>局部变量和全局变量的作用范围</h3><ul><li>全局变量在全局范围内可以使用  </li><li>全局变量在局部范围内可以使用(访问)  </li><li>局部变量在局部范围内可以使用  </li><li>局部变量在全局范围内无法正常使用  </li></ul><h3 id="global-关键字"><a href="#global-关键字" class="headerlink" title="global 关键字"></a>global 关键字</h3><ul><li>global 关键字的作用是提升局部变量为全局变量<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def 函数名():</span><br><span class="line">...</span><br><span class="line">    #提升局部变量为全局变量</span><br><span class="line">    global 局部变量</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h3><ul><li><p>在函数内部声明的函数就是内部函数  </p></li><li><p>特征:<br>内部函数在函数内部可以访问<br>内部函数的调用必须在定义内部函数之后<br>内部函数不可以在函数外部调用<br>本质上内部函数等同于内部变量  </p></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li><p>闭包<br>将函数内部的局部变量或者内部函数,弄到函数外,并且可以正常使用的特殊方法.突破了局部作用域的限制!<br>注意:闭包少用!</p></li><li><p>闭包格式：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def 外层函数()：</span><br><span class="line">局部变量</span><br><span class="line">局部变量</span><br><span class="line"></span><br><span class="line">   def 内部函数()：</span><br><span class="line">pass</span><br><span class="line">return (局部变量，局部变量...内部函数,内部函数...)</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="nonlocal关键字"><a href="#nonlocal关键字" class="headerlink" title="nonlocal关键字"></a>nonlocal关键字</h3><ul><li>声明当前变量不是当前函数内部的变量，他有可能是当前函数的外部变量（不是全局变量）<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def 外部函数()</span><br><span class="line"></span><br><span class="line">    局部变量</span><br><span class="line"></span><br><span class="line">    def 内部函数（）:</span><br><span class="line"></span><br><span class="line">        nonlocal 变量名#声明当前变量不是内部函数中的变量</span><br><span class="line"></span><br><span class="line">        其他代码...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 代码</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><ul><li>在函数中调用当前函数本身的函数就是递归函数。<br>示例：<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def recursion(n):</span><br><span class="line">    #输出当前的n的值</span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line">    #判断n的值是否>0,决定下一步操作</span><br><span class="line">    if n>0:        #n>0 在此调用当前函数digui，将n - 1放进去</span><br><span class="line">        recursion(n-1)</span><br><span class="line">    else:</span><br><span class="line">        #n>0 为False 输出分隔线</span><br><span class="line">        print('------')</span><br><span class="line"></span><br><span class="line">    #再次输出n的值</span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line">recursion(3)</span><br><span class="line"></span><br><span class="line">执行结果:</span><br><span class="line">3 2 1 0 ----- 0 1 2 3</span><br></pre></td></tr></tbody></table></figure></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「流程控制」「函数」
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 的语法基础</title>
    <link href="http://yoursite.com/2019/04/25/Python/01.Basic-level/01.Python%E7%9A%84%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/04/25/Python/01.Basic-level/01.Python的语法基础/</id>
    <published>2019-04-25T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python的语法基础"><a href="#Python的语法基础" class="headerlink" title="Python的语法基础"></a>Python的语法基础</h1><ul><li>基础语法</li></ul><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul><li><p>编码<br>默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 </p></li><li><p>查看数据类型<br>用法：type(变量名)</p></li><li><p>获取变量在内存中的id标识<br>用法：id(变量名)  </p></li></ul><ul><li><p>系统中保留关键字：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import keyword     </span><br><span class="line">print (keyword.kwlist)</span><br></pre></td></tr></tbody></table></figure></li><li><p>多行语句<br>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句     </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line">        </span><br><span class="line"># 在 [], {}, 或 () 中的多行语句，不需要使用反斜杠(\)</span><br><span class="line">total = ['item_one', 'item_two', 'item_three',</span><br><span class="line">        'item_four', 'item_five']</span><br></pre></td></tr></tbody></table></figure></li><li><p>等待用户输入：input()</p></li><li>同一行显示多条语句  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Python可以在同一行中使用多条语句，语句之间使用分号(;)分割</span><br><span class="line"> </span><br><span class="line">import sys; x = 'runoob'; sys.stdout.write(x + '\n')</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="Python的数据类型"><a href="#Python的数据类型" class="headerlink" title="Python的数据类型"></a>Python的数据类型</h1><p>Python中可以自定义数据类型,可以具有无限种数据类型<br>系统默认提供6个标准数据类型：</p><ul><li>Number类型(数字) </li><li>String类型（字符串） </li><li>List类型 (列表) </li><li>tuple类型(元组) </li><li>Dictionary类型(字典) </li><li>Set类型（集合）</li></ul><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>Number类型主要包含数学相关的数据：一共分为4种小类型：  </p><ul><li><p>整型<br>整型就是整数。包括正整数负整数和0<br>二进制（0b开头）<br>变量 = 0b10101<br>八进制（0o开头）<br>变量 = 0o777<br>十进制（不需要）<br>变量  = 250<br>十六进制（0x开头）<br>变量 = 0xabcd  </p></li><li><p>浮点型<br>浮点型就是小数。<br>使用小数表示浮点数 float1 = 3.141592653<br>科学计数法表示浮点数<br>float2 = 314e-2 # 314*10的-2次方  </p></li><li><p>复数<br>什么是复数。 复数由实数和虚数两部分组成<br>表达式: 163 + 2j<br>使用复数功能结构: com2 = complex(15,3)  </p></li><li><p>布尔类类型<br>布尔值就是表示确定或者否定的数据类型，只有2个值：True和False 在python当中没有真正的布尔类型，而是使用数字0来表示False，数字1表示True，所以bool是Number类型</p></li></ul><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>字符串就是文字类型 </p><h3 id="字符串的声明："><a href="#字符串的声明：" class="headerlink" title="字符串的声明："></a>字符串的声明：</h3><ul><li><p>单引号声明字符串<br>  变量 = ‘值’</p></li><li><p>双引号声明字符串<br>  变量 = “值”  </p></li><li><p>三引号声明变量<br>  变量 = ‘’’值’’’<br>  变量 = “””值”””<br>  三引号声明字符串的方式适合大数据的字符串、多行数据  </p></li></ul><h3 id="字符串相关操作"><a href="#字符串相关操作" class="headerlink" title="字符串相关操作"></a>字符串相关操作</h3><ul><li><p>常用<br>字符串连接符号: +<br>字符复制操作: *<br>[] 通过指定位置（索引）来获取指定位置的字符<br>[:] 取片操作（不包含结束位置）<br>注意事项：<br>单引号中不可以直接使用单引号<br>双引号中不可以直接使用双引号<br>三引号中可以随意使用单双引号   </p></li><li><p>字符串的转义操作：<br>(在行尾时) 续行符<br>\  反斜杠符号<br>\’  单引号<br>\”  双引号<br>\a  响铃<br>\b  退格(Backspace)<br>\e  转义<br>\000    空<br>\n  换行<br>\v  纵向制表符<br>\t  横向制表符<br>\r  回车<br>\f  换页<br>\oyy    八进制数，yy代表的字符，例如：\o12代表换行<br>\xyy    十六进制数，yy代表的字符，例如：\x0a代表换行<br>\other  其它的字符以普通格式输出 </p></li><li><p>r 防止转义:<br>print(r’hello\nrunoob’)    </p></li></ul><h3 id="str-的内置函数"><a href="#str-的内置函数" class="headerlink" title="str 的内置函数"></a>str 的内置函数</h3><ul><li><p>capitalize()  首字母大写<br>格式： str.capitalize()<br>返回值：首字母大写的字符串，仅把整个字符串的第一个字符大写  </p></li><li><p>upper()  将所有英文字符变为大写<br>格式：str.upper()<br>返回值：返回所有英文字符大写的字符串 </p></li><li><p>lower()   将所有英文字符变为小写<br>格式：str.lower()<br>返回值：返回所有英文字符小写的字符串  </p></li><li><p>swapcase()  大小写互相转换<br>格式：str.swapcase()<br>返回值：转换之后的字符串  </p></li><li><p>title()  按照标题格式进行大小写转换（每个单词首字母大写)<br>格式：str.title()<br>返回值：返回所有英文单词首字母大写的字符串  </p></li><li><p>len()  计算字符串的字符个数,以后也可以用于计算元组列表等序列<br>格式: len(str)<br>返回值:整型  </p></li><li><p>count()  计算一个字符串中出现指定字符串的次数<br>格式：str.count(‘查找的字符串’[,开始位置])<br>返回值:返回整型</p></li><li><p>find()  查找字符串中是否具有指定的字符串,查找不到返回-1<br>格式：str.find(查找的字符串[，开始位置])<br>返回值:第一次出现的位置</p></li><li><p>index()  查找字符串中是否具有指定的字符串，查找不到直接报错<br>格式：str.index(查找的字符串[，开始位置])<br>返回值:第一次出现的位置  </p></li><li><p>startswith()  检测字符串是否以指定的字符串开头<br>格式： str.startswith(‘查找的字符串’[，开始位置])<br>返回值：布尔值 </p></li><li><p>endswith()  检测字符串是否以指定的字符串结尾<br>格式： str.endswith(‘查找的字符串’[，开始位置])<br>返回值：布尔值  </p></li><li><p>isupper()  检测字符串中字母是否都是大写字母<br>格式：str.isupper()<br>返回值：布尔值  </p></li><li><p>islower()  检测字符串中的字母是否都是小写字母<br>格式：str.islower()<br>返回值：布尔值  </p></li><li><p>isalnum()  检测一个字符串是否都是有数字或者是否都是有字母组成<br>格式：str.isalnum()<br>返回值:布尔值<br>注意：空字符串返回False  </p></li><li><p>isalpha()  检测字符串是否都是有字母类型构成，汉字作为字母处理<br>格式：str.isalpha()<br>返回值：布尔值<br>注意：空字符串返回False</p></li><li><p>isdigit()  检测字符串是否由纯数字字符组成<br>格式：str.isdigit()<br>返回值：布尔值<br>注意：空字符串返回False  </p></li><li><p>isspace()  检测字符串是否完全由空白字符组成<br>格式：str.isspace()<br>返回值：布尔值<br>注意：回车，换行，缩进，空格都可以当作空白字符，空字符串是False</p></li><li><p>istitle()  检测字符串是否符合title()的结果，每个单词首字母大写<br>格式：str.istitle()<br>返回值：布尔值  </p></li><li><p>isnumeric()  检测字符串是否有纯数字构成<br>格式：str.isnumeric()<br>返回值：布尔值  </p></li><li><p>isdecimal()  检测字符串是否完全由十进制字符组成<br>格式：str.isdecimal()<br>返回值：布尔值  </p></li><li><p>split()  使用指定的字符将字符串卷拆解成多个字符串<br>格式： str.split(‘用于拆解的字符串’)<br>返回值：列表类型  </p></li><li><p>splitlines()  使用\n，\r或者\r\n切割字符串<br>格式：str.splitlines()<br>返回值：列表类型  </p></li><li><p>join()  使用指定的字符串将序列中的内容组成新的字符串<br>格式：连接字符串.join(序列)<br>返回值：组成的新的字符串  </p></li><li><p>zfill()  0填充操作<br>格式： str.zfill(长度)<br>返回值：填充0的字符串<br>注意：填充结果原有内容靠右对齐，前面位数不足使用0来补充，常用于数字类型字符串。  </p></li><li><p>center() 将字符串进行居中操作，并且在空白处进行填充<br>格式： str.center(未来字符宽度,空白填充字符)<br>返回值：新的字符串  </p></li><li><p>ljust（） 将字符串进行左对齐操作，并且在空白处进行填充<br>格式： str.ljust(未来字符宽度,空白填充字符)<br>返回值：新的字符串  </p></li><li><p>rjust() 将字符串进行右对齐操作，并且在空白处进行填充<br>格式： str.rjust(未来字符宽度,空白填充字符)<br>返回值：新的字符串   </p></li><li><p>lstrip() 去掉字符串左侧的空白<br>格式： str.lstrip()<br>返回值：字符串  </p></li><li><p>rstrip()去掉字符串右侧的空白<br>格式： str.rstrip()<br>返回值：字符串  </p></li><li><p>strip()去掉字符串两侧的空白<br>格式： str.strip()<br>返回值：字符串  </p></li><li><p>replace() 字符串替换操作<br>格式： str.replace(被替换的字符串,替换字符串)<br>返回值：替换之后的字符串、  </p></li><li><p>maketrans() 制作一个字符串映射表，为了给translate函数使用<br>格式:str.maketrans（’被替换的字符串’,’替换字符串’）<br>返回值：字典类型，被替换字符串组成键，替换字符串组成值<br>注意： 两个参数的字符串个数必须一一对应，这里的str不是值字符串，而是真正的str，也可以写空字符串代替str（字符串都是str制作的）  </p></li><li><p>translate() 进行字符串翻译操作，类似转换<br>格式：str.translate(映射表)<br>返回值:新的字符串<br>注意:translate用于多字符替换，replace用于长字符串替换  </p></li></ul><h3 id="string模块相关内容"><a href="#string模块相关内容" class="headerlink" title="string模块相关内容"></a>string模块相关内容</h3><ul><li><p>获取所有的空白字符:<br>print (string.whitespace)  </p></li><li><p>获取ascii码的所有字母表（包含大写和小写）:<br>print(string.ascii_letters)  </p></li><li><p>获取ascii码中的所有大写字母:<br>print(string.ascii_uppercase)  </p></li><li><p>获取ascii码中所有的小写字母:<br>print(string.ascii_lowercase)  </p></li><li><p>获取ascii码中所有10进制数字字符:<br>print(string.digits)  </p></li><li><p>获取八进制所有数字字符:<br>print(string.octdigits)  </p></li><li><p>获取十六进制的所有数字字符<br>print(string.hexdigits)  </p></li><li><p>打印所有可见字符<br>print(string.printable)  </p></li><li><p>打印所有标点符号<br>print(string.punctuation)  </p></li></ul><h2 id="List类型-列表"><a href="#List类型-列表" class="headerlink" title="List类型 (列表)"></a>List类型 (列表)</h2><h3 id="列表的定义和访问："><a href="#列表的定义和访问：" class="headerlink" title="列表的定义和访问："></a>列表的定义和访问：</h3><ul><li><p>列表的定义<br>变量 = [值,值,值….]<br>列表的标志符号是[]   </p></li><li><p>列表的访问操作<br>列表变量：[索引位置]<br>添加列表操作：不可以使用索引方式添加<br>修改列表操作：列表变量[索引位置] = 新值<br>删除列表操作：del 列表变量[索引位置] </p></li></ul><h3 id="列表的序列操作"><a href="#列表的序列操作" class="headerlink" title="列表的序列操作"></a>列表的序列操作</h3><ul><li><p>索引操作<br>格式： 列表变量[索引]  </p></li><li><p>分片操作<br>列表[:]<br>表示获取列表的所有数据<br>列表[开始索引：]<br>表示丛开始索引位置截取到列表的最后<br>列表[:结束索引]<br>表示从列表的开头截取到结束索引位置之前，不包含结束位置<br>列表[开始索引:结束索引]<br>表示从列表的开始索引位置截取到结束索引位置之前，不包含结束位置<br>列表[开始索引:结束索引:跳步值]<br>表示从开始索引位置到结束索引位置之间，不包含索引位置，并且获取数据时索引每次+跳步值来获取，默认跳步值为1  </p></li><li><p>序列相加<br>格式：列表 = 列表1 + 列表2</p></li><li><p>列表相乘<br>格式： 列表 = 列表1 * 整数<br>结果：将列表重复N分组成新的列表<br>注意： 数字必须为整数    </p></li><li><p>成员资格运算<br>格式1：数据  in 列表<br>作用：检测数据是否在列表当中<br>返回值：布尔值<br>格式2：数据  not in 列表<br>作用：检测数据是不是不在列表当中<br>返回值：布尔值</p></li><li><p>最大、最小、长度计算</p></li></ul><h3 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h3><ul><li><p>for i in 列表: </p></li><li><p>while i < length:</p></li><li><p>双层列表循环<br>列表 = [[值1,值2],[值1,值2]，[值1,值2]…]<br>for i,j in 列表:</p></li></ul><h3 id="列表内涵：-list-content"><a href="#列表内涵：-list-content" class="headerlink" title="列表内涵： list content"></a>列表内涵： list content</h3><ul><li><p>简单的列表内涵：<br>格式：[[变量 for [变量 in 列表]<br>作用：遍历列表中的数据并且组成新的列表，如果需要改变原有数据，在最开始i处修改<br>结果：新的列表  </p></li><li><p>带有判断的列表内涵<br>格式 [变量 for 变量 in 列表 判断条件]<br>作用：遍历列表中的数据，根据判断条件取出符合条件的数据组成新的列表<br>结果:新的列表  </p></li><li><p>多循环带判断的列表内涵<br>格式：[[变量1+变量2 for 变量1 in 列表1 for 变量2 in 列表2 判断条件]<br>作用：将列表1中和列表2中每个数据进行操作，但是必须在符合判断条件的前提下进行。<br>结果：新的列表  </p></li></ul><h3 id="序列函数"><a href="#序列函数" class="headerlink" title="序列函数"></a>序列函数</h3><ul><li><p>len() 获取列表的数据长度<br>格式：len(列表)<br>返回值：整型  </p></li><li><p>max() 获取列表中的最大值<br>格式：max(列表)<br>返回值：列表中的最大值  </p></li><li><p>min() 获取列表的最小值<br>格式：min(列表)<br>返回值：列表中的最小值  </p></li><li><p>list() 将其他序列类型转化为列表<br>格式：list(序列)<br>返回值：列表  </p></li></ul><h3 id="列表专用函数"><a href="#列表专用函数" class="headerlink" title="列表专用函数"></a>列表专用函数</h3><ul><li><p>append() 在列表的最后追加新数据<br>格式： 列表.append(数据)<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>insert() 在列表指定的位置插入数据<br>格式：列表.insert（索引,数据）<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>pop() 在列表中移除一个元素<br>格式：列表.pop()<br>返回值:移除掉的元素<br>注意：移除列表最后的元素  </p></li><li><p>格式：列表.pop(索引)<br>返回值：:移除掉的元素<br>注意：移除列表中指定索引的元素  </p></li><li><p>remove() 在列表中移除指定的值的元素<br>格式:列表.remove(值)<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>clear() 清空列表<br>格式：列表.clear()<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>reverse() 列表反转<br>格式：列表.reverse（）<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>extend() 在原有列表最后追加新的序列<br>格式:列表.extend(序列类型)<br>返回值：    无<br>注意：该操作直接改变原有列表  </p></li><li><p>count() 计算指定值在列表中出现的次数<br>格式: 列表.count(值)<br>返回值：整数  </p></li><li><p>copy() 复制原有列表<br>格式: 列表.copy()<br>返回值：新的列表 </p></li></ul><h2 id="tuple类型-元组"><a href="#tuple类型-元组" class="headerlink" title="tuple类型(元组)"></a>tuple类型(元组)</h2><h3 id="元组的创建和特征"><a href="#元组的创建和特征" class="headerlink" title="元组的创建和特征"></a>元组的创建和特征</h3><ul><li><p>元组的创建<br>创建空元组:变量 = ()<br>创建单个数据的元组: 变量 = (值,)   或  变量 = 值,<br>创建多个数据的元组: 变量 = (值,值，值…)  或者  变量 = 值,值，值…  </p></li><li><p>元组的特征<br>元组的关键符号是逗号而不是小括号。<br>元组不具备修改功能。<br>是一种特殊的列表。</p></li></ul><h3 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h3><ul><li><p>索引操作<br>元组[索引位置]  </p></li><li><p>分片操作<br>元组[:]<br>获取元素的所有数据<br>元组[开始索引:]<br>获取开始索引位置到最后的所有数据<br>元组[:结束索引]<br>获取元组开头到结束索引位置之前的所有数据（不包含结束位置）<br>元组[开始索引:结束索引]<br>获取元素开始索引位置到结束索引位置之间的所有数据（不包含结束位置）<br>元组[开始索引:结束索引:跳步值]<br>获取元素开始位置到结束索引之间的指定间隔的数据数据（不包含结束位置）  </p></li><li><p>相加操作<br>新元组 = 元组 + 元组  </p></li><li><p>相乘操作<br>新元组 = 元组 * 整数</p></li><li><p>成员检测<br>格式1:数据 in 元组<br>作用：检测数据是不是在元组当中<br>返回值：布尔值<br>格式2:数据 not in 元组<br>检测数据是否不在元组当中<br>返回值：布尔值</p></li></ul><h3 id="元组的遍历"><a href="#元组的遍历" class="headerlink" title="- 元组的遍历"></a>- 元组的遍历</h3><ul><li><p>for i in 元组：</p></li><li><p>双层元组循环<br>元组 = ((值1,值2),(值1,值2)，(值1,值2)…)<br>for i,j in 元组：</p></li></ul><h3 id="元组的函数"><a href="#元组的函数" class="headerlink" title="元组的函数"></a>元组的函数</h3><ul><li><p>len() 获取元组中数据的长度<br>格式： len(元组)<br>返回值：整数  </p></li><li><p>max() 返回元组中最大的值<br>格式：max(元组)  </p></li><li><p>min() 返回元组中的最小值<br>格式：min(元组)  </p></li><li><p>tuple() 将其他序列转化为元组类型<br>格式： tuple(任意序列)  </p></li></ul><h3 id="元组的方法"><a href="#元组的方法" class="headerlink" title="元组的方法"></a>元组的方法</h3><ul><li><p>count() 计算指定数据出现的次数<br>格式:元组.count(查找的数据)<br>返回值：整数  </p></li><li><p>index() 获取指定值在元组中的索引位置<br>格式：元组.index(查找的数据)<br>返回值：索引位置或者错误信息  </p></li><li><p>变量交换 （元组特殊用法）<br>a,b = b,a </p></li></ul><h2 id="Dictionary类型-字典"><a href="#Dictionary类型-字典" class="headerlink" title="Dictionary类型(字典)"></a>Dictionary类型(字典)</h2><ul><li><p>字典格式：<br>变量 = {键:值,键:值….}  </p></li><li><p>键就是标志或者说是目录,值就是真实的值  </p></li><li><p>字典的标志符号是{}   </p></li></ul><h3 id="字典的创建和特征"><a href="#字典的创建和特征" class="headerlink" title="字典的创建和特征"></a>字典的创建和特征</h3><ul><li><p>创建空字典<br>变量 = {} 或者 变量 = dict()</p></li><li><p>创建有数据的字典<br>变量 = {键:值,键:值,键:值…}<br>变量 = dict({键:值,键:值,键:值…})<br>变量 = dict(键=值,键=值,键=值…)<br>变量 = dict([(键,值),(键,值),（键,值）…])<br>变量 = dict(zip((键，键，键….),(值,值，值…)))</p></li><li><p>字典的特征<br>字典也是序列类型但是是无序序列，所以分片操作无法使用<br>字典中每个数据都由键和值两部分组成：<br>值：任意数据都可以当作值来使用<br>键：可以使用 int，float,str,tuple，冰冻集合，但是list，set，dict等不可以使用</p></li></ul><h3 id="字典的基本操作"><a href="#字典的基本操作" class="headerlink" title="字典的基本操作"></a>字典的基本操作</h3><ul><li><p>访问数据：<br>字典变量[键]</p></li><li><p>添加数据<br>字典变量[新键] = 值</p></li><li><p>修改数据<br>字典变量[键] = 新值</p></li><li><p>删除数据<br>del 字典变量[键]</p></li></ul><h3 id="序列操作-1"><a href="#序列操作-1" class="headerlink" title="序列操作"></a>序列操作</h3><ul><li><p>检测数据是否在字典的键中<br>格式：数据 in 字典</p></li><li><p>检测数据是否不再字典的键中<br>格式：数据 not in 字典</p></li></ul><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><ul><li><p>键遍历操作: for k in 字典:</p></li><li><p>键值遍历: for k,v in 字典.items()：</p></li></ul><h3 id="字典内涵"><a href="#字典内涵" class="headerlink" title="字典内涵"></a>字典内涵</h3><ul><li><p>基本的字典内涵<br>变量= {key:value for key,value in 字典.items()}  </p></li><li><p>带有条件的字典内涵<br>变量 = {key:value for key,value in 字典.items() if 条件}  </p></li></ul><h3 id="字典函数"><a href="#字典函数" class="headerlink" title="字典函数"></a>字典函数</h3><ul><li><p>len() 计算字典的长度<br>格式： len(字典)<br>返回值:字典的长度</p></li><li><p>max() 获取字典中的最大值 （默认比较字典的键）<br>格式:max(字典)<br>返回值：最大的键</p></li><li><p>min() 获取字典中的最小值（默认比较字典的键）<br>格式：min(字典)<br>返回值:最小值</p></li><li><p>dict() 将其他序列转化为字典<br>详情请看字典的定义</p></li><li><p>str(字典) 返回字典的字符串格式</p></li></ul><h3 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h3><ul><li><p>clear() 清空字典<br>格式：字典.clear()<br>返回值：无  None<br>注意：直接改变原有字典  </p></li><li><p>items() 获取字典的键值对组成的元组格式<br>格式：字典.items()<br>返回值：将键值对变成元组的列表形式。<br>注意:返回的数据是内建的dict_items类型，专用于字典的转换中间类型  </p></li><li><p>keys() 获取字典中所有键组成的序列，常用语字典遍历<br>格式： 字典.keys()<br>返回值:返回所有键的组合<br>注意：类型为 dict_keysL类型，也是一种字典转换的中间类型  </p></li><li><p>values() 获取字典中所有值组成的序列，常用语字典遍历<br>格式： 字典.values()<br>返回值：所有值的组合<br>注意：类型为dict_values类型，也是一种字典转换的中间类型  </p></li><li><p>get（） 根据指定的键获取值<br>格式：字典.get(键,默认值)<br>返回值：字典键对应的数据<br>注意：如果键不存在与字典中，则返回默认值而不会报错  </p></li><li><p>pop() 根据键从字典中删除数据<br>格式:字典.pop(键)<br>返回值：删除的键对应的值<br>注意：pop在字典中使用必须有参数，因为字典无序序列，直接改变原有字典  </p></li><li><p>copy() 赋值一个字典<br>格式：字典.copy()<br>返回值：复制出来的新的字典  </p></li><li><p>setdefault() 设置字典中不存在的键的值<br>格式：字典.setdefault(键,默认值)<br>返回值：设置时的默认值<br>注意：如果设置时键已经存在于字典中，则不进行任何操作，直接改变原有字典  </p></li><li><p>fromkeys() 使用指定的序列作为键,使用一个值作为字典的所有值<br>格式:字典.fromkeys(序列,值)<br>返回值：由序列作为字典的键，由值作为所有键对应的值组成的字典  </p></li><li><p>update() 使用字典更新另外一个字典<br>格式：字典1.update(字典2)<br>返回值：无<br>注意:直接改变原有字典  </p></li></ul><h2 id="Set类型（集合）"><a href="#Set类型（集合）" class="headerlink" title="Set类型（集合）"></a>Set类型（集合）</h2><h3 id="集合的创建和特征"><a href="#集合的创建和特征" class="headerlink" title="集合的创建和特征"></a>集合的创建和特征</h3><ul><li><p>创建空集合<br>变量 = set()  </p></li><li><p>创建多个数据的集合<br>变量 = {值,值,值….}  </p></li><li><p>集合的特征<br>集合是一种无序的数据类型，无法通过索引和分片进行操作<br>集合是内部元素绝对唯一的数据，常常用于去掉重复数据<br>集合的数据，str，int，float,bool,tuple，冰冻集合。  </p></li></ul><h3 id="集合序列操作"><a href="#集合序列操作" class="headerlink" title="集合序列操作"></a>集合序列操作</h3><ul><li><p>检测数据是否在集合当中<br>格式：数据 in 集合</p></li><li><p>检测数据是否不在集合当中<br>格式：数据 not in 集合</p></li></ul><h3 id="集合遍历操作"><a href="#集合遍历操作" class="headerlink" title="集合遍历操作"></a>集合遍历操作</h3><ul><li><p>for i in 集合:</p></li><li><p>带有元组的集合遍历<br>集合 = {(值1,值2..),(值3,值4..)…}<br>for i,j in 集合:</p></li></ul><h3 id="集合内涵"><a href="#集合内涵" class="headerlink" title="集合内涵"></a>集合内涵</h3><ul><li><p>普通集合内涵<br>新集合 = {变量 for 变量 in 集合}  </p></li><li><p>带条件的集合内涵<br>新集合 = {变量 for 变量 in 集合 if 条件}  </p></li><li><p>多循环的集合内涵<br>新集合 = {变量1+变量2 for 变量1 in 集合1 for 变量2 in 集合2 if 条件}    </p></li></ul><h3 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h3><ul><li><p>len() 获取集合中元素的个数<br>格式:len(集合)<br>返回值：整数</p></li><li><p>max() 获取集合中最大的元素<br>格式:max(集合)<br>返回值：集合中最大的值</p></li><li><p>min() 获取集合中最小的元组<br>格式：min(集合)<br>返回值：集合中的最小值</p></li><li><p>set() 将其他序列转化为集合类型<br>格式：set(序列)<br>返回值：集合类型</p></li></ul><h3 id="集合方法"><a href="#集合方法" class="headerlink" title="集合方法"></a>集合方法</h3><ul><li><p>add() 向集合中添加数据<br>格式： 集合.add(数据)<br>返回值：无<br>注意：直接改变原有集合，已存在的数据无法添加</p></li><li><p>clear() 清空集合<br>格式：集合.clear()<br>返回值：无<br>注意：直接改变原有集合</p></li><li><p>copy() 集合复制<br>格式:集合.copy()<br>返回值:原集合所有数据组成的新的集合</p></li><li><p>remove() 移除指定的值<br>格式:集合.remove(值)<br>返回值：无<br>注意：直接改变原有集合，如果要删除的值不存在，就报错</p></li><li><p>discard()移除集合中指定的值<br>格式:集合.discard(值)<br>返回值：无<br>注意：直接改变原有集合，如果要删除的值不存在，就不作任何操作</p></li><li><p>pop() 随机移除一个元素<br>格式：集合.pop（）<br>返回值：被移除的元素<br>注意：随机移除元素，没啥规律</p></li><li><p>intersection() 计算两个值集合之间的交集<br>格式： 集合1.intersection(集合2)<br>返回值：新的集合</p></li><li><p>difference() 计算两个集合之间的差集<br>格式： 集合1.difference(集合2)<br>返回值:新的集合</p></li><li><p>union() 计算两个集合之间的并集操作<br>格式：集合1.union（集合2）<br>返回值：新的集合</p></li><li><p>issubset() 检测一个集合是否是另外一个集合的子集<br>格式：集合1.issubset(集合2)<br>返回值：布尔值</p></li><li><p>issuperset() 检测一个集合是否是另外一个和集合的超集<br>格式：集合1.issuperset(集合2)<br>返回值：布尔值</p></li><li><p>difference_update（） 计算集合1和集合2的差集并且将结果赋值给集合1<br>格式：集合1.difference_update(集合2)<br>返回值:无<br>注意：操作结果直接赋值给集合1</p></li><li><p>intersection_update() 计算集合1和集合2的交集并且将结果赋值给集合1<br>格式：集合1.intersection_update(集合2)<br>返回值：无<br>注意:操作结果直接赋值给集合1</p></li><li><p>update() 计算集合1和集合2的并集并且将并集结果赋值给集合1<br>格式：集合1.update(集合2)<br>返回值:无<br>注意:操作结果直接赋值给集合1</p></li></ul><h3 id="冰冻集合-固定集合-frozen"><a href="#冰冻集合-固定集合-frozen" class="headerlink" title="冰冻集合/固定集合 frozen"></a>冰冻集合/固定集合 frozen</h3><ul><li><p>冰冻集合就是不可以进行任何修改相关操作的集合</p></li><li><p>创建冰冻集合<br>创建空的冰冻集合: 变量 = frozenset()<br>创建具有数据的冰冻集合: 变量 = fronzenset(一个序列)  </p></li><li><p>操作方法和函数<br>冰冻集合的操作相关函数和方法同集合类型一样。<br>只是不可以使用修改集合相关的方法和函数。  </p></li><li><p>注意:<br>frozenset 和普通的集合一样没有什么本质区别，能够使用的函数数量不一样，仅此而已哦</p></li></ul><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>类型转换会向着更加精确的类型进行转换  </p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>强制类型转换是根据程序需要，由程序员通过操作强制改变数据的类型。  </p><ul><li><p>int（) 强制将数据转化为整型<br>纯数字字符串转化为整型时，类型改变，值不变<br>只有纯整数字符串才可以转换，其他均不可以<br>浮点型可以转化为整型，去掉小数点后面的部分 </p></li><li><p>float() 强制将数据转化为浮点型<br>整数字符串和浮点数字符串均可以转化为浮点型<br>转化过程中类型改变，值不变<br>整型也可以用于浮点型转换     </p></li><li><p>complex（） 生成一个复数  </p></li><li><p>bool() 强制将数据转化为布尔值<br>能够转化为布尔值False的情况：<br>① 字符串 空字符串 ② 整型 0  ③浮点型 0.0 ④ 复数 0+0j ⑤ 布尔值 Flase ⑥ 列表 [] 空列表 ⑦ 元组 () 空元组 ⑧ 字典 {} 空字典 ⑨ 集合 set（）空集合  </p></li><li><p>str() 字符串类型转换<br>所有数据类型都可以转换为字符串，转换规则就是在原有数据基础上加了引号变成了字符串的格式。例如：[1，2，3] =<br>“[1，2，3]”  </p></li><li><p>list() 将其他数据转换为列表类型<br>能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据）</p></li><li><p>tuple() 将其他数据类型转换为元组类型<br>能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据）  </p></li><li><p>dict() 将其他数据转化为字典类型<br>字典类型转换可以转化的类型有三种：list 、tuple 、set<br>以上所有类型的每个数据必须由元组组成，并且每个元组必须有2个值<br>例子：<br>{(‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’)}<br>[(‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’)]<br>((‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’))    </p></li><li><p>set() 集合类型转换<br>能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据） </p></li></ul><h1 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h1><h2 id="利用百分号格式化"><a href="#利用百分号格式化" class="headerlink" title="利用百分号格式化"></a>利用百分号格式化</h2><ul><li>%d 此处应该放入一个整数<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = "i am %d years old"</span><br><span class="line">print (s%18)</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>%s 放入一个字符串 </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = "i am %s"</span><br><span class="line">print ("i love %s"%"KI")</span><br><span class="line">print (s%"KIOVEN")</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果出现多个占位符，则相应内容需要用括号括起来</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = "i am %s,i am %d years old"</span><br><span class="line">print (s%("ouwen",18))</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="利用format格式化"><a href="#利用format格式化" class="headerlink" title="利用format格式化"></a>利用format格式化</h2><ul><li>以{}和： 代替%号，后面用format带参数完成<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = 'i love {}'.format("you")</span><br><span class="line">print (s)</span><br><span class="line"></span><br><span class="line">s = "i am {1} years old,i love {0} and {1} years old".format("tulingxueyuan",24)</span><br><span class="line">print (s)</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="表达式、运算符"><a href="#表达式、运算符" class="headerlink" title="表达式、运算符"></a>表达式、运算符</h1><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>由变量、运算符、数字、数字分组符号（括号）等以能求得数值的有意义排列方法所得的组合。</p><h2 id="运算符的分类"><a href="#运算符的分类" class="headerlink" title="运算符的分类"></a>运算符的分类</h2><ul><li>算术运算  </li><li>比较运算/关系运算  </li><li>赋值运算  </li><li>逻辑运算  </li><li>位运算  </li><li>成员运算  </li><li>身份运算  </li></ul><h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><pre><code>+  -  *  /  %(取余)  //(地板除，取商)  **幂运算 </code></pre><p>注意：<br>    python中没有自增自减的 ++ 或者– 运算<br>    混合计算时，Python会把整型转换成为浮点数  </p><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><pre><code>==  ！=  >   <   >=  <=</code></pre><p>注意：在python中没有 === 和 ！==运算，只要类型不同就是不等于</p><h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><pre><code>=   +=  -=  *=  /=  //= **=</code></pre><p>注意：a <em>= b 转换之后的表达式为 a = a </em> b 无论何种赋值运算都符合这个格式      </p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>逻辑运算是布尔值之间的运算<br>and 与运算：有假则假<br>or 或运算：有真则真<br>not 非运算:真变假，假变真</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>位运算就是在二进制基础上进行的逻辑运算，将0视为False，将1视为True进行的运算     </p><ul><li>&   按位与运算</li><li>|   按位或运算</li><li><p>～   按位非运算<br>注意：按位非运算之后计算机会进行反码和补码的相关操作之后进行数据存储   </p></li><li><p>^   按位抑或运算:将数据转化为2进制数据然后进行每个位上的逻辑抑或运算<br>变量 = 值1 ^ 值2  </p></li><li><p>左移运算:将数据转化为二进制之后，将二进制数据的所有数据向左移动指定的位数<br>变量 = 值  <<  移动位数<br>特征：左移N位相当于乘以2的N次方，此方法速度远高于乘法   </p></li><li><p>右移运算<br>将数据转化为二进制之后，将二进制数据的所有数据向右移动指定的位数，如果数据移除右侧边界，则会被删除，实际上相当于采用了地板除！<br>变量 = 值 >>  移动位数<br>特征：右移N位相当于除以2的N次方，舍弃小数部分。此方法速度远高于除法 </p></li></ul><h3 id="成员运算"><a href="#成员运算" class="headerlink" title="成员运算"></a>成员运算</h3><ul><li><p>in 检测一个值在指定的序列类型里面<br>格式：  值 in 可迭代序列  </p></li><li><p>not in 检测一个值是否不再指定的序列里面<br>格式：  值 not in 可迭代序列</p></li></ul><h3 id="身份运算"><a href="#身份运算" class="headerlink" title="身份运算"></a>身份运算</h3><ul><li><p>is 检测值1是不是和值2在内存中是否是同一个值，类似id()功能<br>格式: 数据1 is 数据2  </p></li><li><p>is not 检测值1是不是和值2在内存中是否不是同一个值，类似id()功能<br>格式:   数据1 is not 数据2 </p></li></ul><h3 id="检测数据归属"><a href="#检测数据归属" class="headerlink" title="检测数据归属"></a>检测数据归属</h3><ul><li><p>type() 测试时可以使用，开发尽量避免使用<br>格式：type(变量)  </p></li><li><p>isinstance() 检测一个数据是否由指定的类型创建<br>格式：isinstance(变量，检测的类型)  </p></li></ul><h3 id="运算优先级问题"><a href="#运算优先级问题" class="headerlink" title="运算优先级问题"></a>运算优先级问题</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">**  指数 (最高优先级)  </span><br><span class="line">~ + -   按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)  </span><br><span class="line">* / % //    乘，除，取模和取整除  </span><br><span class="line">+ - 加法减法  </span><br><span class="line">>> <<   右移，左移运算符  </span><br><span class="line">&   位 <span class="string">'AND'</span>  </span><br><span class="line">^ | 位运算符  </span><br><span class="line"><= < > >=   比较运算符  </span><br><span class="line">== !=    等于运算符  </span><br><span class="line">= %= /= //= -= += *= **=    赋值运算符   </span><br><span class="line"><span class="keyword">is</span> <span class="keyword">is</span> <span class="keyword">not</span>   身份运算符  </span><br><span class="line"><span class="keyword">in</span> <span class="keyword">not</span> <span class="keyword">in</span>   成员运算符  </span><br><span class="line"><span class="keyword">not</span> <span class="keyword">or</span> <span class="keyword">and</span>  逻辑运算符    </span><br><span class="line">注意：我们并不推荐死记硬背优先级，在实际使用中最好使用()解决优先级问题</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「语法基础」「数据类型」「字符串格式化」「表达式、运算符」
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>HTML 前端课程</title>
    <link href="http://yoursite.com/2019/04/04/Html/01.Html/"/>
    <id>http://yoursite.com/2019/04/04/Html/01.Html/</id>
    <published>2019-04-04T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.743Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.HTML           (常用标签          网页的基本结构)</span><br><span class="line">2.CSS            (常用样式          网页的显示效果)</span><br><span class="line">3.JavaScript     (用户交互效果       动态效果)</span><br><span class="line">4.jQuery         (JavaScript库     简化原生js操作)</span><br><span class="line">5.Ajax           (异步数据交互       在页面不刷新的情况下进行数据交互)</span><br><span class="line">6.BootStrap      (前段UI框架        快速搭建静态页面并支持不同设备)</span><br></pre></td></tr></tbody></table></figure><h2 id="HTML概述"><a href="#HTML概述" class="headerlink" title="HTML概述"></a>HTML概述</h2><h3 id="什么是HTML"><a href="#什么是HTML" class="headerlink" title="什么是HTML"></a>什么是HTML</h3><p>HTML 是用来描述网页的一种语言。</p><blockquote><p>超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。</p></blockquote><blockquote><p>HTML 不是一种编程语言，而是一种标记语言</p></blockquote><blockquote><p>标记语言是一套标记标签 (markup tag)</p></blockquote><blockquote><p>HTML 文档包含了HTML 标签及文本内容</p></blockquote><blockquote><p>HTML文档也叫做 web 页面</p></blockquote><h3 id="HTML是干嘛的"><a href="#HTML是干嘛的" class="headerlink" title="HTML是干嘛的"></a>HTML是干嘛的</h3><blockquote><p>可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。</p></blockquote><h3 id="建立HTML文件"><a href="#建立HTML文件" class="headerlink" title="建立HTML文件"></a>建立HTML文件</h3><ul><li>.html</li><li>.htm</li></ul><h3 id="HTML注释"><a href="#HTML注释" class="headerlink" title="HTML注释"></a>HTML注释</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><!--注释内容--></span><br></pre></td></tr></tbody></table></figure><h3 id="HTML网页的基本结构"><a href="#HTML网页的基本结构" class="headerlink" title="HTML网页的基本结构"></a>HTML网页的基本结构</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 第一行是声明文档：告诉浏览器以什么html版本解析我们的代码 </span><br><span class="line"><!DOCTYPE html>      声明为 HTML5 文档</span><br><span class="line"><html>              html是我们网页当中最大的标签,根元素</span><br><span class="line"><!-- 主要是来写不直接显示在页面当中的内容,一般是做网页的一些设置--></span><br><span class="line"><head>头，元素包含了文档的元（neta)数据</span><br><span class="line"><!--设置网页编码格式--></span><br><span class="line"><meta charset="utf-8"></span><br><span class="line"><!--设置网页的标题--></span><br><span class="line"><title></title></span><br><span class="line"></head>   </span><br><span class="line"><!-- 主要是写显示在页面当中的内容--></span><br><span class="line"><body></body>   体，元素包含了可见的页面内容</span><br><span class="line"></html></span><br></pre></td></tr></tbody></table></figure><h3 id="HTML标签结构"><a href="#HTML标签结构" class="headerlink" title="HTML标签结构"></a>HTML标签结构</h3><p>HTML 标记标签通常被称为 HTML 标签 (HTML tag)。</p><ul><li>HTML 标签是由尖括号包围的关键词</li><li>HTML 标签通常是成对出现的</li><li>标签对中的第一个标签是开始标签，第二个标签是结束标签</li></ul><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><开始标签>内容</结束标签></span><br></pre></td></tr></tbody></table></figure><h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><p>“HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思.<br> 一个 HTML 元素包含了开始标签与结束标签</p><h3 id="HTML属性"><a href="#HTML属性" class="headerlink" title="HTML属性"></a>HTML属性</h3><ul><li>HTML 元素可以设置属性</li><li>属性一般添加在开始标签 (<header></header>)</li><li>属性一般以名称/值对的形式出现，比如：name=”value”。</li></ul><p><strong>注意：</strong></p><ul><li>属性值必须用双引号引起来</li><li>标签都用小写字母</li><li>双标签必须要写闭合标签</li></ul><h1 id="HTML常用标签"><a href="#HTML常用标签" class="headerlink" title="HTML常用标签"></a>HTML常用标签</h1><h2 id="HTML常用的块级标签（块级元素）"><a href="#HTML常用的块级标签（块级元素）" class="headerlink" title="HTML常用的块级标签（块级元素）"></a>HTML常用的块级标签（块级元素）</h2><blockquote><p>独占一行</p></blockquote><h3 id="有语义的HTML块级元素"><a href="#有语义的HTML块级元素" class="headerlink" title="有语义的HTML块级元素"></a>有语义的HTML块级元素</h3><blockquote><p>有默认样式</p></blockquote><ul><li><p>标题（Heading） </p><blockquote><p>通过H1～H6 标签来定义的.</p></blockquote></li><li><p>段落 </p><blockquote><p>通过标签 p 来定义的.</p></blockquote></li><li><p>列表<br>无序列表 ul,li</p><blockquote><p>是一个项目的列表,列项目使用粗体圆点（典型的小黑圆圈）进行标记</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><ul></span><br><span class="line"><li>l列表项1</li></span><br><span class="line"><li>列表项2</li></span><br><span class="line"></ul></span><br></pre></td></tr></tbody></table></figure></blockquote></li></ul><p>有序列表 ol,li</p><blockquote><p>也是一个项目的列表，列表项目默认使用数字进行标记。有序列表当中有type属性，设置列表的标记类型<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><ol type='a'></span><br><span class="line"><li>l列表项1</li></span><br><span class="line"><li>列表项2</li></span><br><span class="line"></ol></span><br></pre></td></tr></tbody></table></figure><p></p></blockquote><p>自定义列表 dl,dt,dd（了解）<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><dl></span><br><span class="line"><dt>这是自定义标题</dt></span><br><span class="line"><dd>这是自定义列表项</dd></span><br><span class="line"></dl></span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>注意：</strong><br>列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。</p><ul><li>表格 table,tr,td<br>table常用属性</li><li>border        边框</li><li>cellpadding   内容距离表框的距离</li><li>cellspacing   单元格和单元格之间的距离</li><li>rowspan       垂直合并（跨行显示）</li><li>colspan       水平合并（跨列显示）</li><li>anglin        内容水平对其方式</li><li>valign        内容垂直对其方式<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><table border="1" cellpadding="10px"></span><br><span class="line"><tr></span><br><span class="line"><td>第一行、第一列</td></span><br><span class="line"><td>第一行、第二列</td></span><br><span class="line"></tr></span><br><span class="line"><tr></span><br><span class="line"><td>第二行、第一列</td></span><br><span class="line"></tr></span><br><span class="line"></table></span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="无意义的块级元素-div"><a href="#无意义的块级元素-div" class="headerlink" title="无意义的块级元素 div"></a>无意义的块级元素 div</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><div> 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示换行。</span><br><span class="line">一般与 CSS 一同使用</span><br><span class="line"><div> 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。</span><br></pre></td></tr></tbody></table></figure><h2 id="HTML常用的行级标签（行内元素）"><a href="#HTML常用的行级标签（行内元素）" class="headerlink" title="HTML常用的行级标签（行内元素）"></a>HTML常用的行级标签（行内元素）</h2><p>不独占一行</p><h3 id="有语义的行内元素"><a href="#有语义的行内元素" class="headerlink" title="有语义的行内元素"></a>有语义的行内元素</h3><h4 id="HTML链接-a标签"><a href="#HTML链接-a标签" class="headerlink" title="HTML链接 a标签"></a>HTML链接 a标签</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><a href="链接地址">链接文本</a></span><br></pre></td></tr></tbody></table></figure><p>target属性，定义被链接的文档在何处显示  _blank 新窗口打开</p><h4 id="HTML图像"><a href="#HTML图像" class="headerlink" title="HTML图像"></a>HTML图像</h4><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><img src="图片地址" alt=""></span><br></pre></td></tr></tbody></table></figure><h4 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h4><ul><li>b标签 i标签 strong标签 em标签</li></ul><h3 id="无语义的行内元素"><a href="#无语义的行内元素" class="headerlink" title="无语义的行内元素"></a>无语义的行内元素</h3><ul><li>span标签 配合css使用</li></ul><h2 id="常用的实体字符"><a href="#常用的实体字符" class="headerlink" title="常用的实体字符"></a>常用的实体字符</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&lt;&copy;</span><br></pre></td></tr></tbody></table></figure><h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><p>表单是一个包含表单元素的区域。通过form来定义表单区域</p><blockquote><p>通过type属性定义不同类型的表单控件</p><ul><li>text 普通文本输入框</li><li>password 密码输入框</li><li>radio    单选按钮</li><li>checked  多选按钮</li><li>select   下拉框</li><li>file     文件上传选框</li><li>textarea 文本域</li><li>submit   提交按钮</li><li>reset    充值按钮</li><li>hidden   隐藏域，要和表单单一其提交的信息</li></ul></blockquote><p>常用属性：<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name 属性：表单项名，用于存储内容值</span><br><span class="line">value属性：输入的值</span><br><span class="line">disabled属性：禁用属性</span><br><span class="line">readonly属性：禁用属性</span><br><span class="line">checked属性：选择框指定默认选项</span><br><span class="line">placeholder：提示</span><br></pre></td></tr></tbody></table></figure><p></p><p><strong>注意：</strong><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">form 有两个必须存在的属性 action提交地址 metchod提交方式</span><br><span class="line">post:通过request body传参，参数不可见，参数没有大小限制</span><br><span class="line">get:通url进行传参，参数可见，不安全，大小有限制，</span><br><span class="line"></span><br><span class="line">如果表单中含有文件上传 </span><br><span class="line">    method提交方式必须为post </span><br><span class="line">    form中必须有enctype属性</span><br><span class="line">    enctype="multipart/form-data"</span><br></pre></td></tr></tbody></table></figure><p></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「HTML」
    
    </summary>
    
      <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 语法「四」</title>
    <link href="http://yoursite.com/2018/11/15/MySQL/04.MySQL/"/>
    <id>http://yoursite.com/2018/11/15/MySQL/04.MySQL/</id>
    <published>2018-11-15T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.749Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-语法「四」"><a href="#MySQL-语法「四」" class="headerlink" title="MySQL 语法「四」"></a>MySQL 语法「四」</h1><ul><li>日志</li><li>备份  </li></ul><h2 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h2><ul><li>错误日志</li><li>查询日志</li><li>慢查询日志</li><li>二进制日志</li><li>中继日志</li><li>innodb 存储引擎级别的事务日志</li></ul><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>mysql 执行过程中的错误信息、警告信息、event  schedule运行时产生的信息、mysql 启动和停止过程的输出信息、主从结构中，从服务器IO复制线程的启动信息。<br>常用 log_error 和 log_warning 来定义。<br>show variables like “%log_errror%”;</p><p>log_warning: 标识告警信息是否一并记录到错误日志中、<br>为  0 表示不记录告警信息 、为1表示告警信息一并记录到错误日志中。<br>大于1 表示失败的连接 的信息和创建新连接时 拒绝访问类的错误信息也会被记录到错误日志。<br>show variables like “%log_warning%”;</p><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql> show  variables where variable_name like "%general_log%" or variable_name="log_output";</span><br><span class="line">+------------------+----------------------------------+</span><br><span class="line">| Variable_name    | Value                            |</span><br><span class="line">+------------------+----------------------------------+</span><br><span class="line">| general_log      | OFF                              |</span><br><span class="line">| general_log_file | /var/lib/mysql/VM_0_2_centos.log |</span><br><span class="line">| log_output       | FILE                             |</span><br><span class="line">+------------------+----------------------------------+</span><br></pre></td></tr></tbody></table></figure><p>general_log：表示查询日志是否开启。默认为OFF</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><ul><li><p>show variables like “slow_query_log%”;<br>show variables where variable_name like “%slow_query%” or variable_name like “log_output”;<br>show variables like “slow_query_log%”;<br>log_slow_queries： 是否开启慢查询<br>log_output:慢查询开启后以哪种方式存放<br>FILE：表示慢查询日志存放于指定的文件中<br>TABLE：表示慢查询日志存放于mysql库的slow_log表中<br>FILE,TABLE：同时存放于指定文件和slow_log 表中<br>NONE：不记录查询日志<br>slow_query_log_file:log_output设置为FILE时，指定慢查询日志存储于哪个日志文件中。默认文件名为 “ 主机名-slow.log” ，位置为datadir参数。<br>long_query_time:认定的慢查询时间<br>log_queries_not_using_indexes:如果运行的sql语句没有使用到索引，是否也被当做慢查询记录到慢查询日志中，OFF 表示不记录，ON 表示记录。<br>set global slow_query_log=ON;<br>show variables where variable_name like “%slow_query%” or variable_name like “log_output”;<br>show variables like “slow_query_log%”;<br>set global long_query_time=3;<br>select @@global.long_query_time;<br>举例：select  sleep(5);<br>tail -fn6 /var/lib/mysql/<br>show global status like ‘%slow_queries%’;</p></li><li><p>mysqldumpslow 命令<br>mysql自带的对慢查询日志的统计分析工具。只能作用于慢查询日志文件，不会统计slow_log表。<br>mysqldumpslow -s t /var/lib/mysql/cos72ini-slow.log<br>mysqldumpslow -s r  /var/lib/mysql/DU-HOST-slow.log<br>c :执行计数<br>i:锁定时间<br>r:返回记录<br>t:执行时间<br>al：平均锁定时间<br>ar:平均返回记录数<br>mysqldumpslow -s r -t 2  /var/lib/mysql/DU-HOST-slow.log    -t 指明查看多少条统计信息。查看两条统计信息。</p></li><li><p>其他选项<br>mysqldumpslow –help</p></li></ul><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><ul><li><p>binlog ：记录所有修改数据的语句、有可能改变数据库的语句—–主要用于时间点恢复（备份恢复），以及主从复制结构。</p></li><li><p>三种模式：<br>statement模式：记录对数据库修改的语句。<br>row模式：记录对数据库做出修改的语句所影响的数据行以及这些行的修改。<br>mixed模式：混合以上两种模式，一般语句使用statement模式，特殊函数使用row模式记录。<br>my.cnf 配置<br>binlog.format=row</p></li><li><p>二进制日志相关参数：<br>log_bin:控制是否开启二进制日志。只读变量，只能通过修改my.cnf，设置log_bin的值<br>sql_log_bin: 当前会话的操作是否会被记录于二进制中<br>binlog_format:二进制日志的记录方式<br>max_binlog_size:设置单个二进制日志文件的最大大小<br>sync_binlog：<br>show binary log;<br>show master logs;</p></li></ul><ul><li><p>查看二进制日志文件<br>①show binlog events in ‘二进制文件名’;<br>指定位置查看：<br>②show binlog events in ‘二进制文件名’ from 24 ;<br>limit 3 ;<br>limit 100,10;<br>③show master status;<br>查看当前使用的二进制文件，以及位置。</p></li><li><p>滚动二进制日志<br>flush logs;</p></li></ul><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><ul><li><p>备份相关术语：<br>全量备份：对某个时间点的数据完全的备份<br>差异备份：<br>增量备份：对上一次备份后的变化的数据的备份<br>时间点恢复<br>热备：在数据库正常运行的情况下备份<br>温备：备份期间数据库只能进行读。不能进行写操作<br>冷备：备份期间。读写均不可操作<br>物理备份：直接备份数据库对应的数据文件<br>逻辑备份：建数据从数据导出，并且将导出的数据进行存档备份  </p></li><li><p>常用的备份工具：<br><a href="http://www.zsythink.net/archives/1450" target="_blank" rel="noopener">mysqldump</a><br><a href="http://www.zsythink.net/archives/1455" target="_blank" rel="noopener">xtrabackup</a><br>select 语句进行部分备份<br>cp、tar命令。适于冷备。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「日志」「备份」
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 语法「三」</title>
    <link href="http://yoursite.com/2018/11/14/MySQL/03.MySQL/"/>
    <id>http://yoursite.com/2018/11/14/MySQL/03.MySQL/</id>
    <published>2018-11-14T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.747Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-语法「三」"><a href="#MySQL-语法「三」" class="headerlink" title="MySQL 语法「三」"></a>MySQL 语法「三」</h1><ul><li>增、删、改、查等     </li><li>查询缓存   </li><li>存储引擎</li></ul><h2 id="增、删、改、查-等"><a href="#增、删、改、查-等" class="headerlink" title="增、删、改、查 等"></a>增、删、改、查 等</h2><ul><li><p>insert<br>① insert into tb1（name,age) values(‘tom’,33);<br>insert into tb1(name,age) values(‘jerry’,33),(‘naruto’，28）；<br>insert into tb1 values(4,’sasuke’,28),(5,’hinata’,25);<br>② insert into tbl set id=2,name=’test’,age=18;</p></li><li><p>delete<br>delete from tb1;<br>delete from tb1 where age=22;<br>delete from tb1 where name like ‘k.*’;<br>delete from tb1 where age > 30 order by age desc limit 1;</p></li><li><p>update<br>update tb1 set age=28;<br>update tb1 set name=’kkkk’ where id=3;<br>update tb1 set name=’xxxx’,age=22 where id=5;</p></li><li><p>select<br>① select <em> from tb1 limit 3;<br>select </em> from tb1 where age>=25 and age<=30;<br>select <em> from tb1 where age between 25 and 30;<br>select </em> from tb1 where age not between 25 and 30;    不在25-30区间。<br>② in 关键字指定列表：<br>select <em> from tb1 where age in(22,23,24,25);<br>③ 去重查询:distinct<br>select distinct age from sut;<br>④ 取别名：<br>select name as stuname,age from t1;<br>⑤ 分组和聚合：<br>select </em> from students froup by gender;<br>⑥ 对分组后的信息再次过滤，使用having 关键字<br>select avg(age) as aveage,gender from students froup by gender having aveage > 20;<br>⑦ 多表查询：<br>select * fomr t1,t2;</p></li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><ul><li><p>查看当前服务是否开启缓存<br>show variables like ‘%query_cache%’;<br>mysql> show variables like ‘%query_cache%’;<br>+——————————+———+<br>| Variable_name                | Value   |<br>+——————————+———+<br>| have_query_cache             | YES     |                YES   支持缓存<br>| query_cache_limit            | 1048576 |                单挑查询缓存的最大值，默认1M。超过大小结果不会被缓存。<br>| query_cache_min_res_unit     | 4096    |        缓存存储于内存的最小单元，默认4K。<br>| query_cache_size             | 1048576 |            查询缓存的总大小<br>| query_cache_type             | OFF     |           ON、OFF、DEMAND 分别表示启用、禁用、按需缓存<br>| query_cache_wlock_invalidate | OFF     |<br>+——————————+———+<br>6 rows in set (0.00 sec)</p></li><li><p>使用：<br>① 在开启缓存（query_cache_type=ON) 指定对应的查询语句不使用缓存：<br>select sql_no_cache name from stu;<br>②在按需缓存（query_cache_type=DEMAND) 指定对应的查询语句使用缓存：<br>select sql_cache name from stu;</p></li><li><p>举例：在 my.cnf 设置查询未 按需缓存，缓存空间大小100M<br>query_cache_type=DEMAND<br>query_cache_size=100M</p></li><li><p>清除查询缓存中已经存在的缓存<br>reset query cache;</p></li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ul><li><p>存储引擎也称为 “ 表类型”，每张表可以使用不同的存储引擎类型。<br>MYISAM: 支持级锁，不支持行级锁、不支持事务、不支持外部约束，支持全文索引，表空间文件较小<br>INNODB：支持表级锁、行级锁、事务、外检，不支持全文索引，表空间较大。<br>CSV：<br>MRG_MYISAM：<br>BLACKHOLE：<br>MEMORY：<br>PERFORMANCE_SCHEMA：<br>FEDERATED：<br>ARCHIVE：<br>FEDRATED：</p></li><li><p>查看表类型，查看存储引擎<br>show engines;<br>show create table t1;<br>show table status \G;<br>show table status like ‘%t1%’ \G;</p></li><li><p>设置存储引擎/ 表类型：<br>在创建表的时候指定： create table t1 (id int(10) default null) ENGINE=innodb;</p></li><li><p>修改表的存储引擎/修改默认表类型：<br>alter talbe t1 ENGINE=myisam;</p></li><li><p>修改默认的存储引擎<br>vim /etc/my.cnf<br>default-storage-engine=innodb<br>innodb_file_per_table=on</p></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><p>事务： 一组sql语句的集合。当做一个操作单元。（要么都执行成功、要么全部失败）<br>mysql 中，innodb 存储引擎是支持事务的，完全符合ACID 特性。<br>A： atomicity 原子性<br>C: consistency 一致性<br>I: isolation 隔离性<br>D: durability  持久性</p></li><li><p>redo log ：mysql 会将事务中的sql 语句涉及到的所有数据操作先记录到redo log 中，然后将操作从redo log 中执行。<br>redo log ：包含 redo log buffer(重做日志缓冲）和 redo log file(重做日志文件)<br>redo log  buffer :存在于内存中<br>redo log file： 存在于磁盘上</p></li><li><p>undo log : 数据被修改前的备份。</p></li><li><p>log group:重做日志组。有多个重做日志文件</p></li><li><p>事务日志参数：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">show global variables like '%innodb%log%';</span><br><span class="line">mysql> show global variables like '%innodb%log%';</span><br><span class="line">+----------------------------------+-----------+</span><br><span class="line">| Variable_name                    | Value     |</span><br><span class="line">+----------------------------------+-----------+</span><br><span class="line">| innodb_api_enable_binlog         | OFF       |</span><br><span class="line">| innodb_flush_log_at_timeout      | 1         |</span><br><span class="line">| innodb_flush_log_at_trx_commit   | 1         |表示事务提交以后，是否立即将redo log 从内存耍写到redo log file  中。</span><br><span class="line">| innodb_locks_unsafe_for_binlog   | OFF       |</span><br><span class="line">| innodb_log_buffer_size           | 8388608   |</span><br><span class="line">| innodb_log_compressed_pages      | ON        |</span><br><span class="line">| innodb_log_file_size             | 50331648  |每个redo log file 的大小。</span><br><span class="line">| innodb_log_files_in_group        | 2         |每个重做日志组中有几个 redo log file</span><br><span class="line">| innodb_log_group_home_dir        | ./        |重做日志组文件所在路径，默认为 /var/log/mysql 此目录中的 lib_logfile0 和 lib_logfile1 即为日志组的两个重做日志5M，也对应了innodb_log_file_size 的值。</span><br><span class="line">| innodb_mirrored_log_groups       | 1         |一共有几组日志组</span><br><span class="line">| innodb_online_alter_log_max_size | 134217728 |</span><br><span class="line">| innodb_undo_logs                 | 128       |</span><br><span class="line">+----------------------------------+-----------+</span><br><span class="line">12 rows in set (0.03 sec)</span><br></pre></td></tr></tbody></table></figure></li><li><p>事务控制语句<br>查看是否开启自动提交功能：<br>show global variables like ‘autocommit%’;<br>show session variables like ‘autocommit%’;</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「增、删、改、查等」「查询缓存」「存储引擎」
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 语法「二」</title>
    <link href="http://yoursite.com/2018/11/12/MySQL/02.MySQL/"/>
    <id>http://yoursite.com/2018/11/12/MySQL/02.MySQL/</id>
    <published>2018-11-12T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-语法「二」"><a href="#MySQL-语法「二」" class="headerlink" title="MySQL 语法「二」"></a>MySQL 语法「二」</h1><ul><li>约束、键  </li><li>索引</li><li>视图</li></ul><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul><li><p>常用约束：主键约束、唯一键约束、外键约束、非空约束等<br>主键 primary key ： 一个或多个字段的组合。只能有一个主键<br>唯一键 unique key：字段的数据必须不同于已经存在的其他行上的数据，但可以为空。可以有多个唯一键<br>外键：foreign key。 一个表中的外键字段中所有能插入的数据取值范围，取决于引用的另一个表上主键字段上的已经存在的数据集合<br>检查条件约束：check，自定义的逻辑表达式  </p></li><li><p>非空约束<br>添加非空约束：<br>alter table testtb modify name varchar(100) not null;<br>删除非空约束：<br>alter table testtb modify name varchar(100) null;</p></li><li><p>自动增长<br>添加自动增长：<br>alter table testtb modify id int auto_increment;<br>alter table testtb change id id int auto_increment;<br>删除自动增长：<br>alter table testtb change id id int;<br>alter table testtb modify id int;</p></li><li><p>主键约束<br>添加主键约束：<br>alter table testtb add primary key(id);<br>alter table testtb add constraint primary key(id);<br>删除主键约束：<br>alter table testtb drop primary key;<br>注意：如果对应的主键上存在自动增长，则不能直接删除主键，需先删除自动增长后，在删除主键。</p></li><li><p>唯一性约束<br>添加唯一性约束：<br>alter  table testtb add unique key(uid);<br>alter table testtb add unique key uni_test(test);<br>删除唯一键约束：<br>alter table testtb drop index uni_test;</p></li><li><p>外键约束<br>添加外键约束：<br>alter table testtb add column tid int defalut 0 not null;<br>alter table testtb and constraint testtb_tid_kd foreign key(tid) references testtb2(id);<br>删除外键约束：<br>alter table test4 drop foreign key test_tid_fk;</p></li><li><p>查看约束<br>select * from information_schema.key_column_usage where table_name=’test1’;</p></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><p>索引管理<br>单纯的值index<br>添加一个单纯的索引：<br>① alter table testtb add index ind_name(name);<br>②create index ind_name on testtb(name);<br>create index ind_name on testtb(name(20);<br>create index ind_name on testtb(name(20) desc);</p></li><li><p>联合索引<br>create index ind_id_name on test1(id,name);<br>create index ind_id_name on testtb1(id,name(20));</p></li><li><p>重建索引<br>repair table table_name quick;</p></li><li><p>删除索引<br>alter table test2 drop index uu_ttt;</p></li><li><p>查看索引<br>show index from testtb;<br>show index form testtb key_name like ‘ind%’;</p></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul><li><p>创建视图<br>select create_view_priv,,select_priv from mysql.user where user=’root’ and host=’%’;<br>create_view_priv 的值为Y，表示当前用户拥有创建视图的权利。<br>create view testvi as select <em> from classes where classid <=3;<br>视图是一种虚表，不能与存在的表重名:<br>create or replace view testvi as select </em> from classes where classid <=4  如果不存在testvi则创建，存在则覆盖。</p></li><li><p>视图使用自己的字段名称<br>create view testvi(a,b,c) select * from classes;<br>create view testvi(classname,stunum) as select class,num from classes</p></li><li><p>从多个表中查询出数据创建视图<br>create or replace view testvi as select s.name,s.age,c.class from students  s.classes c where s.classid=c.classid;</p></li><li><p>删除视图<br>drop view testvi;<br>如果视图testvi存在，则删除<br>drop view if exists testvi;</p></li><li><p>查看视图<br>select <em> from information_schema.views where table_schema=’U_DB_NAME’;<br>像查表一样使用：<br>select </em> from testvi;</p></li><li>修改视图<br>alter view testvi as select name,age from students;</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「约束、键」「索引」「视图」
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 语法「一」</title>
    <link href="http://yoursite.com/2018/11/08/MySQL/01.MySQL/"/>
    <id>http://yoursite.com/2018/11/08/MySQL/01.MySQL/</id>
    <published>2018-11-08T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.752Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-语法"><a href="#MySQL-语法" class="headerlink" title="MySQL 语法"></a>MySQL 语法</h1><ul><li>MySQL 管理</li><li>MySQL 用户、授权</li><li>MySQL 库</li><li>MySQL 表</li></ul><h2 id="MySQL-管理"><a href="#MySQL-管理" class="headerlink" title="MySQL 管理"></a>MySQL 管理</h2><h3 id="启动和关闭"><a href="#启动和关闭" class="headerlink" title="启动和关闭"></a>启动和关闭</h3><ul><li>不是通过RPM包安装的MySQL<br>启动：    /usr/bin/mysqld_safe &<br>关闭：    mysqladmin -uroot shutdown -p</li></ul><h3 id="MySQL-连接"><a href="#MySQL-连接" class="headerlink" title="MySQL 连接"></a>MySQL 连接</h3><ul><li><p>-D 指定将要登录的具体的数据库<br>mysql -uroot -D test -p123456  </p></li><li><p>本地连接mysql，-S  指定套接字位置<br>mysql -u root -p -S /var/lib/mysql/mysql.sock</p></li><li><p>远程连接mysql，-P 指定mysql服务对应的端口<br>mysql -u root -p 123456 -h 192.168.1.1 -P 3306</p></li><li><p>连接数据库的同时执行对应命令，并返回结果，不进入mysql 提示符<br>mysql -uroot -p123456 -e  ‘use mysql; select user,host,passwd from user;’<br>mysql -uroot -p123456 -e ‘create database if not exists testdb;show databases;’</p></li></ul><h3 id="Help"><a href="#Help" class="headerlink" title="Help"></a>Help</h3><ul><li>help create </li><li>help create databases</li><li>help contents</li><li>help ‘Data Types’</li></ul><h3 id="mysql的属性、状态、变量"><a href="#mysql的属性、状态、变量" class="headerlink" title="mysql的属性、状态、变量"></a>mysql的属性、状态、变量</h3><ul><li>mysql> status</li><li><p>系统变量：配置了mysql的运行环境属性</p></li><li><p>全局变量：global variables ,作用域为整个mysql服务器<br>show  global variables；<br>版本相关：    show global variables  like ‘%version%’ ;<br>字符集相关：    show global variables where variable_name like ‘character%’;<br>日志是否关闭：    show global variables where variable_name like ‘%log%’ and value=’off’;</p></li><li><p>会话变量：session variables，作用域为当前会话<br>show session variables;<br>show variables; </p></li><li><p>查看单个全局系统变量或者会话系统变量：<br>select @@[global | session].system_var_name;<br>select @@global.pid_file;<br>select @@session.warning_count;</p></li><li><p>状态变量：mysql运行中的状态信息，不能设置。<br>查询mysql运行中信息和状态：状态变量也分为全局级别与会话级别<br>show  status;<br>show global status;<br>show session status;<br>show status where variable_name like ‘Uptime%’;</p></li><li><p>在写储存过程中，调用系统变量的值：<br>@@GLOBAL.var_name<br>@@SESSION.var_name<br>@@var_name 表示优先从会话级别获取变量值</p></li><li><p>修改变量值/设定变量值:<br>① 运行时修改：是否立即生效取决于修改的变量的类型，set 命令，运行时修改变量<br>运行时修改global级别的变量：对修改之前建立的会话没有影响，仅对修改后新建立的会话有效<br>运行时修改session级别的变量：仅对当前会话有效，且立即生效<br>② 配置文件修改：重启后生效。<br>例：<br>③ set @@session.autocommit=0;<br>设置系统变量语法总结：<br>set global.var_name = value;<br>set @@global.var_name = value;<br>set session.var_name = value;<br>set @@session.var_name = value;<br>set var_name = value; 不指定级别表示默认为设置会话级别的变量。</p></li></ul><h2 id="MySQL-用户"><a href="#MySQL-用户" class="headerlink" title="MySQL 用户"></a>MySQL 用户</h2><h3 id="MySQL-用户管理"><a href="#MySQL-用户管理" class="headerlink" title="MySQL 用户管理"></a>MySQL 用户管理</h3><ul><li>mysql 的用户格式：    usernmae@host<br>host: 主机名 或者 IP ，mysql 认为主机名 和 IP地址属于不同的主机。<br>通配符：</li><li><p>： 表示任意单个字符<br>%： 表示任意长度的任意字符<br>root@’10.1.%.%’    root用户可以通过10.1这个网段远程登录</p></li><li><p>查询用户<br>use mysql<br>select user,host,passwd from user;</p></li><li><p>创建用户<br>① create user ‘zabbix_proxy‘@’localhost’ identified by ‘zabbix_asp_2017’;<br>② 直接在mysql库的user 表中插入一条记录。（设置了严格的sql-mode  后无法使用）<br>insert  into mysql.user(user,host,passwd) values(‘pan’,’192.168.%.%’,passwd(‘123456’));<br>③ 在授权数据库的同时，如果对应的用户不存在，那么mysql会自动创建对应的用户。<br>grant all on pan.*to <a href="mailto:pan@127.0.0.1" target="_blank" rel="noopener">pan@127.0.0.1</a> identfied by ‘123456’;</p></li><li><p>删除用户<br>① delete 语句删除mysql.user 表中的用户对应的记录，有相关信息残留。<br>delete from mysql.user where user=’pan’ and host=’127.0.0.1’;<br>② drop user <a href="mailto:pan@127.0.0.1" target="_blank" rel="noopener">pan@127.0.0.1</a>     用户与用户对应的所有权限将被删除。</p></li><li><p>重命名用户：<br>rename user oldname to newname;</p></li></ul><h3 id="MySQL-密码管理"><a href="#MySQL-密码管理" class="headerlink" title="MySQL 密码管理"></a>MySQL 密码管理</h3><ul><li><p>更改用户名密码，官方推荐使用alter<br>ALTER USER test@’%’ IDENTIFIED BY ‘123456’;</p></li><li><p>update mysql.user set authentication_string=password(“新密码”) where User=”test” and Host=”localhost”;<br>flush privileges;</p></li><li><p>忘记root密码<br>① vi /etc/my.cnf，在[mysqld]中添加<br>skip-grant-tables<br>② 重启mysql : systemctl restart mysqld.service<br>③ mysql -uroot -p<br>④ use mysql;<br>⑤ 修改root密码：<br>update user set authentication_string=password(‘123456’) where user=’root’;<br>flush privileges;<br>⑥ 删除第1部增加的配置信息<br>skip-grant-tables<br>⑦ 重启mysql ： systemctl restart mysqld.service</p></li></ul><h2 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h2><ul><li><p>授权命令：<br>GRANT ALL privileges on db.tbl to ‘username‘@’host’ identified by ‘passwd’;<br>db 数据库名  tbl 表名    可以使用<em>通配。<br>示例：给本地用户授权某个数据库的所有权限<br>grant all privileges on pandb.</em> to pan@localhost identified by ‘123456’;<br>grant all on pandb.* to pan@localhost identified by ‘123456’;            privileges 关键字可省</p></li><li><p>给远程用户授权<br>grant all privileges on panthink.* to pan@’192.168.%.%’ identified by ‘123456’;<br>flush privileges;</p></li><li><p>授权用户某个数据库的某个权限，比如，只授权用户对于某个数据<br>grant select privileges on panthink.* to pan@’192.168.%.%‘；</p></li><li><p>授权某个数据库多个权限：<br>grant insert,delete,update,select on panthink.* to pan@’192.168.%.%’;</p></li><li><p>授权给多个用户：<br>grant select on mydb.* to pan@locakhost,pan2@localhost;</p></li><li><p>对某张表的某个字段授权：<br>grant select(name,age) on pan.students to pan@localhost;</p></li><li><p>授权test函数，用function关键字指明被操作的对象是函数：<br>grant execute on fuction panthink.test to pan@’192.168.%.%’;</p></li><li><p>强制用户使用ssl建立会话<br>grant useage on <em>.</em>  to ‘zabbix‘@’222.222.222.222’ require ssl;<br>取消ssl 连接限制<br>grant useage on <em>.</em>  to ‘zabbix‘@’222.222.222.222’ require none;</p></li><li><p>赋予用户授权的权限<br>授权zabbix用户db01 的 select权限，同时zabbix 用户也能将此权限授予给其他用户<br>grant select on db01.*  to ‘zabbix‘@’192.168.%.%’  with grant option;</p></li><li><p>查看授权：<br>从用户：    show grants for 用户名；<br>从数据库：select * from mysql.db where db=”要查看的数据库“；</p></li><li><p>删除授权：<br>revoke ‘要删除的权限’ on db.tb from user@host;<br>删除<a href="mailto:zabbix@192.168.1.1" target="_blank" rel="noopener">zabbix@192.168.1.1</a> 用户对于word数据库的所有权限:<br>revoke all on word.* from <a href="mailto:zabbix@192.168.1.1" target="_blank" rel="noopener">zabbix@192.168.1.1</a>;</p></li></ul><h2 id="库管理"><a href="#库管理" class="headerlink" title="库管理"></a>库管理</h2><ul><li><p>创建数据库<br>create database if not exists testdb charaacter set utf16;</p></li><li><p>查看数据库<br>show databases;<br>show create database testdb;<br>查看可用的字符集的命令<br>show character set;<br>查看排序方式的命令<br>show collation；</p></li><li><p>修改数据库<br>alter database testdb character set utf 8;<br>修改数据库的字符集，并设置为默认字符集，数据库中的表都会继承此字符集。<br>alter database testdb default character set utf8; </p></li><li><p>删除数据库<br>drop database if exists testdb;</p></li><li><p>数据库导出<br>mysqldump -u user_name -p database_name > 导出的文件名</p></li><li><p>导出一个数据库结构（不包含数据）<br>mysqldump -u user_name -p -d –add-drop-table database_name > outfile_name.sql</p></li><li><p>带语言参数导出<br>mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name > outfile_name.sql</p></li></ul><h2 id="表管理"><a href="#表管理" class="headerlink" title="表管理"></a>表管理</h2><ul><li><p>查看表的状态<br>show table status where name like ‘%tt%’;<br>desc table_name;<br>查看某张表创建时对应的sql 语句<br>show create table table_name;<br>复制表，但字段的约束和表的索引会丢失。<br>create table testtb2 select * from students;<br>完全的复制表结构<br>create table testdb3 like students;                    </p></li><li><p>修改表：<br>重命名表<br>alter table test1 rename as test2;<br>为表添加字段<br>alter  table ttt add cloumn age int;<br>alter table ttt add age int;        //  省略cloumn 默认为操作列。<br>添加字段设定相应的约束：<br>alter table ttt add age int not null default 0;<br>alter table ttt add cloumn age int not null default 0;<br>添加字段，指定字段在表中的位置：<br>alter table ttt add id int first;<br>alter table hosts add  categoryof varchar(200)  DEFAULT NULL after templateid;<br>删除字段：<br>alter table ttt drop stuname;<br>重命名字段：<br>alter table tsettb4 change name name1 char(20);<br>修改字段类型：<br>alter table testtb change age age char(20);<br>alter table testtb modify age int;    // modify 不能修改字段名称。</p></li><li><p>导出单个数据表结构和数据<br>mysqldump -u user_name -p database_name table_name > outfile_name.sql</p></li><li><p>导出单个数据表结构（不包含数据）<br>mysqldump -h localhost -uroot -p123456  -d database table > dump.sql</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「管理」「用户」「授权」「库」「表」
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux Awk</title>
    <link href="http://yoursite.com/2018/11/06/Linux/04.Awk/"/>
    <id>http://yoursite.com/2018/11/06/Linux/04.Awk/</id>
    <published>2018-11-06T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.745Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>awk是linux环境下的一个命令行工具，但是由于awk强大的能力，我们可以为awk工具传递一个字符串，该字符串的内容类似一种编程语言的语法，我们可以称其为Awk语言，而awk工具本身则可以看作是Awk语言的解析器。<br>就好比python解析器与Python语言的关系。我们一般使用awk来做什么，awk又适合做什么工作呢。由于awk天生提供对文件中文本分列进行处理。<br>所以如果一个文件中的每行都被特定的分隔符(常见的是空格)隔开，我们可以将这个文件看成是由很多列的文本组成，<br>这样的文件最适合用awk进行处理，其实awk在工作中很多时候被用来处理log文件，进行一些统计工作等。</p><h2 id="awk-基础"><a href="#awk-基础" class="headerlink" title="awk 基础"></a>awk 基础</h2><p>awk [options] ‘Pattern{Action}’ file  </p><h3 id="BEGIN、END"><a href="#BEGIN、END" class="headerlink" title="BEGIN、END"></a>BEGIN、END</h3><p>awk ‘BEGIN{print “aaa”,”bbb”} { print $1,$2}’ test<br>awk ‘{print $1,$2} END{print “ccc”,”ddd”}’ test   </p><h3 id="awk-分隔符："><a href="#awk-分隔符：" class="headerlink" title="awk 分隔符："></a>awk 分隔符：</h3><ul><li><p>输入分割符：FS<br>awk -F# ‘{print $1,$2}’ test<br>awk -v FS=’#’ ‘{print $1,$2}’ test  </p></li><li><p>输出分隔符:OFS<br>awk -v OFS=”+++” ‘{print $1,$2}’ test<br>awk -v FS=”#” -v OFS=”—“ ‘{print $1,$2}’ test  </p></li></ul><h3 id="awk-变量："><a href="#awk-变量：" class="headerlink" title="awk  变量："></a>awk  变量：</h3><ul><li><p>awk常用的内置变量：<br>FS ： 输入字段分割符<br>OFS： 输出字段分隔符<br>RS：输入换行符<br>ORS：输出换行符<br>NF：字段数量<br>NR：行号<br>FNR：各文件分别计数的行号<br>FILENAME: 当前文件名<br>ARGC：命令行参数的个数<br>ARGV：数组  </p></li><li><p>NR、FNR<br>awk ‘{print NR,$0}’ test<br>awk ‘{print FNR,$0}’ test</p></li><li><p>内置变量RS<br>awk -v RS=” “ ‘{print NR,$0}’ test </p></li><li><p>内置变量 ORS<br>awk -v ORS=”+++” ‘{print NR,$0}’ test </p></li><li><p>内置变量FILENAME<br>awk ‘{print FILENAME,$0}’ test</p></li><li><p>自定义变量<br>awk -v myvar=”test” ‘BEGIN{print myvar}’<br>awk ‘BEGIN{myvar=”ttt”;print myvar}‘<br>awk ’BEGIN{myvar1=”111”;myvar2=”222”;print myvar1,myvar2}’</p></li></ul><h3 id="awk-格式化："><a href="#awk-格式化：" class="headerlink" title="awk 格式化："></a>awk 格式化：</h3><p>awk中如果输出字符的话，有两种处理方式。printf和print<br>printf：可以自定义输出的模式，另外输出内容之后不自动换行<br>print：输出内容之后自动换行<br>awk ‘{printf “第一列：%s 第二列 %s\n”,$1,$2}’ test<br>awk ‘BEGIN{printf “%s\n%s\n%s\n%s\n%s\n”,1,2,3,4,5}’<br>总结：<br>使用printf 动作输出的文本不会换行，如果需要换行，可以在对应的格式替换符 后 加入  \n  进行转义。<br>使用printf 动作时，格式中的格式替换符必须与被格式化的文本一 一 对应。  </p><h3 id="awk-模式："><a href="#awk-模式：" class="headerlink" title="awk 模式："></a>awk 模式：</h3><ul><li><p>正则模式：<br>awk ‘/^root/{print  $0}’ /etc/passwd<br>awk ‘/\/bin\/bash$/ {print $0}’ /etc/passwd     转义<br>使用（x，y） 这种次数匹配的正则表达式时，需要配合   –posix  或者  –re-interval 选项。<br>字母e最少连续出现两次，最多只能连续出现三次:<br>awk –posix  ‘/he(2,3)y/ {print $0}’ test<br>正则模式：<br>awk ‘/正则1/{动作}’  /some/file      </p></li><li><p>行范围模式：<br>awk ‘/LEE/,/KEKEK/{print $0}’ test<br>awk ‘/正则1/,/正则2/{动作}’ /some/file<br>awk ‘NR>= 3 && NR<=6’ {print $0}’ test </p></li></ul><h3 id="awk-动作"><a href="#awk-动作" class="headerlink" title="awk 动作"></a>awk 动作</h3><ul><li><p>if…else<br>awk ‘{ if(NR==1) {print $0}} ‘ test<br>awk -F “:” ‘{if($3<500){print $1,“系统用户“} else { print ￥1，”普通用户“}} ‘  /etc/passwd  </p></li><li><p>for…in<br>awk ‘BEGIN{for (i=1;i<=6;i++){print i}}’<br>awk ‘BEGIN{for (i=0;i<6;i++} {if (i==3)(continue); print i}}  </p></li><li><p>while<br>awk -v i=1 ‘BEGIN{ while(i<=5){print i;i++} }’<br>awk ‘BEGIN(i=1;while(i<=5){print i:i++}}’<br>awk ‘BEGIN{ do{print “test”;i++} while(i<=5) }’  </p></li><li><p>exit<br>awk “BEGIN{print 1;exit;print 2;print 3}’<br>当执行了exit语句后，如果使用了end模式，将直接执行END模式中的动作，其他动作将不会再执行；如果没有使用END模式，当执行了exit语句后，将直接退出整个awk命令。  </p></li></ul><h3 id="awk-数组-关联数组-："><a href="#awk-数组-关联数组-：" class="headerlink" title="awk 数组(关联数组)："></a>awk 数组(关联数组)：</h3><ul><li><p>定义<br>下标为数字（默认转化为字符串）：<br>awk ‘BEGIN{arr[0]=”aaa”;arr[1]=”bbb”;print arr[0]}’<br>换行符  \   。<br>下标为字符串：<br>awk ‘BEGIN{arr[“earr”]=”aaa”;arr[“kk”]=”bbb”;print arr[“kk”]}’</p></li><li><p>delete<br>删除数组中的元素：<br>awk ‘BEGIN{arr[“laker”]=”kobe”;print arr[“laker”]; delete arr[“laker”];print arr[“laker”]}’<br>删除整个数组 ：delete  arr</p></li><li><p>循环<br>awk ‘BEGIN {arr[“laker”]=”kobe”;arr[“cli”]=”james”;for(i in arr） {print i,arr[i] } } ‘</p></li></ul><h3 id="awk-函数"><a href="#awk-函数" class="headerlink" title="awk 函数"></a>awk 函数</h3><p>rand函数 、 srand函数 、int函数 ：<br>rand 函数生成随机数，需配合srand函数，否则rand 函数返回的值将一直不变。<br>awk ‘BEGIN{srand();print rand()}’<br>字符串函数：gsub  sub<br>awk ‘{gsub(“l”,”L”,$1);print $0}’ test        $1列的小写l 都替换成大写 L。</p><p>length 函数： 获取指定字符串的长度<br>awk ‘{for(1=1;i<=NF;i++) {print $i,length($i）}‘ test</p><p>awk ‘{print $0,length()}’ test        省略参数</p><p>index 函数： 获取字符位置。<br>awk ‘{print index($0,”Lee”)}’ test</p><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>awk -F: ‘{usetype=$3<500?”系统用户“：”普通用户”;print $1,usertype}’ /etc/passwd</p><p>awk -F: ‘{$3<500?a++:b++} END{print a,b}’ /etc/passwd</p><p>awk ‘i=!i’ test        输出奇数行<br>awk ‘!(i=!i)’ test        输出偶数行</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「Awk」
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Sed</title>
    <link href="http://yoursite.com/2018/11/05/Linux/03.Sed/"/>
    <id>http://yoursite.com/2018/11/05/Linux/03.Sed/</id>
    <published>2018-11-05T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Linux sed 命令是利用脚本来处理文本文件。<br>sed 可依照脚本的指令来处理、编辑文本文件。<br>Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p><ul><li>sed 命令的选项<br>sed [选项] [动作]</li></ul><h2 id="选项与参数"><a href="#选项与参数" class="headerlink" title="选项与参数"></a>选项与参数</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。</span><br><span class="line">-f<script文件>或--file=<script文件> 以选项中指定的script文件来处理输入的文本文件。</span><br><span class="line">-h或--help 显示帮助。</span><br><span class="line">-n或--quiet或--silent 仅显示script处理后的结果。</span><br><span class="line">-V或--version 显示版本信息。</span><br></pre></td></tr></tbody></table></figure><h2 id="动作说明："><a href="#动作说明：" class="headerlink" title="动作说明："></a>动作说明：</h2><p>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～<br>c ：取代， 以行为单位的替换，这些字串可以取代 n1,n2 之间的行！<br>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；<br>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；<br>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～<br>s ：取代，可以直接进行取代的工作哩！</p><h3 id="增、删"><a href="#增、删" class="headerlink" title="增、删"></a>增、删</h3><ul><li><p>在testfile文件的第四行后添加一行，并将结果输出到标准输出：<br>[root@www ~]# sed -e ‘4a\newLine’ testfile </p></li><li><p>以行为单位的新增/删除<br>[root@www ~]# nl /etc/passwd | sed ‘2,5d’</p></li><li><p>只要删除第 2 行<br>nl /etc/passwd | sed ‘2d’ </p></li><li><p>要删除第 3 到最后一行<br>nl /etc/passwd | sed ‘3,$d’ </p></li><li><p>在第二行后加上『drink tea?』字样！<br>[root@www ~]# nl /etc/passwd | sed ‘2a drink tea’</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">2 bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">drink tea</span><br><span class="line">3 daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br></pre></td></tr></tbody></table></figure></li><li><p>在第二行前新增<br>[root@www ~]# nl /etc/passwd | sed ‘2i drink tea’ </p></li><li><p>增加两行以上，在第二行后面加入两行字，例如 Drink tea or ….. 与 drink beer?<br><code>[root@www ~]# nl /etc/passwd | sed '2a Drink tea or ......\ drink beer ?'</code></p></li></ul><h3 id="替换、显示"><a href="#替换、显示" class="headerlink" title="替换、显示"></a>替换、显示</h3><ul><li><p>以行为单位的替换<br>将第2-5行的内容取代成为『No 2-5 number』呢？</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed '2,5c No 2-5 number'</span><br><span class="line">1 root:x:0:0:root:/root:/bin/bash</span><br><span class="line">No 2-5 number</span><br><span class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</span><br></pre></td></tr></tbody></table></figure></li><li><p>仅列出 /etc/passwd 文件内的第 5-7 行<br>[root@www ~]# nl /etc/passwd | sed -n ‘5,7p’</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">6 sync:x:5:0:sync:/sbin:/bin/sync</span><br><span class="line">7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br></pre></td></tr></tbody></table></figure></li><li><p>数据的搜寻并显示<br>搜索 /etc/passwd有root关键字的行<br>[root@www ~]# nl /etc/passwd | sed ‘/root/p’</p></li></ul><ul><li><p>数据的搜寻并删除<br>删除/etc/passwd所有包含root的行，其他行输出<br>[root@www ~]# nl /etc/passwd | sed  ‘/root/d’</p></li><li><p>数据的搜寻并替换<br><code>sed 's/要被取代的字串/新的字串/g'</code><br>仅仅对第一行进行了替换操作：<br>sed ‘1s/aa/AA/g’ test.txt<br>使用m,n的限定，例如：<br>sed ‘5,$s/aa/AA/g’ test.txt<br>使用正则表达式限定符合条件的行：<br>sed ‘/^[0-9]/s/aa/AA/g’ test.txt<br>注意：<br>s/待替换的字符串/新字符串/ 这种格式中 / 作为分隔符并不是一定的，当使用s命令时候，<br>我们可以使用别的分隔符，实际上s后面紧接着的字符就是分隔符，所以不一定是 / 符号。例如：<br>echo ‘aabbccaadd’ | sed s#aa#AA#g<br>输出：<br>AAbbccAAdd<br>这里s命令后面跟着的#符号被当作分隔符了</p></li></ul><h3 id="多点编辑"><a href="#多点编辑" class="headerlink" title="多点编辑"></a>多点编辑</h3><ul><li>删除/etc/passwd第三行到末尾的数据，并把bash替换为blueshell  <figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# nl /etc/passwd | sed -e '3,$d' -e 's/bash/blueshell/'</span><br><span class="line">1  root:x:0:0:root:/root:/bin/blueshell</span><br><span class="line">2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br></pre></td></tr></tbody></table></figure></li></ul><p>-e表示多点编辑，第一个编辑命令删除/etc/passwd第三行到末尾的数据，第二条命令搜索bash替换为blueshell。</p><h3 id="将修改应用到文件中"><a href="#将修改应用到文件中" class="headerlink" title="将修改应用到文件中"></a>将修改应用到文件中</h3><ul><li><p>利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !<br>[root@www ~]# sed -i ‘s/.$/!/g’ regular_express.txt</p></li><li><p>利用 sed 直接在 regular_express.txt 最后一行加入 # This is a test:<br>[root@www ~]# sed -i ‘$a # This is a test’ regular_express.txt<br>$ 代表的是最后一行，而 a 的å¨作是新增</p></li></ul><h3 id="sed正则中的元字符"><a href="#sed正则中的元字符" class="headerlink" title="sed正则中的元字符"></a>sed正则中的元字符</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ 表示行尾 </span><br><span class="line">^ 表示行首</span><br><span class="line">[a-z0-9]表示字符范围</span><br><span class="line">[^]表示除了字符集中的字符以外的字符 </span><br><span class="line">sed的正则中  \(\)  和 \{m,n\} 需要转义 </span><br><span class="line">. 表示任意字符  </span><br><span class="line">* 表示零个或者多个  </span><br><span class="line">\+ 一次或多次　　</span><br><span class="line">\? 零次或一次    </span><br><span class="line">\| 表示或语法</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「Sed」
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Grep</title>
    <link href="http://yoursite.com/2018/11/04/Linux/02.Grep/"/>
    <id>http://yoursite.com/2018/11/04/Linux/02.Grep/</id>
    <published>2018-11-04T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>　　grep (global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来)是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p><p>　　Unix的grep家族包括grep、egrep和fgrep。egrep和fgrep的命令只跟grep有很小不同。egrep是grep的扩展，支持更多的re元字符， fgrep就是fixed grep或fast grep，它们把所有的字母都看作单词，也就是说，正则表达式中的元字符表示回其自身的字面意义，不再特殊。linux使用GNU版本的grep。它功能更强，可以通过-G、-E、-F命令行选项来使用egrep和fgrep的功能。</p><p>　　grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。<br>　　<br>命令格式：grep [option] pattern file</p><h2 id="grep-选项"><a href="#grep-选项" class="headerlink" title="grep 选项"></a>grep 选项</h2><h3 id="grep的常用选项："><a href="#grep的常用选项：" class="headerlink" title="grep的常用选项："></a>grep的常用选项：</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-V： 打印grep的版本号  </span><br><span class="line">-E： 解释PATTERN作为扩展正则表达式，也就相当于使用egrep。 或操作    </span><br><span class="line">-F :   解释PATTERN作为固定字符串的列表，由换行符分隔，其中任何一个都要匹配。也就相当于使用fgrep。  </span><br><span class="line">-G:   将范本样式视为普通的表示法来使用。这是默认值。加不加都是使用grep。</span><br></pre></td></tr></tbody></table></figure><h3 id="匹配控制选项："><a href="#匹配控制选项：" class="headerlink" title="匹配控制选项："></a>匹配控制选项：</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-e :  使用PATTERN作为模式。这可以用于指定多个搜索模式，或保护以连字符（ - ）开头的图案。指定字符串做为查找文件内容的样式。     </span><br><span class="line">-f :  指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。  </span><br><span class="line">-i :  搜索时候忽略大小写  </span><br><span class="line">-v:  反转匹配，选择没有被匹配到的内容。  </span><br><span class="line">-w：匹配整词，精确地单词,单词的两边必须是非字符符号(即不能是字母数字或下划线)  </span><br><span class="line">-x：仅选择与整行完全匹配的匹配项。精确匹配整行内容(包括行首行尾那些看不到的空格内容都要完全匹配)  </span><br><span class="line">-y：此参数的效果和指定“-i”参数相同。</span><br></pre></td></tr></tbody></table></figure><h3 id="一般输出控制选项："><a href="#一般输出控制选项：" class="headerlink" title="一般输出控制选项："></a>一般输出控制选项：</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-c： 抑制正常输出;而是为每个输入文件打印匹配线的计数。 </span><br><span class="line">--color [= WHEN]：让关键字高亮显示，如--color=auto  </span><br><span class="line">-L：列出文件内容不符合指定的范本样式的文件名称  </span><br><span class="line">-l : 列出文件内容符合指定的范本样式的文件名称。  </span><br><span class="line">-m num：当匹配内容的行数达到num行后,grep停止搜索,并输出停止前搜索到的匹配内容  </span><br><span class="line">-o: 只输出匹配的具体字符串,匹配行中其他内容不会输出  </span><br><span class="line">-q：安静模式,不会有任何输出内容,查找到匹配内容会返回0,未查找到匹配内容就返回非0  </span><br><span class="line">-s：不会输出查找过程中出现的任何错误消息，-q和-s选项因为与其他系统的grep有兼容问题，shell脚本应该避免使用-q和-s，并且应该将标准和错误输出重定向到/dev/null 代替。</span><br></pre></td></tr></tbody></table></figure><h3 id="输出线前缀控制："><a href="#输出线前缀控制：" class="headerlink" title="输出线前缀控制："></a>输出线前缀控制：</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-b：输出每一个匹配行(或匹配的字符串)时在其前附加上偏移量(从文件第一个字符到该匹配内容之间的字节数)  </span><br><span class="line">-H：在每一个匹配行之前加上文件名一起输出(针对于查找单个文件),当查找多个文件时默认就会输出文件名  </span><br><span class="line">-h：禁止输出上的文件名的前缀。无论查找几个文件都不会在匹配内容前输出文件名  </span><br><span class="line">--label = LABEL：显示实际来自标准输入的输入作为来自文件LABEL的输入。这是特别在实现zgrep等工具时非常有用，例如gzip -cd foo.gz | grep --label = foo -H的东西。看到 也是-H选项。  </span><br><span class="line">-n：输出匹配内容的同时输出其所在行号。  </span><br><span class="line">-T：初始标签确保实际行内容的第一个字符位于制表位上，以便对齐标签看起来很正常。在匹配信息和其前的附加信息之间加入tab以使格式整齐。</span><br></pre></td></tr></tbody></table></figure><h3 id="上下文线控制选项："><a href="#上下文线控制选项：" class="headerlink" title="上下文线控制选项："></a>上下文线控制选项：</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-A num：匹配到搜索到的行以及该行下面的num行  </span><br><span class="line">-B num：匹配到搜索到的行以及该行上面的num行  </span><br><span class="line">-C num：匹配到搜索到的行以及上下各num行</span><br></pre></td></tr></tbody></table></figure><h3 id="文件和目录选择选项："><a href="#文件和目录选择选项：" class="headerlink" title="文件和目录选择选项："></a>文件和目录选择选项：</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-a： 处理二进制文件，就像它是文本;这相当于--binary-files = text选项。不忽略二进制的数据。    </span><br><span class="line"> --binary-files = TYPE：如果文件的前几个字节指示文件包含二进制数据，则假定该文件为类型TYPE。默认情况下，TYPE是二进制的，grep通常输出一行消息二进制文件匹配，或者如果没有匹配则没有消息。如果TYPE不匹配，grep假定二进制文件不匹配;这相当于-I选项。如果TYPE是文本，则grep处理a二进制文件，如果它是文本;这相当于-a选项。警告：grep --binary-files = text可能会输出二进制的垃圾，如果输出是一个终端和如果可能有讨厌的副作用终端驱动程序将其中的一些解释为命令。</span><br><span class="line"></span><br><span class="line">-D：如果输入文件是设备，FIFO或套接字，请使用ACTION处理。默认情况下，读取ACTION，这意味着设备被读取，就像它们是普通文件一样。如果跳过ACTION，设备为 默默地跳过。  </span><br><span class="line"></span><br><span class="line">-d:  如果输入文件是目录，请使用ACTION处理它。默认情况下，ACTION是读的，这意味着目录被读取，就像它们是普通文件一样。如果跳过ACTION，目录将静默跳过。如果ACTION是recurse，grep将递归读取每个目录下的所有文件;这是相当于-r选项。  </span><br><span class="line"></span><br><span class="line">--exclude=GLOB：跳过基本名称与GLOB匹配的文件（使用通配符匹配）。文件名glob可以使用*，？和[...]作为通配符，和\引用通配符或反斜杠字符。搜索其文件名和GLOB通配符相匹配的文件的内容来查找匹配使用方法:grep -H --exclude=c* "old" ./*  c*是通配文件名的通配符./* 指定需要先通配文件名的文件的范围,必须要给*,不然就匹配不出内容,(如果不给*,带上-r选项也可以匹配)  </span><br><span class="line"></span><br><span class="line">--exclude-from = FILE：在文件中编写通配方案,grep将不会到匹配方案中文件名的文件去查找匹配内容  </span><br><span class="line"></span><br><span class="line">--exclude-dir = DIR：匹配一个目录下的很多内容同时还要让一些子目录不接受匹配,就使用此选项。  </span><br><span class="line"></span><br><span class="line"> --include = GLOB：仅搜索其基本名称与GLOB匹配的文件（使用--exclude下所述的通配符匹配）。  </span><br><span class="line"></span><br><span class="line">-R ,-r :以递归方式读取每个目录下的所有文件; 这相当于-d recurse选项。</span><br></pre></td></tr></tbody></table></figure><h3 id="其他选项："><a href="#其他选项：" class="headerlink" title="其他选项："></a>其他选项：</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--line-buffered： 在输出上使用行缓冲。这可能会导致性能损失。  </span><br><span class="line">--mmap：启用mmap系统调用代替read系统调用  </span><br><span class="line">-U：将文件视为二进制。  </span><br><span class="line">-z：将输入视为一组行，每一行由一个零字节（ASCII NUL字符）而不是a终止新队。与-Z或--null选项一样，此选项可以与排序-z等命令一起使用来处理任意文件名。</span><br></pre></td></tr></tbody></table></figure><h2 id="选项简述"><a href="#选项简述" class="headerlink" title="选项简述"></a>选项简述</h2><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-a   --text   #不要忽略二进制的数据。 将 binary 文件以 text 文件的方式搜寻数据 </span><br><span class="line">-A<显示行数>   --after-context=<显示行数>   #除了显示符合范本样式的那一列之外，并显示该行之后的内容。   </span><br><span class="line">-b   --byte-offset   #在显示符合样式的那一行之前，标示出该行第一个字符的编号。   </span><br><span class="line">-B<显示行数>   --before-context=<显示行数>   #除了显示符合样式的那一行之外，并显示该行之前的内容。   </span><br><span class="line">-c    --count   #计算符合样式的行数。   </span><br><span class="line">-C<显示行数>    --context=<显示行数>或-<显示行数>   #除了显示符合样式的那一行之外，并显示该行之前后的内容。   </span><br><span class="line">-d <动作>      --directories=<动作>   #当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。   </span><br><span class="line">-e<范本样式>  --regexp=<范本样式>   #指定字符串做为查找文件内容的样式。   </span><br><span class="line">-E      --extended-regexp   #将样式为延伸的普通表示法来使用。   </span><br><span class="line">-f<规则文件>  --file=<规则文件>   #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。   </span><br><span class="line">-F   --fixed-regexp   #将样式视为固定字符串的列表。   </span><br><span class="line">-G   --basic-regexp   #将样式视为普通的表示法来使用。   </span><br><span class="line">-h   --no-filename   #在显示符合样式的那一行之前，不标示该行所属的文件名称。   </span><br><span class="line">-H   --with-filename   #在显示符合样式的那一行之前，表示该行所属的文件名称。   </span><br><span class="line">-i    --ignore-case   #忽略字符大小写的差别。   </span><br><span class="line">-l    --file-with-matches   #列出文件内容符合指定的样式的文件名称。   </span><br><span class="line">-L   --files-without-match   #列出文件内容不符合指定的样式的文件名称。   </span><br><span class="line">-n   --line-number   #在显示符合样式的那一行之前，标示出该行的列数编号。   </span><br><span class="line">-q   --quiet或--silent   #不显示任何信息。   </span><br><span class="line">-r   --recursive   #此参数的效果和指定“-d recurse”参数相同。   </span><br><span class="line">-s   --no-messages   #不显示错误信息。   </span><br><span class="line">-v   --revert-match   #显示不包含匹配文本的所有行。   </span><br><span class="line">-V   --version   #显示版本信息。   </span><br><span class="line">-w   --word-regexp   #只显示全字符合的列。   </span><br><span class="line">-x    --line-regexp   #只显示全列符合的列。   </span><br><span class="line">-y   #此参数的效果和指定“-i”参数相同。</span><br><span class="line">--color=auto ：可以将找到的关键词部分加上颜色的显示</span><br></pre></td></tr></tbody></table></figure><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="常用用法"><a href="#常用用法" class="headerlink" title="常用用法"></a>常用用法</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">grep -i pattern files ：不区分大小写地搜索。默认情况区分大小写，</span><br><span class="line">grep -l pattern files ：只列出匹配的文件名，</span><br><span class="line">grep -L pattern files ：列出不匹配的文件名，</span><br><span class="line">grep -w pattern files ：只匹配整个单词，而不是字符串的一部分（如匹配‘magic’，而不是‘magical’），</span><br><span class="line">grep -C number pattern files ：匹配的上下文分别显示[number]行，</span><br><span class="line">grep pattern1 | pattern2 files ：显示匹配 pattern1 或 pattern2 的行，</span><br><span class="line">grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。</span><br><span class="line"></span><br><span class="line">这里还有些用于搜索的特殊符号：</span><br><span class="line">< 和 > 分别标注单词的开始与结尾。</span><br><span class="line">例如：</span><br><span class="line">grep man * 会匹配 ‘Batman’、‘manic’、‘man’等，</span><br><span class="line">grep \'<man\' * 匹配‘manic’和‘man’，但不是‘Batman’，</span><br><span class="line">grep \'<man>\' 只匹配‘man’，而不是‘Batman’或‘manic’等其他的字符串。</span><br><span class="line">\'^\'：指匹配的字符串在行首，</span><br><span class="line">\'$\'：指匹配的字符串在行尾，</span><br><span class="line">如果您不习惯命令行参数，可以试试图形界面的‘grep’，如 reXgrep 。这个软件提供 AND、OR、NOT 等语法，还有漂亮的按钮 :-) 。如果您只是需要更清楚的输出，不妨试试 fungrep 。</span><br><span class="line"></span><br><span class="line">.grep 搜索字符串</span><br><span class="line">命令格式:</span><br><span class="line">grep string filename</span><br><span class="line">寻找字串的方法很多，比如说我想找所有以M开头的行.此时必须引进pattern的观念.</span><br><span class="line">说明：</span><br><span class="line">^M 以M开头的行，^表示开始的意思</span><br><span class="line">M$ 以M结尾的行，$表示结束的意思</span><br><span class="line">^[0-9] 以数字开始的行，[]内可列举字母</span><br><span class="line">^[124ab] 以1,2,4,a,或b开头的行</span><br><span class="line">^b.503 句点表示任一字母</span><br><span class="line">* 星号表示0个以上的字母(可以没有)</span><br><span class="line">+ 加号表示1个以上的字母</span><br><span class="line">. 斜线可以去掉特殊意义</span><br><span class="line"><eg> cat passwd | grep ^b 列出大学部有申请帐号者名单</span><br><span class="line">cat passwd | grep ^s 列出交换学生申请帐号者名单</span><br><span class="line">cat passwd | grep \'^b.503\' 列出电机系各年级...</span><br><span class="line">grep \'^.\' myfile.txt 列出所有以句点开头的行</span><br></pre></td></tr></tbody></table></figure><ul><li><p>查找指定进程个数<br>[root@loaclhost ~]# ps -ef|grep -c java<br>[root@loaclhost ~]# ps -ef|grep java -c</p></li><li><p>从文件中读取关键词进行搜索，默认是显示的是行<br>命令1：cat test.txt | grep -f test2.txt<br>命令2（显示行号）：cat test.txt | grep -nf test2.txt<br>作用：输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行，可用于按指定关键词（放到一个文件中）搜索日志文件。</p></li><li><p>将多个文件之间相同的行输出来<br>默认不加参数指定过滤关键字，外加多个文件，只是将多个文件里面有匹配的行输出<br>[root@loaclhost ~]# grep  “IPADDR” ifcfg-eth0  ifcfg-lo     </p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ifcfg-eth0:IPADDR=192.168.1.108</span><br><span class="line"></span><br><span class="line">ifcfg-lo:IPADDR=127.0.0.1</span><br></pre></td></tr></tbody></table></figure></li><li><p>将多个文件之间相同的行输出出来<br>[root@loaclhost ~]# grep -f 文件1 文件2<br>[root@loaclhost ~]# grep -f ifcfg-eth0  ifcfg-lo<br><code>ONBOOT=yes</code></p></li><li><p>只显示被模式匹配到的字符串，而不是整个行<br>命令：grep -o “you” ab.log<br>加上正则表达式，这样才是正确的用法，不用输出一整行，只是输出一小段<br>[root@loaclhost ~]# grep -o “root:.*0” /etc/passwd<br><code>root:x:0:0</code><br>[root@loaclhost ~]#  grep -o “root” -b   /etc/passwd</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0:root</span><br><span class="line"></span><br><span class="line">11:root</span><br><span class="line"></span><br><span class="line">17:root</span><br><span class="line"></span><br><span class="line">414:root</span><br></pre></td></tr></tbody></table></figure></li><li><p>从文件中查找关键词，忽略大小写，默认情况区分大小写<br>命令1：grep ‘linux’ test.txt<br>命令2（从多个文件中查找）：grep ‘linux’ test.txt test2.txt<br>命令3（忽略大小写）：grep -i  ‘linux’ test.txt<br>命令：find . -name “.log” | grep -i error | grep -vi “info”</p></li><li><p>grep不显示本身<br>命令：ps aux|grep [s]sh<br>不包含grep ssh这条命令:<br>ps aux | grep ssh | grep -v “grep”<br>将/etc/passwd，将没有出现 root 和nologin的行取出来:<br>grep -v root /etc/passwd | grep -v nologin  </p></li></ul><ul><li><p>递归查找子目录 -r<br>查找当前目录及其子目录下面包含匹配字符的文件</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># grep ‘ab’ * #在当前目录搜索带'ab'行的文件</span><br><span class="line"># grep -r ‘ab’ * #在当前目录及其子目录下搜索'ab'行的文件</span><br><span class="line"># grep -l -r ‘ab’ * #在当前目录及其子目录下搜索'ab'行的文件，但是不显示匹配的行，只显示匹配的文件</span><br><span class="line"># grep -nr BLOG* . # 查找子目录，匹配后输出行号，这里的点表示当前目录</span><br><span class="line"># grep -lr BLOG* . #查找子目录，匹配后只输出文件名</span><br><span class="line">查询不包含某个目录</span><br><span class="line">#grep -R --exclude-dir=node_modules 'some pattern' /path/to/search</span><br></pre></td></tr></tbody></table></figure></li><li><p>列出关键字所在行的前几行与后几行也一起显示<br><code>-A -B -C</code><br>很多时候，我们并关心匹配行而是关心匹配行的上下文。这时候-A -B -C就有用了<br>-A n 后n行，A记忆为(After)<br>-B n 前n行，B记忆为(Before)<br>-C n 前n行，后n行，C记忆为(Center)</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@locaslhost ~]# dmesg | grep -n -A3 -B2 --color=auto '6586'</span><br><span class="line">148-[11918697.806055] ACPI Exception: AE_AML_BUFFER_LIMIT, Evaluating _PMM (20130517/power_meter-339)</span><br><span class="line">149-[11918757.806573] ACPI Error: SMBus/IPMI/GenericSerialBus write requires Buffer of length 66, found length 32 (20130517/exfield-299)</span><br><span class="line">150:[11918757.806586] ACPI Error: Method parse/execution failed [\_SB_.PMI0._PMM] (Node ffff8808fcc56578), AE_AML_BUFFER_LIMIT (20130517/psparse-536)</span><br><span class="line">151-[11918757.806601] ACPI Exception: AE_AML_BUFFER_LIMIT, Evaluating _PMM (20130517/power_meter-339)</span><br><span class="line">152-[11918817.808022] ACPI Error: SMBus/IPMI/GenericSerialBus write requires Buffer of length 66, found length 32 (20130517/exfield-299)</span><br><span class="line">153-[11918817.808033] ACPI Error: Method parse/execution failed [\_SB_.PMI0._PMM] (Node ffff8808fcc56578), AE_AML_BUFFER_LIMIT (20130517/psparse-536)</span><br><span class="line">--</span><br><span class="line"></span><br><span class="line"># 如上所示，你会发现关键字 6586 所在的前两行及 后三行也都被显示出来！</span><br></pre></td></tr></tbody></table></figure></li><li><p>–line-buffered 打开buffering 模式<br>有一个文件是动态的，它不断地添加信息到文件的尾部，而你想要输出包含某些信息的行。即持续的grep一个动态的流</p></li><li><p>e与E区别<br>grep想同时过滤多个条件或操作<br>错误写法：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># netstat -an|grep "ESTABLISHED|WAIT"      #默认grep不支持多条件匹配</span><br></pre></td></tr></tbody></table></figure></li></ul><p>正确写法：<br>加上-E 多条件用””包起来，然后多条件之间用|管道符分开<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># netstat -an|grep -E "ESTABLISHED|WAIT"    </span><br><span class="line"></span><br><span class="line">tcp        0     52 192.168.1.108:22            192.168.1.104:54127         ESTABLISHED</span><br></pre></td></tr></tbody></table></figure><p></p><p>而-e呢不用””包起来，-e 指定一个匹配条件<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># ps -aux|grep -e udevd -e master|awk {'print $(NF-1)'}|sort|uniq  </span><br><span class="line"></span><br><span class="line">/sbin/udevd</span><br><span class="line"></span><br><span class="line">/usr/bin/salt-master</span><br></pre></td></tr></tbody></table></figure><p></p><p>grep -E ‘123|abc’ filename  // 找出文件（filename）中包含123或者包含abc的行<br>egrep ‘123|abc’ filename    // 用egrep同样可以实现<br>awk ‘/123|abc/‘ filename   // awk 的实现方式<br>与操作<br>grep pattern1 files | grep pattern2 ：显示既匹配 pattern1 又匹配 pattern2 的行。  </p><ul><li>-m的使用<br>只匹配到了第三行就退出<br><code># grep -m 3 "abc" test2.txt</code> </li></ul><h3 id="与正则表达式结合"><a href="#与正则表达式结合" class="headerlink" title="与正则表达式结合"></a>与正则表达式结合</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">grep的规则表达式:</span><br><span class="line">\     反义字符：如"\"\""表示匹配""</span><br><span class="line">[ - ] 匹配一个范围，[0-9a-zA-Z]匹配所有数字和字母</span><br><span class="line">* 所有字符，长度可为0</span><br><span class="line">+ 前面的字符出现了一次或者多次</span><br><span class="line">^  #匹配行的开始 如：'^grep'匹配所有以grep开头的行。    </span><br><span class="line">$  #匹配行的结束 如：'grep$'匹配所有以grep结尾的行。    </span><br><span class="line">.  #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。    </span><br><span class="line">*  #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。    </span><br><span class="line">.*   #一起用代表任意字符。   </span><br><span class="line">[]   #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。    </span><br><span class="line">[^]  #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。    </span><br><span class="line">\(..\)  #标记匹配字符，如'\(love\)'，love被标记为1。    </span><br><span class="line">\<      #到匹配正则表达式的行开始，如:'\<grep'匹配包含以grep开头的单词的行。    </span><br><span class="line">\>      #到匹配正则表达式的行结束，如'grep\>'匹配包含以grep结尾的单词的行。    </span><br><span class="line">x\{m\}  #重复字符x，m次，如：'0\{5\}'匹配包含5个o的行。    </span><br><span class="line">x\{m,\}  #重复字符x,至少m次，如：'o\{5,\}'匹配至少有5个o的行。    </span><br><span class="line">x\{m,n\}  #重复字符x，至少m次，不多于n次，如：'o\{5,10\}'匹配5--10个o的行。   </span><br><span class="line">\w    #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。   </span><br><span class="line">\W    #\w的反置形式，匹配一个或多个非单词字符，如点号句号等。   </span><br><span class="line">\b    #单词锁定符，如: '\bgrep\b'只匹配grep。  </span><br><span class="line"></span><br><span class="line">POSIX字符:</span><br><span class="line">[:alnum:]    #文字数字字符   </span><br><span class="line">[:alpha:]    #文字字符   </span><br><span class="line">[:digit:]    #数字字符   </span><br><span class="line">[:graph:]    #非空字符（非空格、控制字符）   </span><br><span class="line">[:lower:]    #小写字符   </span><br><span class="line">[:cntrl:]    #控制字符   </span><br><span class="line">[:print:]    #非空字符（包括空格）   </span><br><span class="line">[:punct:]    #标点符号   </span><br><span class="line">[:space:]    #所有空白字符（新行，空格，制表符）   </span><br><span class="line">[:upper:]    #大写字符   </span><br><span class="line">[:xdigit:]   #十六进制数字（0-9，a-f，A-F）</span><br></pre></td></tr></tbody></table></figure><ul><li><p>通过管道过滤ls -l输出的内容，只显示以a开头的行。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">首与行尾字节 ^ $，^ 符号，在字符类符号(括号[])之内与之外是不同的！ 在 [] 内代表『反向选择』，在 [] 之外则代表定位在行首的意义！</span><br><span class="line"></span><br><span class="line">$ ls -l | grep \'^a\'</span><br><span class="line">$ ls -l | grep  ^a</span><br><span class="line">$ ls -l | grep  ^[^a]      #输出非a开头的行，反向选择</span><br><span class="line">$ grep -n '^$' express.txt      #找出空白行，因为只有行首跟行尾 (^$)</span><br></pre></td></tr></tbody></table></figure></li><li><p>显示所有以d开头的文件中包含test的行。<br><code>$ grep \'test\' d*</code></p></li><li><p>输出以hat结尾的行内容<br><code>$ cat test.txt |grep hat$</code></p></li><li><p>显示在aa，bb，cc文件中匹配test的行。<br><code>$ grep \'test\' aa bb cc</code></p></li><li><p>显示所有包含每个字符串至少有5个连续小写字符的字符串的行。</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ grep \'[a-z]{5}\' aa</span><br><span class="line">$ grep -n '[0-9]' regular_express.txt  　　#取得有数字的那一行</span><br><span class="line">$ grep -n '^[a-z]' regular_express.txt 　　 #只输出开头是小写字母的那一行</span><br><span class="line">$ grep -n '^[^a-zA-Z]' regular_express.txt   #不输出开头是英文的</span><br><span class="line">$ grep -n '\.$' regular_express.txt   　　　　 #只输出行尾结束为小数点 (.) 的那一行</span><br><span class="line">注意：小数点具有其他意义，所以必须要使用转义字符(\)来加以解除其特殊意义！</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p>显示包含ed或者at字符的内容行<br>命令：cat test.txt |grep -E “ed|at”</p></li><li><p>显示当前目录下面以.txt 结尾的文件中的所有包含每个字符串至少有7个连续小写字符的字符串的行<br>命令：grep ‘[a-z]{7}‘ *.txt    </p></li><li><p>查询IP地址、邮箱、手机号<br>也就是说-o，只显示匹配行中匹配正则表达式的那部分，-P，作为Perl正则匹配<br>命令（IP）：grep -oP “([0-9]{1,3}.){3}[0-9]{1,3}” file.txt<br>命令（邮箱）：grep -oP “[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+” file.txt<br>手机号码是1[3|4|5|8]后面接9位数字:<br>命令（手机号）：grep -E “\<1[3|4|5|8][0-9]{9}>“  file.txt</p></li><li><p>任意一个字节 . 与重复字节 *</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">. (小数点)：代表『一定有一个任意字节』的意思；</span><br><span class="line">* (星号)：代表『重复前一个字符， 0 到无穷多次』的意思，为组合形态</span><br><span class="line"></span><br><span class="line">$ grep -n '[0-9][0-9]*' regular_express.txt     #找出『任意数字』的行</span><br><span class="line"></span><br><span class="line">$ grep -n 'g.*g' regular_express.txt       #找出以g行首与行尾的行，当中的字符可有可无</span><br><span class="line"></span><br><span class="line">这个 .* 的 RE 表示任意字符是很常见的.</span><br></pre></td></tr></tbody></table></figure></li><li><p>限定连续 RE 字符范围 {}</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">利用 . 与 RE 字符及 * 来配置 0 个到无限多个重复字节</span><br><span class="line"></span><br><span class="line">打算找出两个到五个 o 的连续字串，该如何作？这时候就得要使用到限定范围的字符 {} 了。 但因为 { 与 } 的符号在 shell 是有特殊意义的，因此， 我们必须要使用字符   \ 来让他失去特殊意义才行。 </span><br><span class="line">$ grep -n 'o\{2\}' regular_express.txt</span><br><span class="line">$ grep -n 'go\{2,5\}g' regular_express.txt  #要找出 g 后面接 2 到 5 个 o ，然后再接一个 g 的字串</span><br><span class="line">$ grep -n 'go\{2,\}g' regular_express.txt    #想要的是 2 个 o 以上的 goooo....g 呢？除了可以是 gooo*g</span><br></pre></td></tr></tbody></table></figure></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「Grep」
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux Ftp</title>
    <link href="http://yoursite.com/2018/10/20/Linux/05.Ftp_Sftp/"/>
    <id>http://yoursite.com/2018/10/20/Linux/05.Ftp_Sftp/</id>
    <published>2018-10-20T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-Ftp、Sftp"><a href="#Linux-Ftp、Sftp" class="headerlink" title="Linux Ftp、Sftp"></a>Linux Ftp、Sftp</h1><p>sftp命令可以通过ssh来上传和下载文件，是常用的文件传输工具，它的使用方式与ftp类似，但它使用ssh作为底层传输协议，所以安全性比ftp要好得多。</p><h2 id="Ftp常见命令详解"><a href="#Ftp常见命令详解" class="headerlink" title="Ftp常见命令详解"></a>Ftp常见命令详解</h2><h3 id="登录Ftp服务器"><a href="#登录Ftp服务器" class="headerlink" title="登录Ftp服务器"></a>登录Ftp服务器</h3><p>格式：直接输入ftp加ip地址:ftp 192.168.10.xxx<br>格式：直接输入ftp，进入ftp服务后输入open加ip地址:open 192.168.10.xxx </p><h3 id="查看Ftp服务器上的文件"><a href="#查看Ftp服务器上的文件" class="headerlink" title="查看Ftp服务器上的文件"></a>查看Ftp服务器上的文件</h3><p>（一般情况下用户都会被限制目录的访问权限，只可在当前目录下进行操作）<br>dir：显示服务器目录和文件列表<br>ls：显示服务器简易的文件列表<br>cd：进入服务器指定的目录</p><p>dir命令可以使用通配符“”和“?”，比如，显示当前目录中所有扩展名为jpg的文件，可使用命令 dir .jpg。<br>cd命令中必须带目录名。比如 cd main 表示进入当前目录下的main子目录</p><h3 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h3><p>上传和下载文件时应该使用正确的传输类型，FTP的传输类型分为ASCII码方式和二进制方式两种，<br>对.txt、.htm等文件应采用ASCII码方式传输，对.exe或图片、视频、音频等文件应采用二进制方式传输。在默认情况下，FTP为ASCII码传输方式。 </p><p>type：查看当前的传输方式<br>ascii：设定传输方式为ASCII码方式<br>binary：设定传输方式为二进制方式  </p><p>get：下载指定文件get filename [newname]<br>mget：下载多个文件mget filename [filename ….]（mget命令支持通配符“”和“?”，比如：mget .mp3 表示下载FTP服务器当前目录下的所有扩展名为mp3的文件。）</p><h3 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h3><p>put：上传指定文件put filename [newname]<br>send：上传指定文件send filename [newname] </p><p>这里的send和put方法用法都基本相同，但是上传速度send却要比put快很多</p><h3 id="结束并退出Ftp"><a href="#结束并退出Ftp" class="headerlink" title="结束并退出Ftp"></a>结束并退出Ftp</h3><p>close：结束与服务器的FTP会话<br>quit：结束与服务器的FTP会话并退出FTP环境  </p><h3 id="其它Ftp命令"><a href="#其它Ftp命令" class="headerlink" title="其它Ftp命令"></a>其它Ftp命令</h3><p>pwd：查看Ftp服务器上的当前工作目录<br>rename filename newfilename：重命名FTP服务器上的文件<br>deletefilename：删除FTP服务器上的文件<br>help[cmd]：显示FTP命令的帮助信息，cmd是命令名，如果不带参数，则显示所有FTP命令  </p><h2 id="Sftp常见命令详解"><a href="#Sftp常见命令详解" class="headerlink" title="Sftp常见命令详解"></a>Sftp常见命令详解</h2><h3 id="登录Sftp服务器"><a href="#登录Sftp服务器" class="headerlink" title="登录Sftp服务器"></a>登录Sftp服务器</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式：sftp <host></span><br><span class="line">通过sftp连接<host>，端口为默认的22，用户为Linux当前登录用户。</span><br><span class="line"></span><br><span class="line">格式：sftp -oPort=<port> <host></span><br><span class="line">通过sftp连接<host>，指定端口<port>，用户为Linux当前登录用户。</span><br><span class="line"></span><br><span class="line">格式：sftp <user>@<host></span><br><span class="line">通过sftp连接<host>，端口为默认的22，指定用户<user>。</span><br><span class="line"></span><br><span class="line">格式：sftp -oPort=<port> <user>@<host></span><br><span class="line">通过sftp连接<host>，端口为<port>，用户为<user>。</span><br></pre></td></tr></tbody></table></figure><h3 id="查看Sftp-服务器上的文件"><a href="#查看Sftp-服务器上的文件" class="headerlink" title="查看Sftp 服务器上的文件"></a>查看Sftp 服务器上的文件</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">help/? 打印帮助信息   </span><br><span class="line">pwd 查看远程服务器当前目录   </span><br><span class="line">lpwd 查看本地系统的当前目录  </span><br><span class="line"></span><br><span class="line">cd <dir> 将远程服务器的当前目录更改为<dir>   </span><br><span class="line">lcd <dir> 将本地系统的当前目录更改为<dir>  </span><br><span class="line"></span><br><span class="line">ls 显示远程服务器上当前目录的文件名   </span><br><span class="line">ls -l 显示远程服务器上当前目录的文件详细列表；   </span><br><span class="line"></span><br><span class="line">ls <pattern> 显示远程服务器上符合指定模式<pattern>的文件名；  </span><br><span class="line">ls -l <pattern>  显示远程服务器上符合指定模式<pattern>的文件详细列表   </span><br><span class="line">lls 显示本地系统上当前目录的文件名,lls的其他参数与ls命令的类似</span><br></pre></td></tr></tbody></table></figure><h3 id="下载文件-1"><a href="#下载文件-1" class="headerlink" title="下载文件"></a>下载文件</h3><p>get <file> 下载指定文件<file><br>get <pattern> 下载符合指定模式<pattern>的文件</pattern></pattern></file></file></p><h3 id="上传文件-1"><a href="#上传文件-1" class="headerlink" title="上传文件"></a>上传文件</h3><p>put <file> 上传指定文件<file>；<br>get <pattern> 上传符合指定模式<pattern>的文件。</pattern></pattern></file></file></p><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">progress 切换是否显示文件传输进度</span><br><span class="line">mkdir <dir> 在远程服务器上创建目录</span><br><span class="line">lmkdir <dir> 在本地系统上创建目录</span><br></pre></td></tr></tbody></table></figure><h3 id="结束并退出Sftp"><a href="#结束并退出Sftp" class="headerlink" title="结束并退出Sftp"></a>结束并退出Sftp</h3><p>exit/quit/bye 退出sftp</p><h3 id="其他Sftp-命令"><a href="#其他Sftp-命令" class="headerlink" title="其他Sftp 命令"></a>其他Sftp 命令</h3><p>其他命令还有：chgrp, chmod, chown, ln, lumask, rename, rm, rmdir, symlink, version。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「Ftp」「Sftp」
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="http://yoursite.com/2018/10/04/Linux/01.Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/10/04/Linux/01.Linux常用命令/</id>
    <published>2018-10-04T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.751Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><h3 id="设置变量的三种方法"><a href="#设置变量的三种方法" class="headerlink" title="设置变量的三种方法"></a>设置变量的三种方法</h3><ul><li><p>在/etc/profile文件中添加变量【对所有用户生效（永久的）】</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vi /etc/profile</span><br><span class="line">export  PATH=/home/kylin : $PATH    </span><br><span class="line"># source /etc/profile</span><br></pre></td></tr></tbody></table></figure></li><li><p>在用户目录下的.bash_profile文件中增加变量【对单一用户生效（永久的）】</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vi /home/guok/.bash.profile</span><br><span class="line">添加如下内容：</span><br><span class="line">export CLASSPATH=./JAVA_HOME/lib;$JAVA_HOME/jre/lib</span><br><span class="line">$ source /home/guok/.bash_profile</span><br></pre></td></tr></tbody></table></figure></li><li><p>直接运行export命令定义变量【只对当前shell（BASH）有效（临时的）】<br>在shell的命令行下直接使用[export 变量名=变量值]</p></li></ul><h3 id="PATH声明，其格式为："><a href="#PATH声明，其格式为：" class="headerlink" title="PATH声明，其格式为："></a>PATH声明，其格式为：</h3><pre><code>PATH=$PATH:<PATH 1>:<PATH 2>:<PATH 3>:------:<PATH N>你可以自己加上指定的路径，中间用冒号隔开。环境变量更改后，在用户下次登陆时生效。如果想立刻生效，则可执行下面的语句：$source .bash_profile需要注意的是，最好不要把当前路径”./”放到PATH里，这样可能会受到意想不到的攻击。完成后，可以通过$ echo $PATH查看当前的搜索路径。这样定制后，就可以避免频繁的启动位于shell搜索的路径之外的程序了。</code></pre><h3 id="常用的环境变量"><a href="#常用的环境变量" class="headerlink" title="常用的环境变量"></a>常用的环境变量</h3><p>　　PATH      决定了shell将到哪些目录中寻找命令或程序<br>　　HOME      当前用户主目录<br>　　HISTSIZE　历史记录数<br>　　LOGNAME   当前用户的登录名<br>　　HOSTNAME　指主机的名称<br>　　SHELL 　　当前用户Shell类型<br>　　LANGUGE 　语言相关的环境变量，多语言可以修改此环境变量<br>　　MAIL　　　当前用户的邮件存放目录<br>　　PS1　　　基本提示符，对于root用户是#，对于普通用户是$</p><h3 id="常用的环境变量相关命令"><a href="#常用的环境变量相关命令" class="headerlink" title="常用的环境变量相关命令"></a>常用的环境变量相关命令</h3><ul><li>显示环境变量HOME</li><li><p>设置一个新的环境变量hello<br>fs@ubuntu:~$ export HELLO=”Hello”<br>fs@ubuntu:~$ echo $HELLO </p></li><li><p>使用env命令显示所有的环境变量</p></li><li><p>使用set命令显示所有本地定义的Shell变量　<br>fs@ubuntu:~$ set  </p></li><li><p>使用unset命令来清除环境变量<br>set可以设置某个环境变量的值。清除环境变量的值用unset命令。如果未指定值，则该变量值将被设为NULL。<br>fs@ubuntu:~$ unset $TEST \删除环境变量TEST  　  </p></li><li>使用readonly命令设置只读变量<br>如果使用了readonly命令的话，变量就不可以被修改或清除了。<br>fs@ubuntu:~$ export TEST=”Test” \增加一个环境变量TEST<br>fs@ubuntu:~$ readonly TEST \将环境变量TEST设为只读<br>fs@ubuntu:~$ unset TEST \此变量无法删除<br>bash: unset: TEST: cannot unset: readonly variable<br>fs@ubuntu:~$ TEST=”NEW” \此变量不可更改<br>bash: TEST: readonly variable  </li></ul><h2 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h2><h3 id="rpm的一般格式："><a href="#rpm的一般格式：" class="headerlink" title="rpm的一般格式："></a>rpm的一般格式：</h3><p>rpm [选项] [rpm软件包] </p><ul><li><p>初始化rpm 数据库（可以省略）<br>rpm –initdb<br>rpm –rebuilddb   注：这个要花好长时间。<br>注：有时rpm系统出了问题，不能安装和查询，大多是这里出了问题</p></li><li><p>RPM软件包管理的查询功能：<br>rpm -q [select-options] [query-options] </p></li><li><p>查询系统已安装的软件<br>语法：rpm -q 软件名<br>例：rpm -q mplayer<br>查看系统中所有已经安装的包，要加 -a 参数<br>rpm -qa  </p></li><li><p>查询一个已经安装的文件属于哪个软件包<br>语法： rpm -qf  文件名<br>注： 文件名所在的绝对路径要指出<br>例：rpm -qf  /usr/lib/libacl.la</p></li><li><p>查询已安装软件都安装到何处<br>语法：rpm   -ql  软件包名<br>例：rpm -ql  mplayer</p></li><li><p>查询一个已安装包的信息<br>语法:  rpm  -qi  软件包名<br>例： rpm   -qi  mplayer</p></li><li><p>查看一下已安装软件的配置文件<br>语法： rpm  -qc  软件名</p></li><li><p>查看一个已安装软件的文档安装位置<br>语法： rpm  -qd   软件名</p></li><li><p>查看一下已安装软件所依赖的软件包及文件<br>rpm   -qR   软件名</p></li></ul><h2 id="进程管理PS、TOP"><a href="#进程管理PS、TOP" class="headerlink" title="进程管理PS、TOP"></a>进程管理PS、TOP</h2><h3 id="进程的属性："><a href="#进程的属性：" class="headerlink" title="进程的属性："></a>进程的属性：</h3><p>进程ID（PID）    、父进程和父进程ID（PPID）、启动进程的用户ID（UID）和所归属的组ID（GID）、进程状态：R  S  Z 、进程执行优先级、进程连接的终端名、进程资源占用：内存、CPU占用量</p><h3 id="PS-TOP-管理进程"><a href="#PS-TOP-管理进程" class="headerlink" title="PS  TOP  管理进程"></a>PS  TOP  管理进程</h3><ul><li><p>PS  静态 当前的状态<br>参数说明：<br>l  ：长格式输出<br>u  ：按用户名和启动时间顺序显示<br>f    :树形格式显示<br>a    ：显示所有用户的所以进程<br>r     :运行中的进程<br>e     ：显示所有进程，包括没有控制终端的进程<br>x    : 显示没有控制终端的进程</p></li><li><p>PS -aux 输出的解释<br>USER        进程的属主；<br>PID            进程的ID<br>PPID            父进程<br>%CPU        占用的CPU百分比<br>%MEM        占用的内存百分比<br>NI            进程的NICE值<br>VSZ            占用虚拟内存大小<br>RSS            实际使用内存大小<br>TTY            进程启动的终端ID<br>STAT        进程状态        R   S  T  Z    N    L  s<br>START        启动进程的时间<br>TIME        进程消耗CPU的时间</p></li><li><p>COMMAND    命令的名称和参数<br>PS  -AUX        BSD格式显示<br>PS  -ef         标准格式显示</p></li><li><p>TOP  动态查看进程<br>统计信息区前5行是系统整体的统计信息。<br>图 。。。。<br>系统信息解释：<br>任务队列信息（第一行）：当前时间        系统运行时间        当前登陆用户数        系统负载，即任务队列平均长度，三个数值分别为1分钟、5分钟、15分钟前到现在的平均值。<br>进程和CPU的信息（第二、三行）：进程总数        正在运行的进程数    睡眠的进程数    停止的进程数        僵尸进程数    系统用户进程使用CPU百分比    内核中的进程占用CPU百分比（sy）    用户进程空间内改变过优先级的进程占用CPU百分比（ni）    空闲CPU百分比（id）<br>内存信息（第四五行）：物理内存总量        空闲内存总量        使用的物理内存总量        用作内核缓存的内存量（和free    -k 一个意思）    交换区总量    使用的交换区总量    空闲交换区总量<br>总的可以利用内存    </p></li><li><p>TOP快捷键<br>默认3s 刷新一次、空格  立即刷新<br>q  退出<br>M  按内存排序<br>P   按CPU排序</p></li></ul><h2 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h2><ul><li>配置yum源的配置文件<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[base-yum]</span><br><span class="line">name=rhel7-source</span><br><span class="line">baseurl=file:///mnt</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></tbody></table></figure></li></ul><p>清空yum 缓存        yum  clean    all<br>生成列表            yum     list<br>安装                yum    install    -y<br>检测升级            yum  check-update<br>升级                yum        update<br>软件包查询        yum        list<br>软件包信息        yum        info</p><ul><li>源码包安装：<br>编译 make -j 4  使用4个进程同编译<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--prefix  指定安装的位置</span><br><span class="line">--user   指定运行的用户</span><br><span class="line">--group 。  制定运行的组</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="du、df"><a href="#du、df" class="headerlink" title="du、df"></a>du、df</h2><p>du 统计文件大小相加<br>df  统计数据块使用情况</p><p>[root@bsso yayu]# du -h –max-depth=1 work/testing<br>27M     work/testing/logs<br>35M     work/testing</p><ul><li>查看linux文件目录的大小和文件夹包含的文件数<br>统计总数大小<br>du -sh xmldb/</li></ul><p>统计当前目录大小 并安大小 排序<br>du -sm <em> | sort -n<br>du -sk </em> | sort -n</p><p>看一个的大小<br>du -sk * | grep guojf </p><h2 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h2><ul><li>which   可执行文件位置 </li><li><p>whereis  可执行文件的位置及相关文件</p></li><li><p>find   目录结构中搜索文件。<br>格式：    find        路径        选项        </p></li></ul><p>选项：    -name        -perm        -user    -mtime        -n        +n<br>-type    查找某一类型。    b    c    p    d    f    l<br>例：find    /etc/        -name    “host*”<br>find    .    -perm    755<br>find     /home/kylin    -user    kylin<br>find    /home/kylin    -group    kylin<br>find    /root    -mtime    -5<br>find     /root    -mtime    +3</p><h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><p>计划任务：在某个时段自动执行某个任务。</p><h3 id="at-只能执行一次"><a href="#at-只能执行一次" class="headerlink" title="at    只能执行一次"></a>at    只能执行一次</h3><p>systemctl        status    atd<br>ctrl    +D 结束</p><p>at    -l    查看计划任务    任务编号    、执行时间    、执行者<br>at    20:00   2017-4-12<br>at    now     +10min    在10分钟后执行<br>删除at 计划任务：atrm    +     计划任务的编号</p><h3 id="周期行计划任务：cron-主程序-、"><a href="#周期行计划任务：cron-主程序-、" class="headerlink" title="周期行计划任务：cron  主程序        、"></a>周期行计划任务：cron  主程序        、</h3><ul><li><p>Crond 服务：<br>1.系统级别    2.用户级别的计划任务</p></li><li><p>主文件：    /etc/crontab<br>针对用户级别的计划任务：<br>对于root用户：<br>命令：crontab        -e        创建一个计划任务<br> crontab          -l         显示<br> crontab        -r          删除计划任务</p></li></ul><p>crontab    -e    # 写法<br>分    时     日    月    星    谁做后面的事情        命令<br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">每月 9,18,22 这几天的凌晨1点1分，执行一个备份脚本</span><br><span class="line">1 1 9,18,22**/root/backup.sh</span><br><span class="line">每月 9-22号这几天的凌晨1点1分，执行一个备份脚本</span><br><span class="line">1  1  9-22  *    *   /root/backup.sh</span><br><span class="line">每5分钟，执行一次</span><br><span class="line">*/5**** /root/backup.sh</span><br></pre></td></tr></tbody></table></figure><p></p><p>anacron    ：解决cront  错过时间后，不执行cron计划任务的问题。<br>anacron的作用：机器重启后，侦测在关机的这一段时间期间，有没有cron每有执行的计划任务， 如果有，开机后，anacron会立即执行没有执行的任务。</p><h2 id="Curl"><a href="#Curl" class="headerlink" title="Curl"></a>Curl</h2><p>curl模拟Http 的get 或 post请求</p><h3 id="查看网页源码"><a href="#查看网页源码" class="headerlink" title="查看网页源码"></a>查看网页源码</h3><p>$ curl <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"></span><br><span class="line">　　<html><head></span><br><span class="line">　　<title>301 Moved Permanently</title></span><br><span class="line">　　</head><body></span><br><span class="line">　　<h1>Moved Permanently</h1></span><br><span class="line">　　<p>The document has moved <a href="http://www.sina.com.cn/">here</a>.</p></span><br><span class="line">　　</body></html></span><br></pre></td></tr></tbody></table></figure><p></p><ul><li>保存下来，可以使用-o参数<br>$ curl -o [文件名] <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a></li></ul><h3 id="自动跳转"><a href="#自动跳转" class="headerlink" title="自动跳转"></a>自动跳转</h3><p>有的网址是自动跳转的。使用-L参数，curl就会跳转到新的网址。<br>$ curl -L <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a></p><h3 id="显示头信息"><a href="#显示头信息" class="headerlink" title="显示头信息"></a>显示头信息</h3><p>-i参数可以显示http response的头信息，连同网页代码一起。<br>$ curl -i <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a></p><p>-I参数则是只显示http response的头信息。 </p><h3 id="显示通信过程"><a href="#显示通信过程" class="headerlink" title="显示通信过程"></a>显示通信过程</h3><p>-v参数可以显示一次http通信的整个过程，包括端口连接和http request头信息。<br>$ curl -v <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a><br></p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">　* About to connect() to www.sina.com port 80 (#0)</span><br><span class="line">　　* Trying 61.172.201.195... connected</span><br><span class="line">　　* Connected to www.sina.com (61.172.201.195) port 80 (#0)</span><br><span class="line">　　> GET / HTTP/1.1</span><br><span class="line">　　> User-Agent: curl/7.21.3 (i686-pc-linux-gnu) libcurl/7.21.3 OpenSSL/0.9.8o zlib/1.2.3.4 libidn/1.18</span><br><span class="line">　　> Host: www.sina.com</span><br><span class="line">　　> Accept: */*</span><br><span class="line">　　> </span><br><span class="line">　　* HTTP 1.0, assume close after body</span><br><span class="line">　　< HTTP/1.0 301 Moved Permanently</span><br><span class="line">　　< Date: Sun, 04 Sep 2011 00:42:39 GMT</span><br><span class="line">　　< Server: Apache/2.0.54 (Unix)</span><br><span class="line">　　< Location: http://www.sina.com.cn/</span><br><span class="line">　　< Cache-Control: max-age=3600</span><br><span class="line">　　< Expires: Sun, 04 Sep 2011 01:42:39 GMT</span><br><span class="line">　　< Vary: Accept-Encoding</span><br><span class="line">　　< Content-Length: 231</span><br><span class="line">　　< Content-Type: text/html; charset=iso-8859-1</span><br><span class="line">　　< X-Cache: MISS from sh201-19.sina.com.cn</span><br><span class="line">　　< Connection: close</span><br><span class="line">　　< </span><br><span class="line">　　<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN"></span><br><span class="line">　　<html><head></span><br><span class="line">　　<title>301 Moved Permanently</title></span><br><span class="line">　　</head><body></span><br><span class="line">　　<h1>Moved Permanently</h1></span><br><span class="line">　　<p>The document has moved <a href="http://www.sina.com.cn/">here</a>.</p></span><br><span class="line">　　</body></html></span><br><span class="line">　　* Closing connection #0</span><br></pre></td></tr></tbody></table></figure><p></p><p>如果你觉得上面的信息还不够，那么下面的命令可以查看更详细的通信过程。<br>$ curl –trace output.txt <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a><br>或者 $ curl –trace-ascii output.txt <a href="http://www.sina.com" target="_blank" rel="noopener">www.sina.com</a></p><h3 id="发送表单信息"><a href="#发送表单信息" class="headerlink" title="发送表单信息"></a>发送表单信息</h3><p>发送表单信息有GET和POST两种方法。GET方法相对简单，只要把数据附在网址后面就行。<br>$ curl example.com/form.cgi?data=xxx</p><p>POST方法必须把数据和网址分开，curl就要用到–data参数。<br>　<br>　$ curl -X POST –data “data=xxx” example.com/form.cgi</p><p>如果你的数据没有经过表单编码，还可以让curl为你编码，参数是–data-urlencode。<br>　<br>　$ curl -X POST–data-urlencode “date=April 1” example.com/form.cgi</p><h3 id="HTTP动词"><a href="#HTTP动词" class="headerlink" title="HTTP动词"></a>HTTP动词</h3><p>curl默认的HTTP动词是GET，使用-X参数可以支持其他动词。<br>　<br>　$ curl -X POST <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></p><p>　$ curl -X DELETE <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>假定文件上传的表单是下面这样：<br>　<br>　</p><form method="POST" enctype="multipart/form-data" action="upload.cgi"><br>　　　　<input type="file" name="upload"><br>　　　　<input type="submit" name="press" value="OK"><br>　　</form><p></p><p>你可以用curl这样上传文件：<br>　<br>　$ curl –form upload=@localfilename –form press=OK [URL]</p><h3 id="Referer字段"><a href="#Referer字段" class="headerlink" title="Referer字段"></a>Referer字段</h3><p>有时你需要在http request头信息中，提供一个referer字段，表示你是从哪里跳转过来的。<br>　<br>　$ curl –referer <a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a> <a href="http://www.example.com" target="_blank" rel="noopener">http://www.example.com</a></p><p>　九、User Agent字段<br>这个字段是用来表示客户端的设备信息。服务器有时会根据这个字段，针对不同设备，返回不同格式的网页，比如手机版和桌面版。<br>iPhone4的User Agent是<br>　<br>　Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_0 like Mac OS X; en-us) AppleWebKit/532.9 (KHTML, like Gecko) Version/4.0.5 Mobile/8A293 Safari/6531.22.7</p><p>curl可以这样模拟：<br>　<br>　$ curl –user-agent “[User Agent]” [URL]</p><p>十、cookie<br>使用–cookie参数，可以让curl发送cookie。<br>　　<br>$ curl –cookie “name=xxx” <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a></p><p>至于具体的cookie的值，可以从http response头信息的Set-Cookie字段中得到。<br>-c cookie-file可以保存服务器返回的cookie到文件，-b cookie-file可以使用这个文件作为cookie信息，进行后续的请求。<br>　<br>　$ curl -c cookies <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a><br>　$ curl -b cookies <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a></p><p>十一、增加头信息<br>有时需要在http request之中，自行增加一个头信息。–header参数就可以起到这个作用。<br>　　<br>$ curl –header “Content-Type:application/json” <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a></p><p>十二、HTTP认证<br>有些网域需要HTTP认证，这时curl需要用到–user参数。<br>　<br>　$ curl –user name:password example.com　</p><p>十三、get请求<br>curl “<a href="http://www.baidu.com"" target="_blank" rel="noopener">http://www.baidu.com"</a> 如果这里的URL指向的是一个文件或者一幅图都可以直接下载到本地<br>curl -i “<a href="http://www.baidu.com"" target="_blank" rel="noopener">http://www.baidu.com"</a> 显示全部信息<br>curl -l “<a href="http://www.baidu.com"" target="_blank" rel="noopener">http://www.baidu.com"</a> 只显示头部信息<br>curl -v “<a href="http://www.baidu.com"" target="_blank" rel="noopener">http://www.baidu.com"</a> 显示get请求全过程解析<br>wget “<a href="http://www.baidu.com"也可以" target="_blank" rel="noopener">http://www.baidu.com"也可以</a><br>十四、post请求<br>curl -d “param1=value1&param2=value2” “<a href="http://www.baidu.com"" target="_blank" rel="noopener">http://www.baidu.com"</a></p><p>通过脚本发送post请求，顺便附带文本数据，比如通过”浏览”选择本地的card.txt并上传发送post请求：<br>curl  -F “<a href="mailto:blob=@card.txt" target="_blank" rel="noopener">blob=@card.txt</a>;type=text/plain”  “<a href="http://172.16.102.208:8089/wiapi/score?leaderboard_id=7778a8143f111272&score=40&app_key=8d49f16fe034b98b&_test_user=test01"" target="_blank" rel="noopener">http://172.16.102.208:8089/wiapi/score?leaderboard_id=7778a8143f111272&score=40&app_key=8d49f16fe034b98b&_test_user=test01"</a>  </p><p>其中-F 为带文件的形式发送post请求， blob为文本框中的name元素对应的属性值。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「linux」
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>next主题配置</title>
    <link href="http://yoursite.com/2018/10/03/Hexo/02.hexo/"/>
    <id>http://yoursite.com/2018/10/03/Hexo/02.hexo/</id>
    <published>2018-10-03T10:11:07.000Z</published>
    <updated>2019-07-21T01:21:36.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h1><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      「Hexo」「Next」
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
