<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AIR PAN</title>
  
  <subtitle>NOTE</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-23T12:51:52.688Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Air Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL 语法「一」</title>
    <link href="http://yoursite.com/2019/05/21/MySQL/01.MySQL/"/>
    <id>http://yoursite.com/2019/05/21/MySQL/01.MySQL/</id>
    <published>2019-05-21T10:11:07.000Z</published>
    <updated>2019-05-23T12:51:52.688Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-语法"><a href="#MySQL-语法" class="headerlink" title="MySQL 语法"></a>MySQL 语法</h1><ul><li>MySQL 管理</li><li>MySQL 用户、授权</li><li>MySQL 库</li><li>MySQL 表</li></ul><h2 id="MySQL-管理"><a href="#MySQL-管理" class="headerlink" title="MySQL 管理"></a>MySQL 管理</h2><h3 id="启动和关闭"><a href="#启动和关闭" class="headerlink" title="启动和关闭"></a>启动和关闭</h3><ul><li>不是通过RPM包安装的MySQL<br>启动：    /usr/bin/mysqld_safe &amp;<br>关闭：    mysqladmin -uroot shutdown -p</li></ul><h3 id="MySQL-连接"><a href="#MySQL-连接" class="headerlink" title="MySQL 连接"></a>MySQL 连接</h3><ul><li><p>-D 指定将要登录的具体的数据库<br>mysql -uroot -D test -p123456  </p></li><li><p>本地连接mysql，-S  指定套接字位置<br>mysql -u root -p -S /var/lib/mysql/mysql.sock</p></li><li><p>远程连接mysql，-P 指定mysql服务对应的端口<br>mysql -u root -p 123456 -h 192.168.1.1 -P 3306</p></li><li><p>连接数据库的同时执行对应命令，并返回结果，不进入mysql 提示符<br>mysql -uroot -p123456 -e  ‘use mysql; select user,host,passwd from user;’<br>mysql -uroot -p123456 -e ‘create database if not exists testdb;show databases;’</p></li></ul><h3 id="Help"><a href="#Help" class="headerlink" title="Help"></a>Help</h3><ul><li>help create </li><li>help create databases</li><li>help contents</li><li>help ‘Data Types’</li></ul><h3 id="mysql的属性、状态、变量"><a href="#mysql的属性、状态、变量" class="headerlink" title="mysql的属性、状态、变量"></a>mysql的属性、状态、变量</h3><ul><li>mysql&gt; status</li><li><p>系统变量：配置了mysql的运行环境属性</p></li><li><p>全局变量：global variables ,作用域为整个mysql服务器<br>show  global variables；<br>版本相关：    show global variables  like ‘%version%’ ;<br>字符集相关：    show global variables where variable_name like ‘character%’;<br>日志是否关闭：    show global variables where variable_name like ‘%log%’ and value=’off’;</p></li><li><p>会话变量：session variables，作用域为当前会话<br>show session variables;<br>show variables; </p></li><li><p>查看单个全局系统变量或者会话系统变量：<br>select @@[global | session].system_var_name;<br>select @@global.pid_file;<br>select @@session.warning_count;</p></li><li><p>状态变量：mysql运行中的状态信息，不能设置。<br>查询mysql运行中信息和状态：状态变量也分为全局级别与会话级别<br>show  status;<br>show global status;<br>show session status;<br>show status where variable_name like ‘Uptime%’;</p></li><li><p>在写储存过程中，调用系统变量的值：<br>@@GLOBAL.var_name<br>@@SESSION.var_name<br>@@var_name 表示优先从会话级别获取变量值</p></li><li><p>修改变量值/设定变量值:<br>① 运行时修改：是否立即生效取决于修改的变量的类型，set 命令，运行时修改变量<br>运行时修改global级别的变量：对修改之前建立的会话没有影响，仅对修改后新建立的会话有效<br>运行时修改session级别的变量：仅对当前会话有效，且立即生效<br>② 配置文件修改：重启后生效。<br>例：<br>③ set @@session.autocommit=0;<br>设置系统变量语法总结：<br>set global.var_name = value;<br>set @@global.var_name = value;<br>set session.var_name = value;<br>set @@session.var_name = value;<br>set var_name = value; 不指定级别表示默认为设置会话级别的变量。</p></li></ul><h2 id="MySQL-用户"><a href="#MySQL-用户" class="headerlink" title="MySQL 用户"></a>MySQL 用户</h2><h3 id="MySQL-用户管理"><a href="#MySQL-用户管理" class="headerlink" title="MySQL 用户管理"></a>MySQL 用户管理</h3><ul><li>mysql 的用户格式：    usernmae@host<br>host: 主机名 或者 IP ，mysql 认为主机名 和 IP地址属于不同的主机。<br>通配符：</li><li><p>： 表示任意单个字符<br>%： 表示任意长度的任意字符<br>root@’10.1.%.%’    root用户可以通过10.1这个网段远程登录</p></li><li><p>查询用户<br>use mysql<br>select user,host,passwd from user;</p></li><li><p>创建用户<br>① create user ‘zabbix_proxy‘@’localhost’ identified by ‘zabbix_asp_2017’;<br>② 直接在mysql库的user 表中插入一条记录。（设置了严格的sql-mode  后无法使用）<br>insert  into mysql.user(user,host,passwd) values(‘pan’,’192.168.%.%’,passwd(‘123456’));<br>③ 在授权数据库的同时，如果对应的用户不存在，那么mysql会自动创建对应的用户。<br>grant all on pan.*to <a href="mailto:pan@127.0.0.1" target="_blank" rel="noopener">pan@127.0.0.1</a> identfied by ‘123456’;</p></li><li><p>删除用户<br>① delete 语句删除mysql.user 表中的用户对应的记录，有相关信息残留。<br>delete from mysql.user where user=’pan’ and host=’127.0.0.1’;<br>② drop user <a href="mailto:pan@127.0.0.1" target="_blank" rel="noopener">pan@127.0.0.1</a>     用户与用户对应的所有权限将被删除。</p></li><li><p>重命名用户：<br>rename user oldname to newname;</p></li></ul><h3 id="MySQL-密码管理"><a href="#MySQL-密码管理" class="headerlink" title="MySQL 密码管理"></a>MySQL 密码管理</h3><ul><li><p>更改用户名密码，官方推荐使用alter<br>ALTER USER test@’%’ IDENTIFIED BY ‘123456’;</p></li><li><p>update mysql.user set authentication_string=password(“新密码”) where User=”test” and Host=”localhost”;<br>flush privileges;</p></li><li><p>忘记root密码<br>① vi /etc/my.cnf，在[mysqld]中添加<br>skip-grant-tables<br>② 重启mysql : systemctl restart mysqld.service<br>③ mysql -uroot -p<br>④ use mysql;<br>⑤ 修改root密码：<br>update user set authentication_string=password(‘123456’) where user=’root’;<br>flush privileges;<br>⑥ 删除第1部增加的配置信息<br>skip-grant-tables<br>⑦ 重启mysql ： systemctl restart mysqld.service</p></li></ul><h2 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h2><ul><li><p>授权命令：<br>GRANT ALL privileges on db.tbl to ‘username‘@’host’ identified by ‘passwd’;<br>db 数据库名  tbl 表名    可以使用<em>通配。<br>示例：给本地用户授权某个数据库的所有权限<br>grant all privileges on pandb.</em> to pan@localhost identified by ‘123456’;<br>grant all on pandb.* to pan@localhost identified by ‘123456’;            privileges 关键字可省</p></li><li><p>给远程用户授权<br>grant all privileges on panthink.* to pan@’192.168.%.%’ identified by ‘123456’;<br>flush privileges;</p></li><li><p>授权用户某个数据库的某个权限，比如，只授权用户对于某个数据<br>grant select privileges on panthink.* to pan@’192.168.%.%‘；</p></li><li><p>授权某个数据库多个权限：<br>grant insert,delete,update,select on panthink.* to pan@’192.168.%.%’;</p></li><li><p>授权给多个用户：<br>grant select on mydb.* to pan@locakhost,pan2@localhost;</p></li><li><p>对某张表的某个字段授权：<br>grant select(name,age) on pan.students to pan@localhost;</p></li><li><p>授权test函数，用function关键字指明被操作的对象是函数：<br>grant execute on fuction panthink.test to pan@’192.168.%.%’;</p></li><li><p>强制用户使用ssl建立会话<br>grant useage on <em>.</em>  to ‘zabbix‘@’222.222.222.222’ require ssl;<br>取消ssl 连接限制<br>grant useage on <em>.</em>  to ‘zabbix‘@’222.222.222.222’ require none;</p></li><li><p>赋予用户授权的权限<br>授权zabbix用户db01 的 select权限，同时zabbix 用户也能将此权限授予给其他用户<br>grant select on db01.*  to ‘zabbix‘@’192.168.%.%’  with grant option;</p></li><li><p>查看授权：<br>从用户：    show grants for 用户名；<br>从数据库：select * from mysql.db where db=”要查看的数据库“；</p></li><li><p>删除授权：<br>revoke ‘要删除的权限’ on db.tb from user@host;<br>删除<a href="mailto:zabbix@192.168.1.1" target="_blank" rel="noopener">zabbix@192.168.1.1</a> 用户对于word数据库的所有权限:<br>revoke all on word.* from <a href="mailto:zabbix@192.168.1.1" target="_blank" rel="noopener">zabbix@192.168.1.1</a>;</p></li></ul><h2 id="库管理"><a href="#库管理" class="headerlink" title="库管理"></a>库管理</h2><ul><li><p>创建数据库<br>create database if not exists testdb charaacter set utf16;</p></li><li><p>查看数据库<br>show databases;<br>show create database testdb;<br>查看可用的字符集的命令<br>show character set;<br>查看排序方式的命令<br>show collation；</p></li><li><p>修改数据库<br>alter database testdb character set utf 8;<br>修改数据库的字符集，并设置为默认字符集，数据库中的表都会继承此字符集。<br>alter database testdb default character set utf8; </p></li><li><p>删除数据库<br>drop database if exists testdb;</p></li><li><p>数据库导出<br>mysqldump -u user_name -p database_name &gt; 导出的文件名</p></li><li><p>导出一个数据库结构（不包含数据）<br>mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql</p></li><li><p>带语言参数导出<br>mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql</p></li></ul><h2 id="表管理"><a href="#表管理" class="headerlink" title="表管理"></a>表管理</h2><ul><li><p>查看表的状态<br>show table status where name like ‘%tt%’;<br>desc table_name;<br>查看某张表创建时对应的sql 语句<br>show create table table_name;<br>复制表，但字段的约束和表的索引会丢失。<br>create table testtb2 select * from students;<br>完全的复制表结构<br>create table testdb3 like students;                    </p></li><li><p>修改表：<br>重命名表<br>alter table test1 rename as test2;<br>为表添加字段<br>alter  table ttt add cloumn age int;<br>alter table ttt add age int;        //  省略cloumn 默认为操作列。<br>添加字段设定相应的约束：<br>alter table ttt add age int not null default 0;<br>alter table ttt add cloumn age int not null default 0;<br>添加字段，指定字段在表中的位置：<br>alter table ttt add id int first;<br>alter table hosts add  categoryof varchar(200)  DEFAULT NULL after templateid;<br>删除字段：<br>alter table ttt drop stuname;<br>重命名字段：<br>alter table tsettb4 change name name1 char(20);<br>修改字段类型：<br>alter table testtb change age age char(20);<br>alter table testtb modify age int;    // modify 不能修改字段名称。</p></li><li><p>导出单个数据表结构和数据<br>mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql</p></li><li><p>导出单个数据表结构（不包含数据）<br>mysqldump -h localhost -uroot -p123456  -d database table &gt; dump.sql</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-语法&quot;&gt;&lt;a href=&quot;#MySQL-语法&quot; class=&quot;headerlink&quot; title=&quot;MySQL 语法&quot;&gt;&lt;/a&gt;MySQL 语法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;MySQL 管理&lt;/li&gt;
&lt;li&gt;MySQL 用户、授权&lt;/li&gt;
&lt;li&gt;M
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Python 的常用模块</title>
    <link href="http://yoursite.com/2019/05/20/Python/03.High-level/03.Pyhton%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/05/20/Python/03.High-level/03.Pyhton的常用模块/</id>
    <published>2019-05-20T10:11:07.000Z</published>
    <updated>2019-05-23T07:45:20.450Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h1><ul><li>calendar</li><li><a href="https://www.runoob.com/python/python-date-time.html" target="_blank" rel="noopener">time</a></li><li><a href="https://www.cnblogs.com/tkqasn/p/6001134.html" target="_blank" rel="noopener">datetime</a></li><li>timeit</li><li><a href="https://www.runoob.com/python3/python3-os-file-methods.html" target="_blank" rel="noopener">os</a></li><li>shutil</li><li>zip</li><li>math</li><li>string</li><li>上述所有模块使用理论上都应该先导入，string是特例</li></ul><h2 id="calendar"><a href="#calendar" class="headerlink" title="calendar"></a>calendar</h2><ul><li>跟日历相关的模块</li></ul><h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><ul><li><p>时间戳<br>一个时间表示，根据不同语言，可以是整数或者浮点数<br>是从1970年1月1日0时0分0秒到现在经历的秒数<br>如果表示的时间是1970年以前或者太遥远的未来，可能出现异常<br>32位操作系统能够支持到2038年</p></li><li><p>UTC时间<br>UTC又称为世界协调时间，以英国的格林尼治天文所在地区的时间作为参考的时间，也叫做世界标准时间。<br>中国时间是 UTC+8 东八区</p></li><li><p>夏令时<br>夏令时就是在夏天的时候将时间调快一小时，本意是督促大家早睡早起节省蜡烛！ 每天变成25个小时，本质没变还是24小时</p></li></ul><h3 id="时间元组"><a href="#时间元组" class="headerlink" title="时间元组"></a>时间元组</h3><ul><li><p>一个包含时间内容的普通元组</p><pre><code>索引      内容    属性            值0       年       tm_year     20151       月       tm_mon      1～122       日       tm_mday     1～313       时       tm_hour     0～234       分       tm_min      0～595       秒       tm_sec      0～61  60表示闰秒  61保留值6       周几     tm_wday     0～67       第几天    tm_yday     1～3668       夏令时    tm_isdst    0，1，-1（表示夏令时）</code></pre></li></ul><h3 id="时间模块的属性"><a href="#时间模块的属性" class="headerlink" title="时间模块的属性"></a>时间模块的属性</h3><ul><li>timezone: 当前时区和UTC时间相差的秒数，在没有夏令时的情况下的间隔,东八区的是 -28800</li><li>altzone  获取当前时区与UTC时间相差的秒数，在有夏令时的情况下，</li><li>daylight 测当前是否是夏令时时间状态, 0 表示是。time.daylight</li></ul><h3 id="时间模块的方法"><a href="#时间模块的方法" class="headerlink" title="时间模块的方法"></a>时间模块的方法</h3><ul><li><p>time.time()<br>返回值: 时间戳</p></li><li><p>localtime() 得到当前时间的时间结构<br>t = time.localtime()<br>print(t.tm_hour)</p></li><li><p>asctime() 返回元组的正常字符串化之后的时间格式<br>格式：time.asctime（时间元组）<br>返回值:字符串 Tue Jun  6 11:11:00 2017<br>t = time.localtime()<br>tt = time.asctime(t)</p></li><li><p>ctime: 获取字符串化的当前时间<br>格式：time.ctime()<br>返回值：字符串 Mon Mar 26 20:46:30 2018<br>t = time.ctime()</p></li><li><p>mktime() 使用时间元组获取对应的时间戳<br>格式：time.mktime（时间元组）<br>返回值：浮点数时间戳<br>lt = time.localtime()<br>ts = time.mktime(lt)</p></li><li><p>sleep: 使程序进入睡眠，n秒后继续<br>格式：sleep(5)</p></li><li><p>clock() 获取CPU时间<br>格式：time.clock()</p></li><li><p>strftime:将时间元组转化为自定义的字符串格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">格式  含义  备注</span><br><span class="line">%a  本地（locale）简化星期名称    </span><br><span class="line">%A  本地完整星期名称    </span><br><span class="line">%b  本地简化月份名称    </span><br><span class="line">%B  本地完整月份名称    </span><br><span class="line">%c  本地相应的日期和时间表示    </span><br><span class="line">%d  一个月中的第几天（01 - 31）   </span><br><span class="line">%H  一天中的第几个小时（24 小时制，00 - 23）   </span><br><span class="line">%I  一天中的第几个小时（12 小时制，01 - 12）   </span><br><span class="line">%j  一年中的第几天（001 - 366）  </span><br><span class="line">%m  月份（01 - 12） </span><br><span class="line">%M  分钟数（00 - 59）    </span><br><span class="line">%p  本地 am 或者 pm 的相应符    注1</span><br><span class="line">%S  秒（01 - 61）  注2</span><br><span class="line">%U  一年中的星期数（00 - 53 星期天是一个星期的开始）第一个星期天之前的所有天数都放在第 0 周   注3</span><br><span class="line">%w  一个星期中的第几天（0 - 6，0 是星期天） 注3</span><br><span class="line">%W  和 %U 基本相同，不同的是 %W 以星期一为一个星期的开始  </span><br><span class="line">%x  本地相应日期  </span><br><span class="line">%X  本地相应时间  </span><br><span class="line">%y  去掉世纪的年份（00 - 99）    </span><br><span class="line">%Y  完整的年份   </span><br><span class="line">%z  用 +HHMM 或 -HHMM 表示距离格林威治的时区偏移（H 代表十进制的小时数，M 代表十进制的分钟数）      </span><br><span class="line">%%  %号本身</span><br><span class="line"></span><br><span class="line"># 把时间表示成: 2018年3月26日 21:05</span><br><span class="line">t = time.localtime()</span><br><span class="line">ft = time.strftime(&quot;%Y年%m月%d日 %H:%M&quot; , t)</span><br></pre></td></tr></table></figure></li></ul><h2 id="datetime-模块"><a href="#datetime-模块" class="headerlink" title="datetime 模块"></a>datetime 模块</h2><ul><li>datetinme 提供日期和时间的运算和表示</li></ul><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><ul><li><p>datetime.today()<br>返回当前本地datetime.</p></li><li><p>datetime.fromtimestamp(time.time()). </p></li><li><p>datetime.now([tz])<br>返回当前本地日期和时间,如果可选参数tz为None或没有详细说明,这个方法会像today().  </p></li><li><p>datetime.utcnow()<br>返回当前的UTC日期和时间, 如果tzinfo None ,那么与now()类似.</p></li><li><p>datetime.fromtimestamp(timestamp[, tz])<br>根据时间戳返回本地的日期和时间.tz指定时区.</p></li><li><p>datetime.utcfromtimestamp(timestamp)<br>根据时间戳返回 UTC datetime.</p></li><li><p>datetime.fromordinal(ordinal)<br>根据Gregorian ordinal 返回datetime.</p></li><li><p>datetime.combine(date, time)<br>根据date和time返回一个新的datetime.</p></li><li><p>datetime.strptime(date_string, format)<br>根据date_string和format返回一个datetime.</p></li></ul><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul><li><p>datetime.date()<br>返回相同年月日的date对象.</p></li><li><p>datetime.time()<br>返回相同时分秒微秒的time对象.</p></li><li><p>datetime.replace(kw)<br>kw in [year, month, day, hour, minute, second, microsecond, tzinfo], 与date类似.</p></li></ul><h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><ul><li>datetime.min: datetime(MINYEAR, 1, 1).</li><li>datetime.max: datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999).</li></ul><h3 id="实例属性-read-only"><a href="#实例属性-read-only" class="headerlink" title="实例属性(read-only)"></a>实例属性(read-only)</h3><ul><li>datetime.year: 1 至 9999</li><li>datetime.month: 1 至 12</li><li>datetime.day: 1 至 n</li><li>datetime.hour: In range(24). 0 至 23</li><li>datetime.minute: In range(60).</li><li>datetime.second: In range(60).</li><li>datetime.microsecond: In range(1000000).</li></ul><h2 id="timeit-时间测量工具"><a href="#timeit-时间测量工具" class="headerlink" title="timeit-时间测量工具"></a>timeit-时间测量工具</h2><ul><li><p>测量程序运行时间间隔实验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import timeit</span><br><span class="line"></span><br><span class="line"># 生成列表两种方法的比较</span><br><span class="line"># 如果单纯比较生成一个列表的时间，可能很难实现</span><br><span class="line">c = &apos;&apos;&apos;</span><br><span class="line">sum = []</span><br><span class="line">for i in range(1000):</span><br><span class="line">    sum.append(i)</span><br><span class="line"> </span><br><span class="line"># 利用timeit调用代码，执行100000次，查看运行时间</span><br><span class="line">t1= timeit.timeit(stmt=&quot;[i for i in range(1000)]&quot;, number=100000 )</span><br><span class="line"></span><br><span class="line"># 测量代码c执行100000次运行结果</span><br><span class="line">t2 = timeit.timeit(stmt=c, number=100000)</span><br><span class="line">print(t1)</span><br><span class="line">print(t2)</span><br><span class="line"></span><br><span class="line">2.6834080209991953</span><br><span class="line">6.945136217000254</span><br></pre></td></tr></table></figure></li><li><p>timeit 可以执行一个函数，来测量一个函数的执行时间 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def doIt():</span><br><span class="line">    num = 3</span><br><span class="line">    for i in range(num):</span><br><span class="line">        print(&quot;Repeat for &#123;0&#125;&quot;.format(i))</span><br><span class="line">       </span><br><span class="line"># 执行函数，重复10次</span><br><span class="line">t = timeit.timeit(stmt=doIt, number=10)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">s = &apos;&apos;&apos;</span><br><span class="line">def doIt(num):</span><br><span class="line">    for i in range(num):</span><br><span class="line">        print(&quot;Repeat for &#123;0&#125;&quot;.format(i))</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line"># 执行doIt(num)</span><br><span class="line"># setup负责把环境变量准备好</span><br><span class="line"># 实际相当于给timeit创造了一个小环境</span><br><span class="line"># 在创作的小环境中， 代码执行的顺序大致是</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def doIt(num):</span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">num = 3</span><br><span class="line"></span><br><span class="line">doIt(num)</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">t = timeit.timeit(&quot;doIt(num)&quot;, setup=s+&quot;num=3&quot;, number=10)</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure></li></ul><h2 id="os-操作系统相关"><a href="#os-操作系统相关" class="headerlink" title="os - 操作系统相关"></a>os - 操作系统相关</h2><ul><li>跟操作系统相关，主要是文件操作</li><li>于系统相关的操作，主要包含在三个模块里<ul><li>os， 操作系统目录相关</li><li>os.path, 系统路径相关操作</li><li>shutil， 高级文件操作，目录树的操作，文件赋值，删除，移动</li></ul></li><li>路径：<ul><li>绝对路径： 总是从根目录上开始</li><li>相对路径： 基本以当前环境为开始的一个相对的地方</li></ul></li><li>import os</li></ul><h3 id="os-模块"><a href="#os-模块" class="headerlink" title="os 模块"></a>os 模块</h3><ul><li><p>getcwd() 获取当前的工作目录<br>格式：os.getcwd()<br>返回值：当前工作目录的字符串</p></li><li><p>chdir() 改变当前的工作目录<br>格式：os.chdir（路径）<br>返回值：无</p></li><li><p>listdir() 获取一个目录中所有子目录和文件的名称列表<br>格式:os.listdir(路径)<br>返回值：所有子目录和文件名称的列表</p></li><li><p>makedirs（） 递归创建文件夹<br>格式：os.makedirs(递归路径)<br>返回值：无<br>递归路径：多个文件夹层层包含的路径就是递归路径 例如 ‘a/b/c…’</p></li></ul><ul><li><p>system() 运行系统shell命令<br>格式：os.system(系统命令)<br>返回值：打开一个shell或者终端界面<br>一般推荐使用subprocess代替</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rst = os.system(&quot;ls&quot;)</span><br><span class="line">print(rst)</span><br></pre></td></tr></table></figure></li><li><p>getenv() 获取指定的系统环境变量值<br>相应的还有putenv<br>格式：os.getenv(‘环境变量名’)<br>返回值：指定环境变量名对应的值</p></li></ul><h3 id="值部分"><a href="#值部分" class="headerlink" title="值部分"></a>值部分</h3><ul><li>os.curdir: curretn dir,当前目录</li><li>os.pardir: parent dir， 父亲目录</li><li>os.sep: 当前系统的路径分隔符<ul><li>windows: “\”</li><li>linux: “/“</li></ul></li><li>os.linesep: 当前系统的换行符号<ul><li>windows: “\r\n”</li><li>unix,linux,macos: “\n”</li></ul></li><li>os.name： 当前系统名称<ul><li>windows： nt</li><li>mac，unix，linux： posix</li></ul></li></ul><h3 id="os-path-模块-路径相关的模块"><a href="#os-path-模块-路径相关的模块" class="headerlink" title="os.path 模块,路径相关的模块"></a>os.path 模块,路径相关的模块</h3><ul><li><p>abspath() 将路径转化为绝对路径<br>格式:os.path.abspath(‘路径’)<br>返回值：路径的绝对路径形式</p></li><li><p>basename() 获取路径中的文件名部分<br>格式:os.path.basename(路径)<br>返回值：文件名字符串</p></li><li><p>join() 将多个路径拼合成一个路径<br>格式：os.path.join(路径1，路径2….)<br>返回值：组合之后的新路径字符串</p></li><li><p>split() 将路径切割为文件夹部分和当前文件部分<br>格式:os.path.split（路径）<br>返回值：路径和文件名组成的元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t = op.split(&quot;/home/tlxy/dana.haha&quot;)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">d,p = op.split(&quot;/home/tlxy/dana.haha&quot;)</span><br><span class="line">print(d, p)</span><br><span class="line"></span><br><span class="line">(&apos;/home/tlxy&apos;, &apos;dana.haha&apos;)</span><br><span class="line">/home/tlxy dana.haha</span><br></pre></td></tr></table></figure></li><li><p>isdir() 检测是否是目录<br>格式：os.path.isdir(路径)<br>返回值：布尔值</p></li><li><p>jexists() 检测文件或者目录是否存在<br>格式：os.path.exists(路径)<br>返回值:布尔值</p></li></ul><h2 id="shutil-模块"><a href="#shutil-模块" class="headerlink" title="shutil 模块"></a>shutil 模块</h2><ul><li><p>copy() 复制文件<br>格式：shutil.copy(来源路径，目标路径)<br>返回值：返回目标路径<br>拷贝的同时，可以给文件重命名</p></li><li><p>copy2() 复制文件,(保留元数据文件信息）<br>格式：shutil.copy2(来源路径，目标路径)<br>返回值：返回目标路径<br>注意：copy和copy2的唯一区别在于copy2复制文件时尽量保留元数据</p></li><li><p>copyfile()将一个文件中的内容复制到另外一个文件当中<br>格式：shutil.copyfile（’源路径’,’目标路径’)<br>返回值：无</p></li><li><p>move() 移动文件/文件夹<br>格式：shutil.move(源路径，目标路径)<br>返回值：目标路径</p></li></ul><h2 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h2><ul><li><p>归档： 把多个文件或者文件夹合并到一个文件当中</p></li><li><p>make_archive() 归档操作<br>格式:shutil.make_archive(‘归档之后的目录和文件名’,’后缀’,’需要归档的文件夹’)<br>返回值：归档之后的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#help(shutil.make_archive)</span><br><span class="line"></span><br><span class="line"># 是想得到一个叫做tuling.zip的归档文件</span><br><span class="line">rst = shutil.make_archive(&quot;/home/tlxy/tuling&quot;, &quot;zip&quot;, &quot;/home/tlxy/dana&quot;)</span><br><span class="line">print(rst) # /home/tlxy/tuling.zip</span><br></pre></td></tr></table></figure></li><li><p>unpack_archive() 解包操作<br>格式：shutil.unpack_archive(‘归档文件地址’,’解包之后的地址’)<br>返回值：解包之后的地址</p></li></ul><h2 id="zip-压缩包"><a href="#zip-压缩包" class="headerlink" title="zip - 压缩包"></a>zip - 压缩包</h2><ul><li>压缩： 用算法把多个文件或者文件夹无损或者有损合并到一个文件当中</li><li><p>模块名称叫 zipfile</p></li><li><p>zipfile.ZipFile(file[, mode[, compression[, allowZip64]]])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个ZipFile对象，表示一个zip文件。参数file表示文件的路径或类文件对象(file-like object)；参数mode指示打开zip文件的模式，默认值为’r’，表示读已经存在的zip文件，也可以为’w’或’a’，’w’表示新建一个zip文档或覆盖一个已经存在的zip文档，’a’表示将数据附加到一个现存的zip文档中。参数compression表示在写zip文档时使用的压缩方法，它的值可以是zipfile. ZIP_STORED 或zipfile. ZIP_DEFLATED。如果要操作的zip文件大小超过2G，应该将allowZip64设置为True。</span><br><span class="line"></span><br><span class="line"># 对/home/tlxy/tuling.zip压缩</span><br><span class="line">zf = zipfile.ZipFile(&quot;/home/tlxy/tuling.zip&quot;)</span><br></pre></td></tr></table></figure></li><li><p>ZipFile.getinfo(name):<br>获取zip文档内指定文件的信息。返回一个zipfile.ZipInfo对象，它包括文件的详细信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rst = zf.getinfo(&quot;dana.haha&quot;)</span><br><span class="line">print(rst)</span><br><span class="line"></span><br><span class="line">&lt;ZipInfo filename=&apos;dana.haha&apos; compress_type=deflate filemode=&apos;-rw-rw-r--&apos; file_size=41 compress_size=46&gt;</span><br></pre></td></tr></table></figure></li><li><p>ZipFile.namelist()<br>获取zip文档内所有文件的名称列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nl = zf.namelist()</span><br><span class="line"></span><br><span class="line"># ZipFile.extractall([path[, members[, pwd]]])</span><br><span class="line">#  解压zip文档中的所有文件到当前目录。参数members的默认值为zip文档内的所有文件名称列表，也可以自己设置，选择要解压的文件名称。</span><br><span class="line"></span><br><span class="line">rst = zf.extractall(&quot;/home/tlxy/dana&quot;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><ul><li>随机数</li><li><p>所有的随机模块都是伪随机</p></li><li><p>random() 获取0-1之间的随机小数<br>格式：random.random()<br>返回值：随机0-1之间的小数</p></li><li><p>choice() 随机返回序列中的某个值<br>格式：random.choice(序列)<br>返回值：序列中的某个值</p></li></ul><ul><li><p>shuffle() 随机打乱列表<br>格式：random.shuffle(列表)<br>返回值：打乱顺序之后的列表</p></li><li><p>randint(a,b): 返回一个a到b之间的随机整数，包含a和b</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;常用模块&quot;&gt;&lt;a href=&quot;#常用模块&quot; class=&quot;headerlink&quot; title=&quot;常用模块&quot;&gt;&lt;/a&gt;常用模块&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;calendar&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.runoob.com/python
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 的异常处理</title>
    <link href="http://yoursite.com/2019/05/14/Python/03.High-level/02.Python%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/14/Python/03.High-level/02.Python的异常处理/</id>
    <published>2019-05-14T10:11:07.000Z</published>
    <updated>2019-05-23T06:19:16.041Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul><li>异常的分类</li><li>异常处理</li><li>异常手动抛出</li><li>自定义异常</li></ul><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><pre><code>AssertError 断言语句（assert）失败AttributeError 尝试访问未知的对象属性EOFError 用户输入文件末尾标志EOF（Ctrl+d）FloatingPointError 浮点计算错误GeneratorExit generator.close()方法被调用的时候ImportError 导入模块失败的时候IndexError 索引超出序列的范围KeyError 字典中查找一个不存在的关键字KeyboardInterrupt 用户输入中断键（Ctrl+c）MemoryError 内存溢出（可通过删除对象释放内存）NameError 尝试访问一个不存在的变量NotImplementedError 尚未实现的方法OSError 操作系统产生的异常（例如打开一个不存在的文件）OverflowError 数值运算超出最大限制ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象RuntimeError 一般的运行时错误StopIteration 迭代器没有更多的值SyntaxError Python的语法错误IndentationError 缩进错误TabError Tab和空格混合使用SystemError Python编译器系统错误SystemExit Python编译器进程被关闭TypeError 不同类型间的无效操作UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）UnicodeError Unicode相关的错误（ValueError的子类）UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）ValueError 传入无效的参数ZeroDivisionError 除数为零</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li>不能保证程序永远正确运行</li><li>但是，必须保证程序在最坏的情况下得到的问题被妥善处理</li><li><p>python的异常处理模块全部语法为：</p><pre><code>try:    尝试实现某个操作，    如果没出现异常，任务就可以完成    如果出现异常，将异常从当前代码块扔出去尝试解决异常except 异常类型1:    解决方案1：用于尝试在此处处理异常解决问题except 异常类型2：    解决方案2：用于尝试在此处处理异常解决问题except (异常类型1,异常类型2...)    解决方案：针对多个异常使用相同的处理方式excpet:    解决方案：所有异常的解决方案else:    如果没有出现任何异常，将会执行此处代码finally:    管你有没有异常都要执行的代码</code></pre></li></ul><ul><li>流程</li></ul><ol><li>执行try下面的语句</li><li>如果出现异常，则在except语句里查找对应异常病进行处理</li><li>如果没有出现异常，则执行else语句内容</li><li>最后，不管是否出现异常，都要执行finally语句</li></ol><ul><li>除except(最少一个)以外，else和finally可选<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 简单异常案例1</span><br><span class="line">try:</span><br><span class="line">    num = int(input(&quot;Plz input your number:&quot;))</span><br><span class="line">    rst = 100/num</span><br><span class="line">    print(&quot;计算结果是： &#123;0&#125;&quot;.format(rst))</span><br><span class="line">except:</span><br><span class="line">    print(&quot;你特娘的输入的啥玩意儿&quot;)</span><br><span class="line">    # exit是退出程序的意思</span><br><span class="line">    exit()</span><br><span class="line">  </span><br><span class="line">Plz input your number:0</span><br><span class="line">你特娘的输入的啥玩意儿  </span><br><span class="line">```    </span><br><span class="line">```   </span><br><span class="line"># 简单异常案例2</span><br><span class="line"># 给出提示信息</span><br><span class="line">try:</span><br><span class="line">    num = int(input(&quot;Plz input your number:&quot;))</span><br><span class="line">    rst = 100/num</span><br><span class="line">    print(&quot;计算结果是： &#123;0&#125;&quot;.format(rst))</span><br><span class="line"># 捕获异常后，把异常实例化，出息信息会在实例里</span><br><span class="line"># 注意以下写法</span><br><span class="line"># 以下语句是捕获ZeroDivisionError异常并实例化实例e</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&quot;你特娘的输入的啥玩意儿&quot;)</span><br><span class="line">    print(e)</span><br><span class="line">    # exit是退出程序的意思</span><br><span class="line">    exit()</span><br><span class="line">    </span><br><span class="line">Plz input your number:0</span><br><span class="line">你特娘的输入的啥玩意儿</span><br><span class="line">division by zero</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 简单异常案例3</span><br><span class="line"># 给出提示信息</span><br><span class="line">try:</span><br><span class="line">    num = int(input(&quot;Plz input your number:&quot;))</span><br><span class="line">    rst = 100/num</span><br><span class="line">    print(&quot;计算结果是： &#123;0&#125;&quot;.format(rst))</span><br><span class="line"></span><br><span class="line"># 如果是多种error的情况</span><br><span class="line"># 需要把越具体的错误，越往前放</span><br><span class="line"># 在异常类继承关系中，越是子类的异常，越要往前放，</span><br><span class="line"># 越是父亲类的异常，越要往后放</span><br><span class="line"></span><br><span class="line"># 在处理异常的时候，一旦拦截到某一个异常，则不在继续往下查看，直接进行下一个</span><br><span class="line"># 代码，即有finally则执行finally语句块，否则就执行下一个大的语句</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&quot;你特娘的输入的啥玩意儿&quot;)</span><br><span class="line">    print(e)</span><br><span class="line">    # exit是退出程序的意思</span><br><span class="line">    exit()</span><br><span class="line">except NameError as e:</span><br><span class="line">    print(&quot;名字起错了&quot;)</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">except AttributeError as e:</span><br><span class="line">    print(&quot;好像属性有问题&quot;)</span><br><span class="line">    print(e)</span><br><span class="line">    exit()</span><br><span class="line">    </span><br><span class="line"># 所有异常都是继承自Exception</span><br><span class="line"># 如果写上下面这句话，任何异常都会拦截住</span><br><span class="line"># 而且，下面这句话一定是最后一个exception</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(&quot;我也不知道就出错了&quot;)</span><br><span class="line">    print(e)</span><br><span class="line">    </span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&quot;NO&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;)</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">Plz input your number:rerer</span><br><span class="line">我也不知道就出错了</span><br><span class="line">invalid literal for int() with base 10: &apos;rerer&apos;  </span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">## 用户手动引发异常</span><br><span class="line">- 当某些情况，用户希望自己引发一个异常的时候，可以使用</span><br><span class="line">- raise 关键字来引发异常</span><br></pre></td></tr></table></figure><h1 id="raise案例-1"><a href="#raise案例-1" class="headerlink" title="raise案例-1"></a>raise案例-1</h1><p>try:</p><pre><code># 手动引发一个异常#　注意语法：　raise　errorclassnameraise ValueErrorprint(&quot;还没完呀&quot;)</code></pre><p>except NameError as e:<br>    print(“NameError”)<br>except ValueError as e:<br>    print(“ValueError”)<br>except Exception as e:<br>    print(“有异常”)<br>finally:<br>    print(“我肯定会被执行的”)</p><p>ValueError<br>我肯定会被执行的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="raise案例-2"><a href="#raise案例-2" class="headerlink" title="raise案例-2"></a>raise案例-2</h1><h1 id="自己定义异常"><a href="#自己定义异常" class="headerlink" title="自己定义异常"></a>自己定义异常</h1><h1 id="需要注意：-自定义异常必须是系统异常的子类"><a href="#需要注意：-自定义异常必须是系统异常的子类" class="headerlink" title="需要注意：　自定义异常必须是系统异常的子类"></a>需要注意：　自定义异常必须是系统异常的子类</h1><p>class DanaValueError(ValueError):<br>    pass</p><p>try:</p><pre><code># 手动引发一个异常#　注意语法：　raise　errorclassnameraise DanaValueErrorprint(&quot;还没完呀&quot;)</code></pre><p>except NameError as e:<br>    print(“NameError”)<br>except ValueError as e:<br>    print(“ValueError”)<br>except Exception as e:<br>    print(“有异常”)<br>finally:<br>    print(“我肯定会被执行的”)</p><p>ValueError<br>我肯定会被执行的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"># else语句案例</span><br><span class="line">try:</span><br><span class="line">    num = int(input(&quot;Plz input your number:&quot;))</span><br><span class="line">    rst = 100/num</span><br><span class="line">    print(&quot;计算结果是： &#123;0&#125;&quot;.format(rst))</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(&quot;Exception&quot;)</span><br><span class="line">    </span><br><span class="line">else:</span><br><span class="line">    print(&quot;No Exception&quot;)</span><br><span class="line">finally:</span><br><span class="line">    print(&quot;反正我会被执行&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Plz input your number:ghhj</span><br><span class="line">Exception</span><br><span class="line">反正我会被执行</span><br></pre></td></tr></table></figure></p><h2 id="关于自定义异常"><a href="#关于自定义异常" class="headerlink" title="关于自定义异常"></a>关于自定义异常</h2><ul><li>只要是raise异常，则推荐自定义异常</li><li>在自定义异常的时候，一般包含以下内容：<ul><li>自定义发生异常的异常代码</li><li>自定义发生异常后的问题提示</li><li>自定义发生异常的行数</li></ul></li><li>最终的目的是，一旦发生异常，方便程序员快速定位错误现场</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异常&quot;&gt;&lt;a href=&quot;#异常&quot; class=&quot;headerlink&quot; title=&quot;异常&quot;&gt;&lt;/a&gt;异常&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;异常的分类&lt;/li&gt;
&lt;li&gt;异常处理&lt;/li&gt;
&lt;li&gt;异常手动抛出&lt;/li&gt;
&lt;li&gt;自定义异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 的模块和包</title>
    <link href="http://yoursite.com/2019/05/10/Python/03.High-level/01.Python%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"/>
    <id>http://yoursite.com/2019/05/10/Python/03.High-level/01.Python的模块和包/</id>
    <published>2019-05-10T10:11:07.000Z</published>
    <updated>2019-05-23T06:08:43.294Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-的模块和包"><a href="#Python-的模块和包" class="headerlink" title="Python 的模块和包"></a>Python 的模块和包</h1><ul><li>模块</li><li>包  </li><li>命名空间</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul><li>一个模块就是一个包含pytho代码的文件， 后缀名成是.py就可以，模块就是个python文件</li><li><p>为什么我们用模块<br>程序太大，编写维护非常不方便，需要拆分<br>模块可以增加代码重复利用的方式<br>当做命名空间使用，避免命名冲突</p></li><li><p>如何定义模块<br>模块就是一个普通文件，所以任何代码可以直接书写<br>不过根据模块的规范，最好在模块中编写以下内容：<br>函数（单一功能）<br>类（相似功能的组合，或者类似业务模块）<br>测试代码</p></li><li><p>如何使用模块<br>模块直接导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import module_name</span><br><span class="line">module_name.function_name</span><br><span class="line">module_name.class_name</span><br></pre></td></tr></table></figure></li><li><p>假如模块名称直接以数字开头，借助importlib帮助</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 借助于importlib包可以实现导入以数字开头的模块名称</span><br><span class="line">import importlib</span><br><span class="line"></span><br><span class="line"># 相当于导入了一个叫01的模块并把导入模块赋值给了tuling</span><br><span class="line">tuling = importlib.import_module(&quot;01&quot;)</span><br><span class="line"></span><br><span class="line">stu = tuling.Student()</span><br><span class="line">stu.say()</span><br></pre></td></tr></table></figure></li><li><p>import 模块 as 别名<br>from module_name import func_name, class_name<br>按上述方法有选择性的导入<br>使用的时候可以直接使用导入的内容，不需要前缀</p></li><li><p>from module_name import *<br>导入模块所有内容</p></li><li><p><code>if __name__ == &quot;__main__</code> 的使用<br>可以有效避免模块代码被导入的时候被动执行的问题<br>建议所欲程序的入口都以此代码为入口</p></li></ul><h3 id="模块的搜索路径和存储"><a href="#模块的搜索路径和存储" class="headerlink" title="模块的搜索路径和存储"></a>模块的搜索路径和存储</h3><ul><li><p>什么是模块的搜索路径：<br>加载模块的时候，系统会在那些地方寻找此模块</p></li><li><p>系统默认的模块搜索路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path 属性可以获取路径列表</span><br></pre></td></tr></table></figure></li><li><p>添加搜索路径: sys.path.append(dir)</p></li><li><p>模块的加载顺序<br>搜索内存中已经加载好的模块<br>搜索python的内置模块<br>搜索sys.path路径 </p></li></ul><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul><li>包是一种组织管理代码的方式，包里面存放的是模块<br>-　用于将模块包含在一起的文件夹就是包  </li><li>自定义包的结构</li></ul><pre><code>|---包|---|--- __init__.py  包的标志文件|---|--- 模块1|---|--- 模块2|---|--- 子包(子文件夹)|---|---|--- __init__.py  包的标志文件|---|---|--- 子包模块1|---|---|--- 子包模块2</code></pre><ul><li><p>包的导入操作<br>import package_name<br>直接导入一个包，可以使用<strong>init</strong>.py中的内容<br>使用方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package_name.func_name</span><br><span class="line">package_name.class_name.func_name()</span><br></pre></td></tr></table></figure></li><li><p>import package_name as p<br>注意:此种方法是默认对<strong>init</strong>.py内容的导入    </p></li><li><p>import package.module<br>导入包中某一个具体的模块<br>使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package.module.func_name</span><br><span class="line">package.module.class.fun()</span><br><span class="line">package.module.class.var</span><br></pre></td></tr></table></figure></li><li><p>import package.module as pm </p></li><li><p>from … import 导入<br>from package import module1, module2, module3<br>此种导入方法不执行<code>__init__</code>的内容</p></li><li><p>from package import *<br>导入当前包 <code>__init__.py</code>文件中所有的函数和类<br>使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func_name()</span><br><span class="line">class_name.func_name()</span><br><span class="line">class_name.var</span><br></pre></td></tr></table></figure></li><li><p>from package.module import *<br>导入包中指定的模块的所有内容<br>使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func_name()</span><br><span class="line">class_name.func_name()</span><br></pre></td></tr></table></figure></li><li><p>在开发环境中经常会所以用其他模块，可以在当前包中直接导入其他模块中的内容</p></li><li><p>import 完整的包或者模块的路径</p></li><li><p><code>__all__</code> 的用法<br>在使用from package import <em> 的时候， </em> 可以导入的内容  </p></li><li><p><code>__init__.py</code>中如果文件为空， 或者没有 <code>__all__</code>， 那么只可以把<code>__init__</code>中的内容导入</p></li><li><p><code>__init__</code> 如果设置了<code>__all__</code>的值，那么则按照<code>__all__</code> 指定的子包或者模块进行加载<br>  如此则不会载入<code>__init__</code>中的内容</p></li><li><p><code>__all__=[&#39;module1&#39;, &#39;module2&#39;, &#39;package1&#39;.........]</code></p></li></ul><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul><li>用于区分不同位置不同功能但相同名称的函数或者变量的一个特定前缀</li><li>作用是防止命名冲突<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setName()</span><br><span class="line">Student.setName()</span><br><span class="line">Dog.setName()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python-的模块和包&quot;&gt;&lt;a href=&quot;#Python-的模块和包&quot; class=&quot;headerlink&quot; title=&quot;Python 的模块和包&quot;&gt;&lt;/a&gt;Python 的模块和包&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;模块&lt;/li&gt;
&lt;li&gt;包  &lt;/li&gt;
&lt;li
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://yoursite.com/2019/05/01/Linux/01/"/>
    <id>http://yoursite.com/2019/05/01/Linux/01/</id>
    <published>2019-05-01T10:11:07.000Z</published>
    <updated>2019-05-23T09:18:39.443Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus</title>
    <link href="http://yoursite.com/2019/05/01/Prometheus/01.pro/"/>
    <id>http://yoursite.com/2019/05/01/Prometheus/01.pro/</id>
    <published>2019-05-01T10:11:07.000Z</published>
    <updated>2019-05-23T09:17:15.565Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Prometheus" scheme="http://yoursite.com/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="http://yoursite.com/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Zabbix 的面向对象</title>
    <link href="http://yoursite.com/2019/05/01/Zabbix/01/"/>
    <id>http://yoursite.com/2019/05/01/Zabbix/01/</id>
    <published>2019-05-01T10:11:07.000Z</published>
    <updated>2019-05-23T09:19:14.593Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Zabbix" scheme="http://yoursite.com/categories/Zabbix/"/>
    
    
      <category term="Zabbix" scheme="http://yoursite.com/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>Python 的面向对象</title>
    <link href="http://yoursite.com/2019/05/01/Python/02.Oop/01.Python%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/05/01/Python/02.Oop/01.Python的面向对象/</id>
    <published>2019-05-01T10:11:07.000Z</published>
    <updated>2019-05-23T06:08:13.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OOP-Python面向对象"><a href="#OOP-Python面向对象" class="headerlink" title="OOP-Python面向对象"></a>OOP-Python面向对象</h1><ul><li>Python的面向对象<ul><li>OO</li><li>类的基本实现</li><li>类和对象的成员分析</li><li>self</li></ul></li><li>面向对象编程<ul><li>基础</li><li>公有私有</li><li>继承</li><li>多态、Mixin</li><li>类的相关函数、类的成员描述符、类的内置属性</li><li>魔法函数</li><li>类和对象的三种方法</li><li>抽象类</li><li>自定义类</li></ul></li></ul><h1 id="Python的面向对象"><a href="#Python的面向对象" class="headerlink" title="Python的面向对象"></a>Python的面向对象</h1><h2 id="面向对象概述（ObjectOriented，OO）"><a href="#面向对象概述（ObjectOriented，OO）" class="headerlink" title="面向对象概述（ObjectOriented，OO）"></a>面向对象概述（ObjectOriented，OO）</h2><ul><li><p>OOP思想<br>接触到任意一个任务，首先想到的是任务这个世界的构成，是由模型构成的<br>OO:面向对象<br>OOA：面向对象的分析<br>OOD：面向对象的设计<br>OOI：xxx的实现<br>OOP：xxx的编程<br>OOA-&gt;OOD-&gt;OOI: 面向对象的实现过程</p></li><li><p>类和对象的概念<br>类：抽象名词，代表一个集合，共性的事物<br>对象：具象的事物，单个个体<br>类跟对象的关系<br>一个具象，代表一类事物的某一个个体<br>一个是抽象，代表的是一大类事物</p></li><li><p>类中的内容，应该具有两个内容<br>表明事物的特征，叫做属性(变量)<br>表明事物功能或动作， 称为成员方法(函数)</p></li></ul><h2 id="类的基本实现"><a href="#类的基本实现" class="headerlink" title="类的基本实现"></a>类的基本实现</h2><ul><li><p>类的命名<br>遵守变量命名的规范<br>大驼峰（由一个或者多个单词构成，每个单词首字母大写，单词跟单词直接相连）<br>尽量避开跟系统命名相似的命名</p></li><li><p>你如何声明一个类<br>class关键字<br>类由属性和方法构成，其他不允许出现<br>成员属性定义可以直接使用变量赋值，如果没有值，许使用None</p></li><li><p>实例化类</p><pre><code>变量 = 类名() #实例化了一个对象</code></pre></li><li><p>访问对象成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.成员属性名称  </span><br><span class="line">obj.成员方法</span><br></pre></td></tr></table></figure></li><li><p>对象的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># dict前后各有两个下划线</span><br><span class="line">obj.__dict__</span><br></pre></td></tr></table></figure></li><li><p>类的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># dict前后各有两个下划线</span><br><span class="line">class_name.__dict__</span><br></pre></td></tr></table></figure></li></ul><h2 id="类和对象的成员分析"><a href="#类和对象的成员分析" class="headerlink" title="类和对象的成员分析"></a>类和对象的成员分析</h2><ul><li>类和对象都可以存储成员，成员可以归类所有，也可以归对象所有</li><li>类存储成员时使用的是与类关联的一个对象</li><li>独享存储成员是是存储在当前对象中</li><li>对象访问一个成员时，如果对象中没有该成员，尝试访问类中的同名成员， 如果对象中有此成员，一定使用对象中的成员</li><li><p>创建对象的时候，类中的成员不会放入对象当中，而是得到一个空对象，没有成员 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    name = &quot;kobe&quot;</span><br><span class="line">    number = 24</span><br><span class="line"></span><br><span class="line"># A 称为类实例    </span><br><span class="line">print (&quot;A&quot;,A.name,id(A.name))</span><br><span class="line">print (&quot;A&quot;,A.number,id(A.number))</span><br><span class="line">print(&quot;*&quot; * 20)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print (&quot;a&quot;,a.name,id(a.name))</span><br><span class="line">print (&quot;a&quot;,a.number,id(a.number))</span><br><span class="line"></span><br><span class="line"># 查看所有的属性</span><br><span class="line">print (&quot;A&quot;,A.__dict__)</span><br><span class="line">print (&quot;a&quot;,a.__dict__)  #&#123;&#125; 空  </span><br><span class="line"></span><br><span class="line"># 在不对对象的实例属性赋值的前提下，类实例的属性和其对象实例的属性指向同一个变量</span><br><span class="line"></span><br><span class="line">A kobe 140589649254976</span><br><span class="line">A 24 9306720</span><br><span class="line">********************</span><br><span class="line">a kobe 140589649254976</span><br><span class="line">a 24 9306720</span><br><span class="line">A &#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;name&apos;: &apos;kobe&apos;, &apos;number&apos;: 24, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;A&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;A&apos; objects&gt;, &apos;__doc__&apos;: None&#125;</span><br><span class="line">a &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过对象对类中成员重新赋值或者通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">案例:</span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    name = &quot;kobe&quot;</span><br><span class="line">    number = 24</span><br><span class="line">    </span><br><span class="line"># A 称为类实例    </span><br><span class="line">print (&quot;A&quot;,A.name,id(A.name))</span><br><span class="line">print (&quot;A&quot;,A.number,id(A.number))</span><br><span class="line">print(&quot;*&quot; * 20)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print (&quot;a&quot;,a.name,id(a.name))</span><br><span class="line">print (&quot;a&quot;,a.number,id(a.number))</span><br><span class="line"></span><br><span class="line">## 查看所有的属性</span><br><span class="line">print (&quot;A&quot;,A.__dict__)</span><br><span class="line">print (&quot;a&quot;,a.__dict__)  #&#123;&#125;   </span><br><span class="line">print(&quot;*&quot; * 20)</span><br><span class="line"></span><br><span class="line">#赋值</span><br><span class="line">a.name  =  &quot;Owen&quot;</span><br><span class="line">a.number = 11</span><br><span class="line"></span><br><span class="line">print (&quot;a&quot;,a.name,id(a.name))</span><br><span class="line">print (&quot;a&quot;,a.number,id(a.number))</span><br><span class="line">print (&quot;a&quot;,a.__dict__)</span><br><span class="line"></span><br><span class="line">#通过对象对类中成员重新赋值或者通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员</span><br><span class="line"></span><br><span class="line">A kobe 140589649254976</span><br><span class="line">A 24 9306720</span><br><span class="line">********************</span><br><span class="line">a kobe 140589649254976</span><br><span class="line">a 24 9306720</span><br><span class="line">A &#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;name&apos;: &apos;kobe&apos;, &apos;number&apos;: 24, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;A&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;A&apos; objects&gt;, &apos;__doc__&apos;: None&#125;</span><br><span class="line">a &#123;&#125;</span><br><span class="line">********************</span><br><span class="line">a Owen 140589649496696</span><br><span class="line">a 11 9306304</span><br><span class="line">a &#123;&apos;name&apos;: &apos;Owen&apos;, &apos;number&apos;: 11&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="关于self"><a href="#关于self" class="headerlink" title="关于self"></a>关于self</h2><ul><li>self在对象的方法中表示当前对象本身，如果通过对象调用一个方法，那么该对象会自动传入到当前方法的第一个参数中 </li><li><p>self并不是关键字，只是一个用于接受对象的普通参数，理论上可以用任何一个普通变量名代替</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">案例:</span><br><span class="line">class Student():</span><br><span class="line">    name = &quot;dana&quot;</span><br><span class="line">    age = 18</span><br><span class="line">    </span><br><span class="line">    # 注意say的写法，参数有一个self</span><br><span class="line">    def say(self):</span><br><span class="line">        self.age = 200</span><br><span class="line">        print(&quot;My age is &#123;0&#125;&quot;.format(self.age))</span><br><span class="line">    # 任何一个普通变量名代替self    </span><br><span class="line">    def sayAgain(s):</span><br><span class="line">        print(&quot;My age is &#123;0&#125;&quot;.format(s.age))</span><br><span class="line">          </span><br><span class="line">yueyue = Student()</span><br><span class="line">yueyue.say()</span><br><span class="line">yueyue.sayAgain()</span><br><span class="line"></span><br><span class="line">My age is 200</span><br><span class="line">My age is 200</span><br></pre></td></tr></table></figure></li><li><p>方法中有self形参的方法是非绑定类的方法，可以通过对象访问； 没有self的是绑定类的方法，只能通过类访问</p></li><li><p>类方法中需要访问当前类的成员，可以通过 <strong>class</strong>成员名来访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Teacher():</span><br><span class="line">    name = &quot;dana&quot;</span><br><span class="line">    age = 19</span><br><span class="line">    </span><br><span class="line">    def say(self):</span><br><span class="line">        self.name = &quot;yaona&quot;</span><br><span class="line">        self.age = 17</span><br><span class="line">        print(&quot;My name is &#123;0&#125;&quot;.format(self.name))</span><br><span class="line">        # 调用类的成员变量需要用 __class__</span><br><span class="line">        print(&quot;My age is &#123;0&#125;&quot;.format(__class__.age))</span><br><span class="line">    def sayAgain():</span><br><span class="line">        print(__class__.name)</span><br><span class="line">        print(__class__.age )</span><br><span class="line">        print(&quot;Hello, nice to see you again&quot;)</span><br><span class="line">        </span><br><span class="line">t = Teacher()</span><br><span class="line">t.say()</span><br><span class="line"></span><br><span class="line"># 调用绑定类函数使用类名</span><br><span class="line">Teacher.sayAgain()</span><br><span class="line"></span><br><span class="line"># 如果类方法中需要访问当前类的成员，可以通过 __class__成员名来访问</span><br><span class="line"></span><br><span class="line">My name is yaona</span><br><span class="line">My age is 19</span><br><span class="line">dana</span><br><span class="line">19</span><br><span class="line">Hello, nice to see you again</span><br></pre></td></tr></table></figure></li><li><p>关于self的案例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 案例:</span><br><span class="line">class A():</span><br><span class="line">    name = &quot; liuying&quot;</span><br><span class="line">    age = 18</span><br><span class="line">    </span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &quot;aaaa&quot;</span><br><span class="line">        self.age = 200</span><br><span class="line">        </span><br><span class="line">    def say(self):</span><br><span class="line">        print(self.name)</span><br><span class="line">        print(self.age)</span><br><span class="line">        </span><br><span class="line">class B():</span><br><span class="line">    name = &quot;bbbb&quot;</span><br><span class="line">    age = 90</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"># 此时，系统会默认把对象a作为第一个参数传入函数</span><br><span class="line">a.say()</span><br><span class="line">   </span><br><span class="line">A.say()    #错误，类实例不会自动传入第一个参数，需要手动传入一个</span><br><span class="line"># 此时，self被a替换</span><br><span class="line">A.say(a)</span><br><span class="line"># 同样可以把A作为参数传入</span><br><span class="line">A.say(A)</span><br><span class="line"></span><br><span class="line"># 此时，传入的是类实例B，因为B具有name和age属性，所以不会报错</span><br><span class="line">A.say(B)</span><br><span class="line"></span><br><span class="line"># 以上代码，利用了鸭子模型</span><br><span class="line"></span><br><span class="line">aaaa</span><br><span class="line">200</span><br><span class="line">aaaa</span><br><span class="line">200</span><br><span class="line">liuying</span><br><span class="line">18</span><br><span class="line">bbbb</span><br><span class="line">90</span><br></pre></td></tr></table></figure></li></ul><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><ul><li>面向对象的三大特性：封装、继承、多态</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li>将属性和方法封装到一个抽象的类中</li><li><p>封装的三个级别：<br>公开，public<br>受保护的，protected<br>私有的，private<br>public，private，protected不是关键字</p></li><li><p>判别对象的位置<br>对象内部<br>对象外部<br>子类中</p></li><li><p><a href="http://blog.csdn.net/handsomekang/article/details/40303207" target="_blank" rel="noopener">python中下划线使用</a></p></li><li><p>私有<br>私有成员是最高级别的封装，只能在当前类或对象中访问<br>在成员前面添加两个两个下划线即可: __age<br>Python的私有不是真私有，是一种成为name mangling的改名策略<br>可以使用:对象._classname_attributename访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 案例:</span><br><span class="line"></span><br><span class="line"># __age是私有变量,不能直接访问。</span><br><span class="line">print(p.__age)  #注意报错信息</span><br><span class="line">        </span><br><span class="line"># name mangling技术     </span><br><span class="line">print(Person.__dict__)</span><br><span class="line">p._Person__age = 19</span><br><span class="line">print(p._Person__age)</span><br><span class="line">        </span><br><span class="line">&#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;name&apos;: &apos;liuying&apos;, &apos;_Person__age&apos;: 18, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Person&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Person&apos; objects&gt;, &apos;__doc__&apos;: None&#125;</span><br><span class="line">19</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>受保护的封装  protected<br>受保护的封装是将对象成员进行一定级别的封装，然后，在类中或者子类中都可以进行访问，但是在外部不可以<br>封装方法： 在成员名称前添加一个下划线即可<br>name mangling的改名策略<br>可以使用:对象._classname_attributename访问</p></li><li><p>公开的，公共的 public<br>公共的封装实际对成员没有任何操作，任何地方都可以访问  </p></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>继承就是一个类可以获得另外一个类中的成员属性和成员方法</li><li><p>作用： 减少代码，增加代码的复用功能， 同时可以设置类与类直接的关系</p></li><li><p>继承与被继承的概念：<br>被继承的类叫父类，也叫基类，也叫超类<br>用于继承的类，叫子类，也叫派生类<br>继承与被继承一定存在一个 is-a 关系</p></li><li><p>继承的语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#父类写在括号内</span><br><span class="line">class Teacher(Person):</span><br></pre></td></tr></table></figure></li><li><p>继承的特征<br>所有的类都继承自object类，即所有的类都是object类的子类<br>子类一旦继承父类，则可以使用父类中除私有成员外的所有内容<br>子类继承父类后并没有将父类成员完全赋值到子类中，而是通过引用关系访问调用<br>子类中可以定义独有的成员属性和方法<br>子类中定义的成员和父类成员如果相同，则优先使用子类成员<br>子类如果想扩充父类的方法，可以在定义新方法的同时访问父类成员来进行代码重用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[父类名.父类成员]的格式来调用父类成员</span><br><span class="line">super().父类成员的格式来调用</span><br></pre></td></tr></table></figure></li><li><p>子类扩充父类功能的案例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 人由工作的函数， 老师也由工作的函数，但老师的工作需要讲课</span><br><span class="line">class Person():</span><br><span class="line">    name = &quot;NoName&quot;</span><br><span class="line">    age = 18</span><br><span class="line">    __score = 0 # 考试成绩是秘密，只要自己知道</span><br><span class="line">    _petname = &quot;sec&quot; #小名，是保护的，子类可以用，但不能公用</span><br><span class="line">    def sleep(self):</span><br><span class="line">        print(&quot;Sleeping ... ...&quot;)</span><br><span class="line">    def work(self):</span><br><span class="line">        print(&quot;make some money&quot;)</span><br><span class="line">        </span><br><span class="line">#父类写在括号内</span><br><span class="line">class Teacher(Person):</span><br><span class="line">    teacher_id = &quot;9527&quot;</span><br><span class="line">    name = &quot;DaNa&quot;</span><br><span class="line">    def make_test(self):</span><br><span class="line">        print(&quot;attention&quot;)</span><br><span class="line">        </span><br><span class="line">    def work(self):</span><br><span class="line">        # 扩充父类的功能只需要调用父类相应的函数</span><br><span class="line">        #Person.work(self)</span><br><span class="line">        # 扩充父类的另一种方法</span><br><span class="line">        # super代表得到父类</span><br><span class="line">        super().work()</span><br><span class="line">        self.make_test()</span><br><span class="line">        </span><br><span class="line">t = Teacher()</span><br><span class="line">t.work()</span><br><span class="line"></span><br><span class="line">make some money</span><br><span class="line">attention</span><br></pre></td></tr></table></figure></li><li><p>继承变量函数的查找顺序问题<br>优先查找自己的变量<br>没有则查找父类<br>构造函数如果本类中没有定义，则自动查找调用父类构造函数<br>如果本类有定义，则不在继续向上查找</p></li><li><p>构造函数<br>是一类特殊的函数，在类进行实例化之前进行调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line">class Dog():</span><br><span class="line"># __init__就是构造函数</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;I am init in dog&quot;)</span><br><span class="line"></span><br><span class="line"># 实例话的时候，括号内的参数需要跟构造函数参数匹配</span><br><span class="line">kaka = Dog()</span><br><span class="line">    </span><br><span class="line">I am init in dog</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>构造函数查找顺序<br>如果定义了构造函数，则实例化时使用构造函数，不查找父类构造函数<br>如果没定义，则自动查找父类构造函数<br>如果子类没定义，父类的构造函数带参数，则构造对象时的参数应该按父类参数构造 </p></li><li><p>super<br>super不是关键字， 而是一个类<br>super的作用是获取MRO（MethodResolustionOrder）列表中的第一个类<br>super于父类直接没任何实质性关系，但通过super可以调用到父类<br>super使用的两个方法,参见在构造函数中调用父类的构造函数</p></li><li><p>单继承和多继承<br>单继承：每个类只能继承一个类<br>多继承，每个类允许继承多个类</p></li><li><p>单继承和多继承的优缺点<br>单继承：<br>优点：传承有序逻辑清晰语法简单隐患少呀<br>缺点：功能不能无限扩展，只能在当前唯一的继承链中扩展<br>多继承：<br>优点：类的功能扩展方便<br>缺点：继承关系混乱</p></li><li><p>菱形继承/钻石继承问题<br>多个子类继承自同一个父类，这些子类由被同一个类继承，于是继承关系图形成一个菱形图谱<br><a href="https://www.cnblogs.com/whatisfantasy/p/6046991.html" target="_blank" rel="noopener">MRO</a><br>关于多继承的MRO<br>MRO就是多继承中，用于保存继承顺序的一个列表<br>python本身采用C3算法来多多继承的菱形继承进行计算的结果</p></li><li><p>MRO列表的计算原则：<br>子类永远在父类前面<br>如果多个父类，则根据继承语法中括号内类的书写顺序存放<br>如果多个类继承了同一个父类，孙子类中只会选取继承语法括号中第一个父类的父类</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">案例：扩展构造函数</span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;A&quot;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        print(&quot;B&quot;)</span><br><span class="line">        print(name)</span><br><span class="line">        </span><br><span class="line">class C(B):</span><br><span class="line">    # c中想扩展B的构造函数，</span><br><span class="line">    # 即调用B的构造函数后在添加一些功能</span><br><span class="line">    # 由两种方法实现</span><br><span class="line">    </span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    # 第一种是通过父类名调用</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        # 首先调用父类构造函数</span><br><span class="line">        B.__init__(self, name)</span><br><span class="line">        # 其次，再增加自己的功能</span><br><span class="line">        print(&quot;这是C中附加的功能&quot;)</span><br><span class="line">    &apos;&apos;&apos;  </span><br><span class="line">        </span><br><span class="line">    # 第二种，使用super调用</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        # 首先调用父类构造函数</span><br><span class="line">        super(C, self).__init__(name)</span><br><span class="line">        # 其次，再增加自己的功能</span><br><span class="line">        print(&quot;这是C中附加的功能&quot;)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"># 此时，首先查找C的构造函数</span><br><span class="line"># 如果没有，则向上按照MRO顺序查找父类的构造函数，知道找到为止</span><br><span class="line"># 此时，会出现参数结构不对应错误</span><br><span class="line">c = C(&quot;我是C&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B</span><br><span class="line">我是C</span><br><span class="line">这是C中附加的功能</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>不同的子类对象调用相同的父类方法，产生不同的执行结果</li><li>以继承和重写父类方法为前提</li><li>多态性：同一种调用方式，产生不同的执行效果</li><li><a href="https://www.cnblogs.com/luchuangao/p/6739557.html" target="_blank" rel="noopener">多态和多态性</a></li><li>Mixin设计模式<br>主要采用多继承方式对类的功能进行扩展<br><a href="https://www.zhihu.com/question/20778853" target="_blank" rel="noopener">Mixin概念</a><br><a href="http://blog.csdn.net/robinjwong/article/details/48375833" target="_blank" rel="noopener">MRO and Mixin</a><br><a href="https://www.cnblogs.com/xybaby/p/6484262.html" target="_blank" rel="noopener">Mixin模式</a><br><a href="http://runforever.github.io/2014-07-19/2014-07-19-python-mixin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">Mixin MRO</a><br><a href="http://xiaocong.github.io/blog/2012/06/13/python-mixin-and-mro/" target="_blank" rel="noopener">MRO</a>    </li><li>我们使用多继承语法来实现Minxin</li><li>使用Mixin实现多继承的时候非常小心<br>首先他必须表示某一单一功能，而不是某个物品<br>职责必须单一，如果由多个功能，则写多个Mixin<br>Mixin不能依赖于子类的实现<br>子类及时没有继承这个Mixin类， 也能照样工作，只是缺少了某个功能</li><li>优点<br>使用Mixin可以在不对类进行任何修改的情况下，扩充功能<br>可以方便的组织和维护不同功能组件的划分<br>可以根据需要任意调整功能类的组合<br>可以避免创建很多新的类，导致类的继承混乱</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># Mixin案例</span><br><span class="line"></span><br><span class="line">class Person():</span><br><span class="line">                name = &quot;liuying&quot;</span><br><span class="line">                age = 18</span><br><span class="line"></span><br><span class="line">                def eat(self):</span><br><span class="line">                    print(&quot;EAT.......&quot;)</span><br><span class="line">                    </span><br><span class="line">                def drink(self):</span><br><span class="line">                    print(&quot;DRINK......&quot;)</span><br><span class="line">                    </span><br><span class="line">                def sleep(self):</span><br><span class="line">                    print(&quot;SLEEP.....&quot;)</span><br><span class="line">                </span><br><span class="line">class Teacher(Person):</span><br><span class="line">                def work(self):</span><br><span class="line">                    print(&quot;Work&quot;)</span><br><span class="line"></span><br><span class="line">class Student(Person):</span><br><span class="line">                def study(self):</span><br><span class="line">                    print(&quot;Study&quot;)</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">class Tutor(Teacher, Student):</span><br><span class="line">                pass</span><br><span class="line"></span><br><span class="line">t = Tutor()</span><br><span class="line">             </span><br><span class="line">print(Tutor.__mro__)</span><br><span class="line">print(t.__dict__)</span><br><span class="line">print(Tutor.__dict__)</span><br><span class="line"></span><br><span class="line">print(&quot;*&quot;*20)</span><br><span class="line">class TeacherMixin():</span><br><span class="line">                def work(self):</span><br><span class="line">                    print(&quot;Work&quot;)</span><br><span class="line"></span><br><span class="line">class StudentMixin():</span><br><span class="line">                def study(self):</span><br><span class="line">                    print(&quot;Study&quot;)</span><br><span class="line">                    </span><br><span class="line">class TutorM(Person, TeacherMixin, StudentMixin):</span><br><span class="line">                pass</span><br><span class="line"></span><br><span class="line">tt = TutorM()</span><br><span class="line">print(TutorM.__mro__)</span><br><span class="line">print(tt.__dict__)</span><br><span class="line">print(TutorM.__dict__)</span><br></pre></td></tr></table></figure><h2 id="类相关函数"><a href="#类相关函数" class="headerlink" title="类相关函数"></a>类相关函数</h2><ul><li>issubclass:检测一个类是否是另一个类的子类</li><li>isinstance:检测一个对象是否是一个类的实例</li><li>hasattr:检测一个对象是否由成员xxx</li><li>getattr: get attribute</li><li>setattr: set attribute</li><li>delattr: delete attribute</li><li>dir: 获取对象的成员列表</li></ul><h2 id="类的成员描述符（属性）"><a href="#类的成员描述符（属性）" class="headerlink" title="类的成员描述符（属性）"></a>类的成员描述符（属性）</h2><ul><li><p>类的成员描述符是为了在类中对类的成员属性进行相关操作而创建的一种方式<br>get： 获取属性的操作<br>set：修改或者添加属性操作<br>delete： 删除属性的操作</p></li><li><p>如果想使用类的成员描述符，大概有三种方法<br>使用类实现描述器<br>使用属性修饰符<br>使用property函数:property(fget, fset, fdel, doc) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># peroperty案例</span><br><span class="line"></span><br><span class="line"># 定义一个Person类，具有name，age属性</span><br><span class="line"># 对于任意输入的姓名，我们希望都用大写方式保存</span><br><span class="line"># 年龄，我们希望内部统一用整数保存</span><br><span class="line"># x = property(fget, fset, fdel, doc)</span><br><span class="line">class Person():</span><br><span class="line"></span><br><span class="line">    # 函数的名称可以任意</span><br><span class="line">    def fget(self):</span><br><span class="line">        return self._name * 2</span><br><span class="line">    </span><br><span class="line">    def fset(self, name):</span><br><span class="line">        # 所有输入的姓名以大写形式保存</span><br><span class="line">        self._name = name.upper()</span><br><span class="line">        </span><br><span class="line">    def fdel(self):</span><br><span class="line">        self._name = &quot;NoName&quot;</span><br><span class="line">    </span><br><span class="line">    name2 = property(fget, fset, fdel, &quot;对name进行下下操作啦&quot;)</span><br></pre></td></tr></table></figure></li><li><p>无论哪种修饰符都是为了对成员属性进行相应的控制<br>类的方式： 适合多个类中的多个属性共用用一个描述符<br>property：使用当前类中使用，可以控制一个类中多个属性<br>属性修饰符： 使用于当前类中使用，控制一个类中的一个属性</p></li></ul><h2 id="类的内置属性"><a href="#类的内置属性" class="headerlink" title="类的内置属性"></a>类的内置属性</h2><ul><li><p><strong>dict</strong><br>以字典的方式显示类的成员组成</p></li><li><p><strong>doc</strong>:<br>获取类的文档信息</p></li><li><p><strong>name</strong><br>获取类的名称，如果在模块中使用，获取模块的名称</p></li><li><p><strong>bases</strong><br>获取某个类的所有父类，以元组的方式显示</p></li></ul><h2 id="7-类的常用魔术方法"><a href="#7-类的常用魔术方法" class="headerlink" title="7 类的常用魔术方法"></a>7 类的常用魔术方法</h2><ul><li>魔术方法就是不需要人为调用的方法，基本是在特定的时刻自动触发</li><li>魔术方法的统一的特征，方法名被前后各两个下滑线包裹</li><li>操作类<br><code>__init__</code>: 构造函数<br><code>__new__</code>: 对象实例化方法，此函数较特殊，一般不需要使用<br><code>__call__</code>: 对象当函数使用的时候触发<br><code>__str__</code>: 当对象被当做字符串使用的时候调用<br><code>__repr__</code>: 返回字符串 </li></ul><ul><li>描述符相关<br><code>__set__</code><br><code>__get__</code><br><code>__delete__</code></li></ul><ul><li><p>属性操作相关<br><code>__getattr__</code>: 访问一个不存在的属性时触发<br><code>__setattr__</code>: 对成员属性进行设置的时候触发<br>参数：<br>self用来获取当前对象<br>被设置的属性名称，以字符串形式出现<br>需要对属性名称设置的值<br>作用：进行属性设置的时候进行验证或者修改<br>注意： 在该方法中不能对属性直接进行赋值操作，否则死循环 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># __setattr__案例</span><br><span class="line"></span><br><span class="line">class Person():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    def __setattr__(self, name, value):</span><br><span class="line">        print(&quot;设置属性： &#123;0&#125;&quot;.format(name))</span><br><span class="line">        # 下面语句会导致问题，死循环</span><br><span class="line">        #self.name = value</span><br><span class="line">        </span><br><span class="line">        # 此种情况，为了避免死循环，规定统一调用父类魔法函数</span><br><span class="line">        super().__setattr__(name, value)</span><br><span class="line">        </span><br><span class="line">p = Person()</span><br><span class="line">print(p.__dict__)</span><br><span class="line">p.age = 18</span><br></pre></td></tr></table></figure></li><li><p>运算分类相关魔术方法<br><code>__gt__</code>: 进行大于判断的时候触发的函数<br>参数：<br>self<br>第二个参数是第二个对象<br>返回值:可以是任意值，推荐返回布尔值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># __gt__</span><br><span class="line"></span><br><span class="line">class Student():</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self._name = name</span><br><span class="line">    </span><br><span class="line">    def __gt__(self, obj):</span><br><span class="line">        print(&quot;哈哈， &#123;0&#125; 会比 &#123;1&#125; 大吗？&quot;.format(self, obj))</span><br><span class="line">        return self._name &gt; obj._name</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">stu1 = Student(&quot;one&quot;)</span><br><span class="line">stu2 = Student(&quot;two&quot;)</span><br><span class="line"></span><br><span class="line">print(stu1 &gt; stu2)</span><br><span class="line"></span><br><span class="line">哈哈， &lt;__main__.Student object at 0x7f4aac6b3b00&gt; 会比 &lt;__main__.Student object at 0x7f4aac6b3ac8&gt; 大吗？</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li></ul><h2 id="类和对象的三种方法"><a href="#类和对象的三种方法" class="headerlink" title="类和对象的三种方法"></a>类和对象的三种方法</h2><ul><li><p>实例方法<br>需要实例化对象才能使用的方法，使用过程中可能需要截止对象的其他对象的方法完成</p></li><li><p>静态方法<br>不需要实例化，通过类直接访问</p></li><li><p>类方法<br>不需要实例化</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 三种方法的案例</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    # 实例方法</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(self)</span><br><span class="line">        print(&quot;Eating.....&quot;)</span><br><span class="line">    </span><br><span class="line">    #类方法</span><br><span class="line">    # 类方法的第一个参数，一般命名为cls，区别于self</span><br><span class="line">    @classmethod</span><br><span class="line">    def play(cls):</span><br><span class="line">        print(cls)</span><br><span class="line">        print(&quot;Playing.....&quot;)</span><br><span class="line">        </span><br><span class="line">    # 静态方法</span><br><span class="line">    # 不需要用第一个参数表示自身或者类</span><br><span class="line">    @staticmethod</span><br><span class="line">    def say():</span><br><span class="line">        print(&quot;Saying....&quot;)</span><br><span class="line">        </span><br><span class="line">yueyue = Person()</span><br><span class="line"></span><br><span class="line"># 实例方法</span><br><span class="line">yueyue.eat()</span><br><span class="line"># 类方法</span><br><span class="line">Person.play()</span><br><span class="line">yueyue.play()</span><br><span class="line">#静态方法</span><br><span class="line">Person.say()</span><br><span class="line">yueyue.say()</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>抽象方法：没有具体实现内容的方法成为抽象方法</li><li>抽象方法的主要意义是规范了子类的行为和接口</li><li><p>抽象类的使用需要借助abc模块</p><pre><code>import abc</code></pre></li><li><p>抽象类：包含抽象方法的类叫抽象类，通常成为ABC类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 抽象类的实现</span><br><span class="line"></span><br><span class="line">import abc</span><br><span class="line"></span><br><span class="line">#声明一个类并且指定当前类的元类</span><br><span class="line">class Human(metaclass=abc.ABCMeta):</span><br><span class="line"></span><br><span class="line">    # 定义一个抽象的方法</span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def smoking(self):</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    # 定义类抽象方法</span><br><span class="line">    @abc.abstractclassmethod</span><br><span class="line">    def drink():</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    # 定义静态抽象方法</span><br><span class="line">    @abc.abstractstaticmethod</span><br><span class="line">    def play():</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    # 定义一个具体方法</span><br><span class="line">    def sleep(self):</span><br><span class="line">        print(&quot;Sleeping.......&quot;)</span><br></pre></td></tr></table></figure></li><li><p>抽象类的使用<br>抽象类可以包含抽象方法，也可以包含具体方法<br>抽象类中可以有方法也可以有属性<br>抽象类不允许直接实例化<br>必须继承才可以使用，且继承的子类必须实现所有继承来的抽象方法<br>假定子类没有是现实所有继承的抽象方法，则子类也不能实例化<br>抽象类的主要作用是设定类的标准，以便于开发的时候具有统一的规范</p></li></ul><h2 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 函数名可以当变量使用</span><br><span class="line"></span><br><span class="line">def sayHello(name):</span><br><span class="line">    print(&quot;&#123;0&#125;你好 &quot;.format(name))</span><br><span class="line">    </span><br><span class="line">sayHello(&quot;月月&quot;)</span><br><span class="line"></span><br><span class="line">B = sayHello</span><br><span class="line">B(&quot;yueyue&quot;)</span><br></pre></td></tr></table></figure><ul><li>类其实是一个类定义和各种方法的自由组合</li><li><p>可以定义类和函数，然后自己通过类直接赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 组装类 1 </span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def say(self):</span><br><span class="line">    print(&quot;Saying... ...&quot;)</span><br><span class="line">    </span><br><span class="line">#等同于    </span><br><span class="line">class B():</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;Saying......&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(9)</span><br><span class="line">A.say = say</span><br><span class="line">a = A()</span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure></li><li><p>可以借助于MethodType实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 组装类例子 2</span><br><span class="line"></span><br><span class="line"># 自己组装一个类</span><br><span class="line">from types import MethodType</span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def say(self):</span><br><span class="line">    print(&quot;Saying... ...&quot;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">a = A()</span><br><span class="line"># 通过MethodType 把say组装到A  </span><br><span class="line">a.say = MethodType(say, A)</span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure></li><li><p>借助于type实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 利用type造一个类</span><br><span class="line"></span><br><span class="line"># 先定义类应该具有的成员函数</span><br><span class="line">def say(self):</span><br><span class="line">    print(&quot;Saying.....&quot;)</span><br><span class="line">    </span><br><span class="line">def talk(self):</span><br><span class="line">    print(&quot;Talking .....&quot;)</span><br><span class="line">    </span><br><span class="line">#用type来创建一个类</span><br><span class="line">A = type(&quot;AName&quot;, (object, ), &#123;&quot;class_say&quot;:say, &quot;class_talk&quot;:talk&#125;)</span><br><span class="line"></span><br><span class="line"># 然后可以像正常访问一样使用类</span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line">a.class_say()</span><br><span class="line">a.class_talk()</span><br></pre></td></tr></table></figure></li><li><p>利用元类实现- MetaClass<br>元类是类<br>被用来创造别的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 元类演示</span><br><span class="line"># 元类写法是固定的，必须继承自type</span><br><span class="line"># 元类一般命名以MetaClass结尾</span><br><span class="line"></span><br><span class="line">class TulingMetaClass(type):</span><br><span class="line">    # 注意以下写法</span><br><span class="line">    def __new__(cls, name, bases, attrs):</span><br><span class="line">        #自己的业务处理</span><br><span class="line">        print(&quot;哈哈，我是元类呀&quot;)</span><br><span class="line">        attrs[&apos;id&apos;] = &apos;000000&apos;</span><br><span class="line">        attrs[&apos;addr&apos;] = &quot;北京海淀区公主坟西翠路12号&quot;</span><br><span class="line">        return type.__new__(cls, name, bases, attrs)</span><br><span class="line">    </span><br><span class="line"># 元类定义完就可以使用，使用注意写法</span><br><span class="line">class Teacher(object, metaclass=TulingMetaClass):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">t = Teacher()</span><br><span class="line"></span><br><span class="line">t.id</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;OOP-Python面向对象&quot;&gt;&lt;a href=&quot;#OOP-Python面向对象&quot; class=&quot;headerlink&quot; title=&quot;OOP-Python面向对象&quot;&gt;&lt;/a&gt;OOP-Python面向对象&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;Python的面向对象&lt;ul&gt;

      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 的流程控制</title>
    <link href="http://yoursite.com/2019/04/27/Python/01.Basic-level/02.Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/27/Python/01.Basic-level/02.Python的流程控制/</id>
    <published>2019-04-27T10:11:07.000Z</published>
    <updated>2019-05-23T06:07:48.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ul><li>分支结构</li><li>循环结构</li><li>函数</li><li>函数的变量作用域</li></ul><h2 id="分支结构-选择结构"><a href="#分支结构-选择结构" class="headerlink" title="分支结构/选择结构"></a>分支结构/选择结构</h2><ul><li>单项分支: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if 条件表达式：   </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>双向分支      </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 条件表达式:</span><br><span class="line">    ...</span><br><span class="line">else:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p>多项分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if 条件表达式：</span><br><span class="line">    ...</span><br><span class="line">elif 条件表达式:</span><br><span class="line">    ... </span><br><span class="line">elif 条件表达式：</span><br><span class="line">    ...</span><br><span class="line">else:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p>巢状分支<br>巢状分支就是多个其他if…else分支的嵌套组合  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if x &lt; 5:</span><br><span class="line">    print(&apos;x真的小于5哦&apos;)</span><br><span class="line">    if y &lt; 6:</span><br><span class="line">        print(&apos;如果y &lt; 6，我会被输出&apos;)</span><br><span class="line">    elif y &gt; 6:</span><br><span class="line">        print(&apos;如果上y大于6，我会被输出&apos;)</span><br><span class="line">elif x &gt; 5:</span><br><span class="line">    print(&apos;x大于5&apos;)</span><br></pre></td></tr></table></figure></li></ul><p>注意：：在python中并没有switch…case分支。后期可以使用字典和函数的组合来代替。</p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><ul><li><p>while …: …  </p></li><li><p>while …: …     else: …   </p></li><li><p>while True: …</p></li></ul><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul><li>for … in 循环  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 格式1:  </span><br><span class="line">for 变量 in 序列:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"># 格式2:</span><br><span class="line">for 变量1,变量2.. in 多层序列：</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"># 格式3：</span><br><span class="line">for 变量 in 序列：:</span><br><span class="line">    ...</span><br><span class="line">else:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="其他流程控制语句"><a href="#其他流程控制语句" class="headerlink" title="其他流程控制语句"></a>其他流程控制语句</h3><ul><li><p>break 破坏，结束，打破<br>作用：结束程序循环，一旦程序执行了break语句，那么当前break所在的循环就会被终止  </p></li><li><p>continue 继续<br>作用：结束本次循环，开始下一次的循环，他不会终止整个循环，仅对于循环中的某次循环有效  </p></li><li><p>pass 通过，忽略<br>作用：在程序结构中有时不需用写任何python内容，但是如果没有内容，语言结构会出现语法错误！pass可以作为语法占位符使用，pass语句没有任何意义，也不会做任何操作</p></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h3><ul><li><p>最基本的函数结构  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def 函数名()：</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">调用函数： 函数名()</span><br></pre></td></tr></table></figure></li><li><p>具有参数的函数结构  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def 函数名(参数名，参数名...):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">调用函数: 函数名(值,值...)</span><br></pre></td></tr></table></figure></li></ul><p>声明函数的()中的参数称之为形参，形参表示形式上的参数<br>调用函数的()中的参数称之为实参，实参表示真实的值<br>注意:实参传递值给形参的过程，本质上就是普通的变量赋值  </p><ul><li>具有默认值参数的函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def 函数名(形参名 = 默认值,形参名 = 默认值...):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">调用函数1：函数名()</span><br><span class="line">调用函数2:函数名(实参,实参...)</span><br></pre></td></tr></table></figure></li></ul><h3 id="函数文档"><a href="#函数文档" class="headerlink" title="函数文档"></a>函数文档</h3><ul><li><p>查看函数文档：<br>使用help(函数名)，可以查看函数文档信息，查看信息时信息会换行<br>使用函数名.<strong>doc</strong>的方式查看，查看信息时信息不会换行，会显示\n  </p></li><li><p>自定义函数文档：<br>在函数内部开始的第一行使用字符串定义文字内容即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def 函数名()：</span><br><span class="line"></span><br><span class="line">    &apos;此处书写函数文档信息，单引号中使用\n换行&apos;</span><br><span class="line"></span><br><span class="line">    函数中的其他代码...</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">def 函数名():</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    此处书写函数文档信息</span><br><span class="line">    此处书写函数文档信息</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    函数中的其他代码...</span><br></pre></td></tr></table></figure></li></ul><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><ul><li><p>lambda不是一种函数结构，只是一种表达式而且不需要函数名。（匿名函数）<br>格式：</p><p>  变量 = lambda 形参,形参…： 功能代码</p></li><li><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#传入两个参数返回这两个数的乘积  </span><br><span class="line">lambda x,y :x*y </span><br><span class="line"></span><br><span class="line">#根据条件表达式的真假返回值1还是值2  </span><br><span class="line">lambda x： 值1  if 条件表达式 else 值2</span><br></pre></td></tr></table></figure></li><li><p>优点：<br>lambda表达式书写简单，不用def关键字，可惜要用lambda<br>lambda表达式不需要函数名，省得命名头疼<br>看起来比较装逼！  </p></li><li><p>缺点：<br>lambda表达式功能受限，无法使用循环以及部分流程控制相关语句<br>lambda表达式不适合较为复杂的程序。  </p></li></ul><h3 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h3><ul><li>收集参数1 (专用于收集非关键字参数)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 「*」 形参格式的收集参数会收集到调用函数时传入的所有没有关键字的形参  </span><br><span class="line">def 函数名(*形参名)：</span><br><span class="line">    ...    </span><br><span class="line"></span><br><span class="line">调用函数： 函数名(实参,实参....)</span><br></pre></td></tr></table></figure></li></ul><p>注意:<br>1) 收集参数收集到的最终数据是由所有非关键字实参组成的元组。<br>2) 收集参数和普通的参数（关键字参数）可以共存</p><ul><li>收集参数2 (专门用于收集关键字参数)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#「**」 形参格式会收集调用函数时传入函数的所有关键字参数  </span><br><span class="line">def 函数名(**args):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">调用函数：函数名(形参名 = 值,形参名=值...)</span><br></pre></td></tr></table></figure></li></ul><p>-注意:<br>1) 收集的所有关键字参数最终组成的数据为字典类型<br>2) 关键字参数收集的方式可以和普通形参共存，但是必须在最后  </p><ul><li>注意：<br>普通形参，非关键字收集形参和关键字收集形参具有顺序关系<br>普通形参放最前面<br>非关键字形参放中间<br>关键字形参放最后<br>所有收集参数只能够收集没有形参接受的实参 </li></ul><h2 id="函数的变量作用域"><a href="#函数的变量作用域" class="headerlink" title="函数的变量作用域"></a>函数的变量作用域</h2><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><ul><li>全局变量: 在函数外部声明的变量就是全局变量   </li><li>局部变量: 在函数内部声明的变量就是局部变量  </li></ul><h3 id="局部变量和全局变量的作用范围"><a href="#局部变量和全局变量的作用范围" class="headerlink" title="局部变量和全局变量的作用范围"></a>局部变量和全局变量的作用范围</h3><ul><li>全局变量在全局范围内可以使用  </li><li>全局变量在局部范围内可以使用(访问)  </li><li>局部变量在局部范围内可以使用  </li><li>局部变量在全局范围内无法正常使用  </li></ul><h3 id="global-关键字"><a href="#global-关键字" class="headerlink" title="global 关键字"></a>global 关键字</h3><ul><li>global 关键字的作用是提升局部变量为全局变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def 函数名():</span><br><span class="line">...</span><br><span class="line">    #提升局部变量为全局变量</span><br><span class="line">    global 局部变量</span><br></pre></td></tr></table></figure></li></ul><h3 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h3><ul><li><p>在函数内部声明的函数就是内部函数  </p></li><li><p>特征:<br>内部函数在函数内部可以访问<br>内部函数的调用必须在定义内部函数之后<br>内部函数不可以在函数外部调用<br>本质上内部函数等同于内部变量  </p></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li><p>闭包<br>将函数内部的局部变量或者内部函数,弄到函数外,并且可以正常使用的特殊方法.突破了局部作用域的限制!<br>注意:闭包少用!</p></li><li><p>闭包格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def 外层函数()：</span><br><span class="line">局部变量</span><br><span class="line">局部变量</span><br><span class="line"></span><br><span class="line">   def 内部函数()：</span><br><span class="line">pass</span><br><span class="line">return (局部变量，局部变量...内部函数,内部函数...)</span><br></pre></td></tr></table></figure></li></ul><h3 id="nonlocal关键字"><a href="#nonlocal关键字" class="headerlink" title="nonlocal关键字"></a>nonlocal关键字</h3><ul><li>声明当前变量不是当前函数内部的变量，他有可能是当前函数的外部变量（不是全局变量）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def 外部函数()</span><br><span class="line"></span><br><span class="line">    局部变量</span><br><span class="line"></span><br><span class="line">    def 内部函数（）:</span><br><span class="line"></span><br><span class="line">        nonlocal 变量名#声明当前变量不是内部函数中的变量</span><br><span class="line"></span><br><span class="line">        其他代码...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 代码</span><br></pre></td></tr></table></figure></li></ul><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><ul><li>在函数中调用当前函数本身的函数就是递归函数。<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def recursion(n):</span><br><span class="line">    #输出当前的n的值</span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line">    #判断n的值是否&gt;0,决定下一步操作</span><br><span class="line">    if n&gt;0:        #n&gt;0 在此调用当前函数digui，将n - 1放进去</span><br><span class="line">        recursion(n-1)</span><br><span class="line">    else:</span><br><span class="line">        #n&gt;0 为False 输出分隔线</span><br><span class="line">        print(&apos;------&apos;)</span><br><span class="line"></span><br><span class="line">    #再次输出n的值</span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line">recursion(3)</span><br><span class="line"></span><br><span class="line">执行结果:</span><br><span class="line">3 2 1 0 ----- 0 1 2 3</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;流程控制&quot;&gt;&lt;a href=&quot;#流程控制&quot; class=&quot;headerlink&quot; title=&quot;流程控制&quot;&gt;&lt;/a&gt;流程控制&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;分支结构&lt;/li&gt;
&lt;li&gt;循环结构&lt;/li&gt;
&lt;li&gt;函数&lt;/li&gt;
&lt;li&gt;函数的变量作用域&lt;/li&gt;
&lt;/
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 的语法基础</title>
    <link href="http://yoursite.com/2019/04/25/Python/01.Basic-level/01.Python%E7%9A%84%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/04/25/Python/01.Basic-level/01.Python的语法基础/</id>
    <published>2019-04-25T10:11:07.000Z</published>
    <updated>2019-05-23T06:07:10.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python的语法基础"><a href="#Python的语法基础" class="headerlink" title="Python的语法基础"></a>Python的语法基础</h1><ul><li>基础语法</li></ul><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul><li><p>编码<br>默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 </p></li><li><p>查看数据类型<br>用法：type(变量名)</p></li><li><p>获取变量在内存中的id标识<br>用法：id(变量名)  </p></li></ul><ul><li><p>系统中保留关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import keyword     </span><br><span class="line">print (keyword.kwlist)</span><br></pre></td></tr></table></figure></li><li><p>多行语句<br>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line">        </span><br><span class="line"># 在 [], &#123;&#125;, 或 () 中的多行语句，不需要使用反斜杠(\)</span><br><span class="line">total = [&apos;item_one&apos;, &apos;item_two&apos;, &apos;item_three&apos;,</span><br><span class="line">        &apos;item_four&apos;, &apos;item_five&apos;]</span><br></pre></td></tr></table></figure></li><li><p>等待用户输入：input()</p></li><li>同一行显示多条语句  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Python可以在同一行中使用多条语句，语句之间使用分号(;)分割</span><br><span class="line"> </span><br><span class="line">import sys; x = &apos;runoob&apos;; sys.stdout.write(x + &apos;\n&apos;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="Python的数据类型"><a href="#Python的数据类型" class="headerlink" title="Python的数据类型"></a>Python的数据类型</h1><p>Python中可以自定义数据类型,可以具有无限种数据类型<br>系统默认提供6个标准数据类型：</p><ul><li>Number类型(数字) </li><li>String类型（字符串） </li><li>List类型 (列表) </li><li>tuple类型(元组) </li><li>Dictionary类型(字典) </li><li>Set类型（集合）</li></ul><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>Number类型主要包含数学相关的数据：一共分为4种小类型：  </p><ul><li><p>整型<br>整型就是整数。包括正整数负整数和0<br>二进制（0b开头）<br>变量 = 0b10101<br>八进制（0o开头）<br>变量 = 0o777<br>十进制（不需要）<br>变量  = 250<br>十六进制（0x开头）<br>变量 = 0xabcd  </p></li><li><p>浮点型<br>浮点型就是小数。<br>使用小数表示浮点数 float1 = 3.141592653<br>科学计数法表示浮点数<br>float2 = 314e-2 # 314*10的-2次方  </p></li><li><p>复数<br>什么是复数。 复数由实数和虚数两部分组成<br>表达式: 163 + 2j<br>使用复数功能结构: com2 = complex(15,3)  </p></li><li><p>布尔类类型<br>布尔值就是表示确定或者否定的数据类型，只有2个值：True和False 在python当中没有真正的布尔类型，而是使用数字0来表示False，数字1表示True，所以bool是Number类型</p></li></ul><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>字符串就是文字类型 </p><h3 id="字符串的声明："><a href="#字符串的声明：" class="headerlink" title="字符串的声明："></a>字符串的声明：</h3><ul><li><p>单引号声明字符串<br>  变量 = ‘值’</p></li><li><p>双引号声明字符串<br>  变量 = “值”  </p></li><li><p>三引号声明变量<br>  变量 = ‘’’值’’’<br>  变量 = “””值”””<br>  三引号声明字符串的方式适合大数据的字符串、多行数据  </p></li></ul><h3 id="字符串相关操作"><a href="#字符串相关操作" class="headerlink" title="字符串相关操作"></a>字符串相关操作</h3><ul><li><p>常用<br>字符串连接符号: +<br>字符复制操作: *<br>[] 通过指定位置（索引）来获取指定位置的字符<br>[:] 取片操作（不包含结束位置）<br>注意事项：<br>单引号中不可以直接使用单引号<br>双引号中不可以直接使用双引号<br>三引号中可以随意使用单双引号   </p></li><li><p>字符串的转义操作：<br>(在行尾时) 续行符<br>\  反斜杠符号<br>\’  单引号<br>\”  双引号<br>\a  响铃<br>\b  退格(Backspace)<br>\e  转义<br>\000    空<br>\n  换行<br>\v  纵向制表符<br>\t  横向制表符<br>\r  回车<br>\f  换页<br>\oyy    八进制数，yy代表的字符，例如：\o12代表换行<br>\xyy    十六进制数，yy代表的字符，例如：\x0a代表换行<br>\other  其它的字符以普通格式输出 </p></li><li><p>r 防止转义:<br>print(r’hello\nrunoob’)    </p></li></ul><h3 id="str-的内置函数"><a href="#str-的内置函数" class="headerlink" title="str 的内置函数"></a>str 的内置函数</h3><ul><li><p>capitalize()  首字母大写<br>格式： str.capitalize()<br>返回值：首字母大写的字符串，仅把整个字符串的第一个字符大写  </p></li><li><p>upper()  将所有英文字符变为大写<br>格式：str.upper()<br>返回值：返回所有英文字符大写的字符串 </p></li><li><p>lower()   将所有英文字符变为小写<br>格式：str.lower()<br>返回值：返回所有英文字符小写的字符串  </p></li><li><p>swapcase()  大小写互相转换<br>格式：str.swapcase()<br>返回值：转换之后的字符串  </p></li><li><p>title()  按照标题格式进行大小写转换（每个单词首字母大写)<br>格式：str.title()<br>返回值：返回所有英文单词首字母大写的字符串  </p></li><li><p>len()  计算字符串的字符个数,以后也可以用于计算元组列表等序列<br>格式: len(str)<br>返回值:整型  </p></li><li><p>count()  计算一个字符串中出现指定字符串的次数<br>格式：str.count(‘查找的字符串’[,开始位置])<br>返回值:返回整型</p></li><li><p>find()  查找字符串中是否具有指定的字符串,查找不到返回-1<br>格式：str.find(查找的字符串[，开始位置])<br>返回值:第一次出现的位置</p></li><li><p>index()  查找字符串中是否具有指定的字符串，查找不到直接报错<br>格式：str.index(查找的字符串[，开始位置])<br>返回值:第一次出现的位置  </p></li><li><p>startswith()  检测字符串是否以指定的字符串开头<br>格式： str.startswith(‘查找的字符串’[，开始位置])<br>返回值：布尔值 </p></li><li><p>endswith()  检测字符串是否以指定的字符串结尾<br>格式： str.endswith(‘查找的字符串’[，开始位置])<br>返回值：布尔值  </p></li><li><p>isupper()  检测字符串中字母是否都是大写字母<br>格式：str.isupper()<br>返回值：布尔值  </p></li><li><p>islower()  检测字符串中的字母是否都是小写字母<br>格式：str.islower()<br>返回值：布尔值  </p></li><li><p>isalnum()  检测一个字符串是否都是有数字或者是否都是有字母组成<br>格式：str.isalnum()<br>返回值:布尔值<br>注意：空字符串返回False  </p></li><li><p>isalpha()  检测字符串是否都是有字母类型构成，汉字作为字母处理<br>格式：str.isalpha()<br>返回值：布尔值<br>注意：空字符串返回False</p></li><li><p>isdigit()  检测字符串是否由纯数字字符组成<br>格式：str.isdigit()<br>返回值：布尔值<br>注意：空字符串返回False  </p></li><li><p>isspace()  检测字符串是否完全由空白字符组成<br>格式：str.isspace()<br>返回值：布尔值<br>注意：回车，换行，缩进，空格都可以当作空白字符，空字符串是False</p></li><li><p>istitle()  检测字符串是否符合title()的结果，每个单词首字母大写<br>格式：str.istitle()<br>返回值：布尔值  </p></li><li><p>isnumeric()  检测字符串是否有纯数字构成<br>格式：str.isnumeric()<br>返回值：布尔值  </p></li><li><p>isdecimal()  检测字符串是否完全由十进制字符组成<br>格式：str.isdecimal()<br>返回值：布尔值  </p></li><li><p>split()  使用指定的字符将字符串卷拆解成多个字符串<br>格式： str.split(‘用于拆解的字符串’)<br>返回值：列表类型  </p></li><li><p>splitlines()  使用\n，\r或者\r\n切割字符串<br>格式：str.splitlines()<br>返回值：列表类型  </p></li><li><p>join()  使用指定的字符串将序列中的内容组成新的字符串<br>格式：连接字符串.join(序列)<br>返回值：组成的新的字符串  </p></li><li><p>zfill()  0填充操作<br>格式： str.zfill(长度)<br>返回值：填充0的字符串<br>注意：填充结果原有内容靠右对齐，前面位数不足使用0来补充，常用于数字类型字符串。  </p></li><li><p>center() 将字符串进行居中操作，并且在空白处进行填充<br>格式： str.center(未来字符宽度,空白填充字符)<br>返回值：新的字符串  </p></li><li><p>ljust（） 将字符串进行左对齐操作，并且在空白处进行填充<br>格式： str.ljust(未来字符宽度,空白填充字符)<br>返回值：新的字符串  </p></li><li><p>rjust() 将字符串进行右对齐操作，并且在空白处进行填充<br>格式： str.rjust(未来字符宽度,空白填充字符)<br>返回值：新的字符串   </p></li><li><p>lstrip() 去掉字符串左侧的空白<br>格式： str.lstrip()<br>返回值：字符串  </p></li><li><p>rstrip()去掉字符串右侧的空白<br>格式： str.rstrip()<br>返回值：字符串  </p></li><li><p>strip()去掉字符串两侧的空白<br>格式： str.strip()<br>返回值：字符串  </p></li><li><p>replace() 字符串替换操作<br>格式： str.replace(被替换的字符串,替换字符串)<br>返回值：替换之后的字符串、  </p></li><li><p>maketrans() 制作一个字符串映射表，为了给translate函数使用<br>格式:str.maketrans（’被替换的字符串’,’替换字符串’）<br>返回值：字典类型，被替换字符串组成键，替换字符串组成值<br>注意： 两个参数的字符串个数必须一一对应，这里的str不是值字符串，而是真正的str，也可以写空字符串代替str（字符串都是str制作的）  </p></li><li><p>translate() 进行字符串翻译操作，类似转换<br>格式：str.translate(映射表)<br>返回值:新的字符串<br>注意:translate用于多字符替换，replace用于长字符串替换  </p></li></ul><h3 id="string模块相关内容"><a href="#string模块相关内容" class="headerlink" title="string模块相关内容"></a>string模块相关内容</h3><ul><li><p>获取所有的空白字符:<br>print (string.whitespace)  </p></li><li><p>获取ascii码的所有字母表（包含大写和小写）:<br>print(string.ascii_letters)  </p></li><li><p>获取ascii码中的所有大写字母:<br>print(string.ascii_uppercase)  </p></li><li><p>获取ascii码中所有的小写字母:<br>print(string.ascii_lowercase)  </p></li><li><p>获取ascii码中所有10进制数字字符:<br>print(string.digits)  </p></li><li><p>获取八进制所有数字字符:<br>print(string.octdigits)  </p></li><li><p>获取十六进制的所有数字字符<br>print(string.hexdigits)  </p></li><li><p>打印所有可见字符<br>print(string.printable)  </p></li><li><p>打印所有标点符号<br>print(string.punctuation)  </p></li></ul><h2 id="List类型-列表"><a href="#List类型-列表" class="headerlink" title="List类型 (列表)"></a>List类型 (列表)</h2><h3 id="列表的定义和访问："><a href="#列表的定义和访问：" class="headerlink" title="列表的定义和访问："></a>列表的定义和访问：</h3><ul><li><p>列表的定义<br>变量 = [值,值,值….]<br>列表的标志符号是[]   </p></li><li><p>列表的访问操作<br>列表变量：[索引位置]<br>添加列表操作：不可以使用索引方式添加<br>修改列表操作：列表变量[索引位置] = 新值<br>删除列表操作：del 列表变量[索引位置] </p></li></ul><h3 id="列表的序列操作"><a href="#列表的序列操作" class="headerlink" title="列表的序列操作"></a>列表的序列操作</h3><ul><li><p>索引操作<br>格式： 列表变量[索引]  </p></li><li><p>分片操作<br>列表[:]<br>表示获取列表的所有数据<br>列表[开始索引：]<br>表示丛开始索引位置截取到列表的最后<br>列表[:结束索引]<br>表示从列表的开头截取到结束索引位置之前，不包含结束位置<br>列表[开始索引:结束索引]<br>表示从列表的开始索引位置截取到结束索引位置之前，不包含结束位置<br>列表[开始索引:结束索引:跳步值]<br>表示从开始索引位置到结束索引位置之间，不包含索引位置，并且获取数据时索引每次+跳步值来获取，默认跳步值为1  </p></li><li><p>序列相加<br>格式：列表 = 列表1 + 列表2</p></li><li><p>列表相乘<br>格式： 列表 = 列表1 * 整数<br>结果：将列表重复N分组成新的列表<br>注意： 数字必须为整数    </p></li><li><p>成员资格运算<br>格式1：数据  in 列表<br>作用：检测数据是否在列表当中<br>返回值：布尔值<br>格式2：数据  not in 列表<br>作用：检测数据是不是不在列表当中<br>返回值：布尔值</p></li><li><p>最大、最小、长度计算</p></li></ul><h3 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h3><ul><li><p>for i in 列表: </p></li><li><p>while i &lt; length:</p></li><li><p>双层列表循环<br>列表 = [[值1,值2],[值1,值2]，[值1,值2]…]<br>for i,j in 列表:</p></li></ul><h3 id="列表内涵：-list-content"><a href="#列表内涵：-list-content" class="headerlink" title="列表内涵： list content"></a>列表内涵： list content</h3><ul><li><p>简单的列表内涵：<br>格式：[[变量 for [变量 in 列表]<br>作用：遍历列表中的数据并且组成新的列表，如果需要改变原有数据，在最开始i处修改<br>结果：新的列表  </p></li><li><p>带有判断的列表内涵<br>格式 [变量 for 变量 in 列表 判断条件]<br>作用：遍历列表中的数据，根据判断条件取出符合条件的数据组成新的列表<br>结果:新的列表  </p></li><li><p>多循环带判断的列表内涵<br>格式：[[变量1+变量2 for 变量1 in 列表1 for 变量2 in 列表2 判断条件]<br>作用：将列表1中和列表2中每个数据进行操作，但是必须在符合判断条件的前提下进行。<br>结果：新的列表  </p></li></ul><h3 id="序列函数"><a href="#序列函数" class="headerlink" title="序列函数"></a>序列函数</h3><ul><li><p>len() 获取列表的数据长度<br>格式：len(列表)<br>返回值：整型  </p></li><li><p>max() 获取列表中的最大值<br>格式：max(列表)<br>返回值：列表中的最大值  </p></li><li><p>min() 获取列表的最小值<br>格式：min(列表)<br>返回值：列表中的最小值  </p></li><li><p>list() 将其他序列类型转化为列表<br>格式：list(序列)<br>返回值：列表  </p></li></ul><h3 id="列表专用函数"><a href="#列表专用函数" class="headerlink" title="列表专用函数"></a>列表专用函数</h3><ul><li><p>append() 在列表的最后追加新数据<br>格式： 列表.append(数据)<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>insert() 在列表指定的位置插入数据<br>格式：列表.insert（索引,数据）<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>pop() 在列表中移除一个元素<br>格式：列表.pop()<br>返回值:移除掉的元素<br>注意：移除列表最后的元素  </p></li><li><p>格式：列表.pop(索引)<br>返回值：:移除掉的元素<br>注意：移除列表中指定索引的元素  </p></li><li><p>remove() 在列表中移除指定的值的元素<br>格式:列表.remove(值)<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>clear() 清空列表<br>格式：列表.clear()<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>reverse() 列表反转<br>格式：列表.reverse（）<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>extend() 在原有列表最后追加新的序列<br>格式:列表.extend(序列类型)<br>返回值：    无<br>注意：该操作直接改变原有列表  </p></li><li><p>count() 计算指定值在列表中出现的次数<br>格式: 列表.count(值)<br>返回值：整数  </p></li><li><p>copy() 复制原有列表<br>格式: 列表.copy()<br>返回值：新的列表 </p></li></ul><h2 id="tuple类型-元组"><a href="#tuple类型-元组" class="headerlink" title="tuple类型(元组)"></a>tuple类型(元组)</h2><h3 id="元组的创建和特征"><a href="#元组的创建和特征" class="headerlink" title="元组的创建和特征"></a>元组的创建和特征</h3><ul><li><p>元组的创建<br>创建空元组:变量 = ()<br>创建单个数据的元组: 变量 = (值,)   或  变量 = 值,<br>创建多个数据的元组: 变量 = (值,值，值…)  或者  变量 = 值,值，值…  </p></li><li><p>元组的特征<br>元组的关键符号是逗号而不是小括号。<br>元组不具备修改功能。<br>是一种特殊的列表。</p></li></ul><h3 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h3><ul><li><p>索引操作<br>元组[索引位置]  </p></li><li><p>分片操作<br>元组[:]<br>获取元素的所有数据<br>元组[开始索引:]<br>获取开始索引位置到最后的所有数据<br>元组[:结束索引]<br>获取元组开头到结束索引位置之前的所有数据（不包含结束位置）<br>元组[开始索引:结束索引]<br>获取元素开始索引位置到结束索引位置之间的所有数据（不包含结束位置）<br>元组[开始索引:结束索引:跳步值]<br>获取元素开始位置到结束索引之间的指定间隔的数据数据（不包含结束位置）  </p></li><li><p>相加操作<br>新元组 = 元组 + 元组  </p></li><li><p>相乘操作<br>新元组 = 元组 * 整数</p></li><li><p>成员检测<br>格式1:数据 in 元组<br>作用：检测数据是不是在元组当中<br>返回值：布尔值<br>格式2:数据 not in 元组<br>检测数据是否不在元组当中<br>返回值：布尔值</p></li></ul><h3 id="元组的遍历"><a href="#元组的遍历" class="headerlink" title="- 元组的遍历"></a>- 元组的遍历</h3><ul><li><p>for i in 元组：</p></li><li><p>双层元组循环<br>元组 = ((值1,值2),(值1,值2)，(值1,值2)…)<br>for i,j in 元组：</p></li></ul><h3 id="元组的函数"><a href="#元组的函数" class="headerlink" title="元组的函数"></a>元组的函数</h3><ul><li><p>len() 获取元组中数据的长度<br>格式： len(元组)<br>返回值：整数  </p></li><li><p>max() 返回元组中最大的值<br>格式：max(元组)  </p></li><li><p>min() 返回元组中的最小值<br>格式：min(元组)  </p></li><li><p>tuple() 将其他序列转化为元组类型<br>格式： tuple(任意序列)  </p></li></ul><h3 id="元组的方法"><a href="#元组的方法" class="headerlink" title="元组的方法"></a>元组的方法</h3><ul><li><p>count() 计算指定数据出现的次数<br>格式:元组.count(查找的数据)<br>返回值：整数  </p></li><li><p>index() 获取指定值在元组中的索引位置<br>格式：元组.index(查找的数据)<br>返回值：索引位置或者错误信息  </p></li><li><p>变量交换 （元组特殊用法）<br>a,b = b,a </p></li></ul><h2 id="Dictionary类型-字典"><a href="#Dictionary类型-字典" class="headerlink" title="Dictionary类型(字典)"></a>Dictionary类型(字典)</h2><ul><li><p>字典格式：<br>变量 = {键:值,键:值….}  </p></li><li><p>键就是标志或者说是目录,值就是真实的值  </p></li><li><p>字典的标志符号是{}   </p></li></ul><h3 id="字典的创建和特征"><a href="#字典的创建和特征" class="headerlink" title="字典的创建和特征"></a>字典的创建和特征</h3><ul><li><p>创建空字典<br>变量 = {} 或者 变量 = dict()</p></li><li><p>创建有数据的字典<br>变量 = {键:值,键:值,键:值…}<br>变量 = dict({键:值,键:值,键:值…})<br>变量 = dict(键=值,键=值,键=值…)<br>变量 = dict([(键,值),(键,值),（键,值）…])<br>变量 = dict(zip((键，键，键….),(值,值，值…)))</p></li><li><p>字典的特征<br>字典也是序列类型但是是无序序列，所以分片操作无法使用<br>字典中每个数据都由键和值两部分组成：<br>值：任意数据都可以当作值来使用<br>键：可以使用 int，float,str,tuple，冰冻集合，但是list，set，dict等不可以使用</p></li></ul><h3 id="字典的基本操作"><a href="#字典的基本操作" class="headerlink" title="字典的基本操作"></a>字典的基本操作</h3><ul><li><p>访问数据：<br>字典变量[键]</p></li><li><p>添加数据<br>字典变量[新键] = 值</p></li><li><p>修改数据<br>字典变量[键] = 新值</p></li><li><p>删除数据<br>del 字典变量[键]</p></li></ul><h3 id="序列操作-1"><a href="#序列操作-1" class="headerlink" title="序列操作"></a>序列操作</h3><ul><li><p>检测数据是否在字典的键中<br>格式：数据 in 字典</p></li><li><p>检测数据是否不再字典的键中<br>格式：数据 not in 字典</p></li></ul><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><ul><li><p>键遍历操作: for k in 字典:</p></li><li><p>键值遍历: for k,v in 字典.items()：</p></li></ul><h3 id="字典内涵"><a href="#字典内涵" class="headerlink" title="字典内涵"></a>字典内涵</h3><ul><li><p>基本的字典内涵<br>变量= {key:value for key,value in 字典.items()}  </p></li><li><p>带有条件的字典内涵<br>变量 = {key:value for key,value in 字典.items() if 条件}  </p></li></ul><h3 id="字典函数"><a href="#字典函数" class="headerlink" title="字典函数"></a>字典函数</h3><ul><li><p>len() 计算字典的长度<br>格式： len(字典)<br>返回值:字典的长度</p></li><li><p>max() 获取字典中的最大值 （默认比较字典的键）<br>格式:max(字典)<br>返回值：最大的键</p></li><li><p>min() 获取字典中的最小值（默认比较字典的键）<br>格式：min(字典)<br>返回值:最小值</p></li><li><p>dict() 将其他序列转化为字典<br>详情请看字典的定义</p></li><li><p>str(字典) 返回字典的字符串格式</p></li></ul><h3 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h3><ul><li><p>clear() 清空字典<br>格式：字典.clear()<br>返回值：无  None<br>注意：直接改变原有字典  </p></li><li><p>items() 获取字典的键值对组成的元组格式<br>格式：字典.items()<br>返回值：将键值对变成元组的列表形式。<br>注意:返回的数据是内建的dict_items类型，专用于字典的转换中间类型  </p></li><li><p>keys() 获取字典中所有键组成的序列，常用语字典遍历<br>格式： 字典.keys()<br>返回值:返回所有键的组合<br>注意：类型为 dict_keysL类型，也是一种字典转换的中间类型  </p></li><li><p>values() 获取字典中所有值组成的序列，常用语字典遍历<br>格式： 字典.values()<br>返回值：所有值的组合<br>注意：类型为dict_values类型，也是一种字典转换的中间类型  </p></li><li><p>get（） 根据指定的键获取值<br>格式：字典.get(键,默认值)<br>返回值：字典键对应的数据<br>注意：如果键不存在与字典中，则返回默认值而不会报错  </p></li><li><p>pop() 根据键从字典中删除数据<br>格式:字典.pop(键)<br>返回值：删除的键对应的值<br>注意：pop在字典中使用必须有参数，因为字典无序序列，直接改变原有字典  </p></li><li><p>copy() 赋值一个字典<br>格式：字典.copy()<br>返回值：复制出来的新的字典  </p></li><li><p>setdefault() 设置字典中不存在的键的值<br>格式：字典.setdefault(键,默认值)<br>返回值：设置时的默认值<br>注意：如果设置时键已经存在于字典中，则不进行任何操作，直接改变原有字典  </p></li><li><p>fromkeys() 使用指定的序列作为键,使用一个值作为字典的所有值<br>格式:字典.fromkeys(序列,值)<br>返回值：由序列作为字典的键，由值作为所有键对应的值组成的字典  </p></li><li><p>update() 使用字典更新另外一个字典<br>格式：字典1.update(字典2)<br>返回值：无<br>注意:直接改变原有字典  </p></li></ul><h2 id="Set类型（集合）"><a href="#Set类型（集合）" class="headerlink" title="Set类型（集合）"></a>Set类型（集合）</h2><h3 id="集合的创建和特征"><a href="#集合的创建和特征" class="headerlink" title="集合的创建和特征"></a>集合的创建和特征</h3><ul><li><p>创建空集合<br>变量 = set()  </p></li><li><p>创建多个数据的集合<br>变量 = {值,值,值….}  </p></li><li><p>集合的特征<br>集合是一种无序的数据类型，无法通过索引和分片进行操作<br>集合是内部元素绝对唯一的数据，常常用于去掉重复数据<br>集合的数据，str，int，float,bool,tuple，冰冻集合。  </p></li></ul><h3 id="集合序列操作"><a href="#集合序列操作" class="headerlink" title="集合序列操作"></a>集合序列操作</h3><ul><li><p>检测数据是否在集合当中<br>格式：数据 in 集合</p></li><li><p>检测数据是否不在集合当中<br>格式：数据 not in 集合</p></li></ul><h3 id="集合遍历操作"><a href="#集合遍历操作" class="headerlink" title="集合遍历操作"></a>集合遍历操作</h3><ul><li><p>for i in 集合:</p></li><li><p>带有元组的集合遍历<br>集合 = {(值1,值2..),(值3,值4..)…}<br>for i,j in 集合:</p></li></ul><h3 id="集合内涵"><a href="#集合内涵" class="headerlink" title="集合内涵"></a>集合内涵</h3><ul><li><p>普通集合内涵<br>新集合 = {变量 for 变量 in 集合}  </p></li><li><p>带条件的集合内涵<br>新集合 = {变量 for 变量 in 集合 if 条件}  </p></li><li><p>多循环的集合内涵<br>新集合 = {变量1+变量2 for 变量1 in 集合1 for 变量2 in 集合2 if 条件}    </p></li></ul><h3 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h3><ul><li><p>len() 获取集合中元素的个数<br>格式:len(集合)<br>返回值：整数</p></li><li><p>max() 获取集合中最大的元素<br>格式:max(集合)<br>返回值：集合中最大的值</p></li><li><p>min() 获取集合中最小的元组<br>格式：min(集合)<br>返回值：集合中的最小值</p></li><li><p>set() 将其他序列转化为集合类型<br>格式：set(序列)<br>返回值：集合类型</p></li></ul><h3 id="集合方法"><a href="#集合方法" class="headerlink" title="集合方法"></a>集合方法</h3><ul><li><p>add() 向集合中添加数据<br>格式： 集合.add(数据)<br>返回值：无<br>注意：直接改变原有集合，已存在的数据无法添加</p></li><li><p>clear() 清空集合<br>格式：集合.clear()<br>返回值：无<br>注意：直接改变原有集合</p></li><li><p>copy() 集合复制<br>格式:集合.copy()<br>返回值:原集合所有数据组成的新的集合</p></li><li><p>remove() 移除指定的值<br>格式:集合.remove(值)<br>返回值：无<br>注意：直接改变原有集合，如果要删除的值不存在，就报错</p></li><li><p>discard()移除集合中指定的值<br>格式:集合.discard(值)<br>返回值：无<br>注意：直接改变原有集合，如果要删除的值不存在，就不作任何操作</p></li><li><p>pop() 随机移除一个元素<br>格式：集合.pop（）<br>返回值：被移除的元素<br>注意：随机移除元素，没啥规律</p></li><li><p>intersection() 计算两个值集合之间的交集<br>格式： 集合1.intersection(集合2)<br>返回值：新的集合</p></li><li><p>difference() 计算两个集合之间的差集<br>格式： 集合1.difference(集合2)<br>返回值:新的集合</p></li><li><p>union() 计算两个集合之间的并集操作<br>格式：集合1.union（集合2）<br>返回值：新的集合</p></li><li><p>issubset() 检测一个集合是否是另外一个集合的子集<br>格式：集合1.issubset(集合2)<br>返回值：布尔值</p></li><li><p>issuperset() 检测一个集合是否是另外一个和集合的超集<br>格式：集合1.issuperset(集合2)<br>返回值：布尔值</p></li><li><p>difference_update（） 计算集合1和集合2的差集并且将结果赋值给集合1<br>格式：集合1.difference_update(集合2)<br>返回值:无<br>注意：操作结果直接赋值给集合1</p></li><li><p>intersection_update() 计算集合1和集合2的交集并且将结果赋值给集合1<br>格式：集合1.intersection_update(集合2)<br>返回值：无<br>注意:操作结果直接赋值给集合1</p></li><li><p>update() 计算集合1和集合2的并集并且将并集结果赋值给集合1<br>格式：集合1.update(集合2)<br>返回值:无<br>注意:操作结果直接赋值给集合1</p></li></ul><h3 id="冰冻集合-固定集合-frozen"><a href="#冰冻集合-固定集合-frozen" class="headerlink" title="冰冻集合/固定集合 frozen"></a>冰冻集合/固定集合 frozen</h3><ul><li><p>冰冻集合就是不可以进行任何修改相关操作的集合</p></li><li><p>创建冰冻集合<br>创建空的冰冻集合: 变量 = frozenset()<br>创建具有数据的冰冻集合: 变量 = fronzenset(一个序列)  </p></li><li><p>操作方法和函数<br>冰冻集合的操作相关函数和方法同集合类型一样。<br>只是不可以使用修改集合相关的方法和函数。  </p></li><li><p>注意:<br>frozenset 和普通的集合一样没有什么本质区别，能够使用的函数数量不一样，仅此而已哦</p></li></ul><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>类型转换会向着更加精确的类型进行转换  </p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>强制类型转换是根据程序需要，由程序员通过操作强制改变数据的类型。  </p><ul><li><p>int（) 强制将数据转化为整型<br>纯数字字符串转化为整型时，类型改变，值不变<br>只有纯整数字符串才可以转换，其他均不可以<br>浮点型可以转化为整型，去掉小数点后面的部分 </p></li><li><p>float() 强制将数据转化为浮点型<br>整数字符串和浮点数字符串均可以转化为浮点型<br>转化过程中类型改变，值不变<br>整型也可以用于浮点型转换     </p></li><li><p>complex（） 生成一个复数  </p></li><li><p>bool() 强制将数据转化为布尔值<br>能够转化为布尔值False的情况：<br>① 字符串 空字符串 ② 整型 0  ③浮点型 0.0 ④ 复数 0+0j ⑤ 布尔值 Flase ⑥ 列表 [] 空列表 ⑦ 元组 () 空元组 ⑧ 字典 {} 空字典 ⑨ 集合 set（）空集合  </p></li><li><p>str() 字符串类型转换<br>所有数据类型都可以转换为字符串，转换规则就是在原有数据基础上加了引号变成了字符串的格式。例如：[1，2，3] =<br>“[1，2，3]”  </p></li><li><p>list() 将其他数据转换为列表类型<br>能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据）</p></li><li><p>tuple() 将其他数据类型转换为元组类型<br>能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据）  </p></li><li><p>dict() 将其他数据转化为字典类型<br>字典类型转换可以转化的类型有三种：list 、tuple 、set<br>以上所有类型的每个数据必须由元组组成，并且每个元组必须有2个值<br>例子：<br>{(‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’)}<br>[(‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’)]<br>((‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’))    </p></li><li><p>set() 集合类型转换<br>能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据） </p></li></ul><h1 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h1><h2 id="利用百分号格式化"><a href="#利用百分号格式化" class="headerlink" title="利用百分号格式化"></a>利用百分号格式化</h2><ul><li>%d 此处应该放入一个整数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;i am %d years old&quot;</span><br><span class="line">print (s%18)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>%s 放入一个字符串 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;i am %s&quot;</span><br><span class="line">print (&quot;i love %s&quot;%&quot;KI&quot;)</span><br><span class="line">print (s%&quot;KIOVEN&quot;)</span><br></pre></td></tr></table></figure></li><li><p>如果出现多个占位符，则相应内容需要用括号括起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;i am %s,i am %d years old&quot;</span><br><span class="line">print (s%(&quot;ouwen&quot;,18))</span><br></pre></td></tr></table></figure></li></ul><h2 id="利用format格式化"><a href="#利用format格式化" class="headerlink" title="利用format格式化"></a>利用format格式化</h2><ul><li>以{}和： 代替%号，后面用format带参数完成<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;i love &#123;&#125;&apos;.format(&quot;you&quot;)</span><br><span class="line">print (s)</span><br><span class="line"></span><br><span class="line">s = &quot;i am &#123;1&#125; years old,i love &#123;0&#125; and &#123;1&#125; years old&quot;.format(&quot;tulingxueyuan&quot;,24)</span><br><span class="line">print (s)</span><br></pre></td></tr></table></figure></li></ul><h1 id="表达式和运算符"><a href="#表达式和运算符" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h1><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>由变量、运算符、数字、数字分组符号（括号）等以能求得数值的有意义排列方法所得的组合。</p><h2 id="运算符的分类"><a href="#运算符的分类" class="headerlink" title="运算符的分类"></a>运算符的分类</h2><ul><li>算术运算  </li><li>比较运算/关系运算  </li><li>赋值运算  </li><li>逻辑运算  </li><li>位运算  </li><li>成员运算  </li><li>身份运算  </li></ul><h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><pre><code>+  -  *  /  %(取余)  //(地板除，取商)  **幂运算 </code></pre><p>注意：<br>    python中没有自增自减的 ++ 或者– 运算<br>    混合计算时，Python会把整型转换成为浮点数  </p><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><pre><code>==  ！=  &gt;   &lt;   &gt;=  &lt;=</code></pre><p>注意：在python中没有 === 和 ！==运算，只要类型不同就是不等于</p><h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><pre><code>=   +=  -=  *=  /=  //= **=</code></pre><p>注意：a <em>= b 转换之后的表达式为 a = a </em> b 无论何种赋值运算都符合这个格式      </p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>逻辑运算是布尔值之间的运算<br>and 与运算：有假则假<br>or 或运算：有真则真<br>not 非运算:真变假，假变真</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>位运算就是在二进制基础上进行的逻辑运算，将0视为False，将1视为True进行的运算     </p><ul><li>&amp;   按位与运算</li><li>|   按位或运算</li><li><p>～   按位非运算<br>注意：按位非运算之后计算机会进行反码和补码的相关操作之后进行数据存储   </p></li><li><p>^   按位抑或运算:将数据转化为2进制数据然后进行每个位上的逻辑抑或运算<br>变量 = 值1 ^ 值2  </p></li><li><p>左移运算:将数据转化为二进制之后，将二进制数据的所有数据向左移动指定的位数<br>变量 = 值  &lt;&lt;  移动位数<br>特征：左移N位相当于乘以2的N次方，此方法速度远高于乘法   </p></li><li><p>右移运算<br>将数据转化为二进制之后，将二进制数据的所有数据向右移动指定的位数，如果数据移除右侧边界，则会被删除，实际上相当于采用了地板除！<br>变量 = 值 &gt;&gt;  移动位数<br>特征：右移N位相当于除以2的N次方，舍弃小数部分。此方法速度远高于除法 </p></li></ul><h3 id="成员运算"><a href="#成员运算" class="headerlink" title="成员运算"></a>成员运算</h3><ul><li><p>in 检测一个值在指定的序列类型里面<br>格式：  值 in 可迭代序列  </p></li><li><p>not in 检测一个值是否不再指定的序列里面<br>格式：  值 not in 可迭代序列</p></li></ul><h3 id="身份运算"><a href="#身份运算" class="headerlink" title="身份运算"></a>身份运算</h3><ul><li><p>is 检测值1是不是和值2在内存中是否是同一个值，类似id()功能<br>格式: 数据1 is 数据2  </p></li><li><p>is not 检测值1是不是和值2在内存中是否不是同一个值，类似id()功能<br>格式:   数据1 is not 数据2 </p></li></ul><h3 id="检测数据归属"><a href="#检测数据归属" class="headerlink" title="检测数据归属"></a>检测数据归属</h3><ul><li><p>type() 测试时可以使用，开发尽量避免使用<br>格式：type(变量)  </p></li><li><p>isinstance() 检测一个数据是否由指定的类型创建<br>格式：isinstance(变量，检测的类型)  </p></li></ul><h3 id="运算优先级问题"><a href="#运算优先级问题" class="headerlink" title="运算优先级问题"></a>运算优先级问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">**  指数 (最高优先级)  </span><br><span class="line">~ + -   按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)  </span><br><span class="line">* / % //    乘，除，取模和取整除  </span><br><span class="line">+ - 加法减法  </span><br><span class="line">&gt;&gt; &lt;&lt;   右移，左移运算符  </span><br><span class="line">&amp;   位 <span class="string">'AND'</span>  </span><br><span class="line">^ | 位运算符  </span><br><span class="line">&lt;= &lt; &gt; &gt;=   比较运算符  </span><br><span class="line">== !=    等于运算符  </span><br><span class="line">= %= /= //= -= += *= **=    赋值运算符   </span><br><span class="line"><span class="keyword">is</span> <span class="keyword">is</span> <span class="keyword">not</span>   身份运算符  </span><br><span class="line"><span class="keyword">in</span> <span class="keyword">not</span> <span class="keyword">in</span>   成员运算符  </span><br><span class="line"><span class="keyword">not</span> <span class="keyword">or</span> <span class="keyword">and</span>  逻辑运算符    </span><br><span class="line">注意：我们并不推荐死记硬背优先级，在实际使用中最好使用()解决优先级问题</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python的语法基础&quot;&gt;&lt;a href=&quot;#Python的语法基础&quot; class=&quot;headerlink&quot; title=&quot;Python的语法基础&quot;&gt;&lt;/a&gt;Python的语法基础&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;基础语法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基础语法
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
</feed>
