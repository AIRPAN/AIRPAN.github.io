<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AIR PAN</title>
  
  <subtitle>NOTE</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-27T14:41:16.431Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Air Pan</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WordPress个人博客搭建「一」</title>
    <link href="http://yoursite.com/2019/05/25/WordPress/01.WordPress/"/>
    <id>http://yoursite.com/2019/05/25/WordPress/01.WordPress/</id>
    <published>2019-05-25T10:11:07.000Z</published>
    <updated>2019-05-27T14:41:16.431Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一步一步教你基于WordPress搭建自己的个人博客，WordPress作为成熟的CMS框架，美观，方便，插件多，更新频繁，非常适合个人博客与网站的搭建，无需太多的代码基础。</p><h1 id="购买VPS"><a href="#购买VPS" class="headerlink" title="购买VPS"></a>购买VPS</h1><h2 id="购买云服务器"><a href="#购买云服务器" class="headerlink" title="购买云服务器"></a>购买云服务器</h2><p>为了搭建个人网站，首先肯定需要一个云服务器<br>国内的推荐腾讯云，毕竟大公司，工单服务贼及时！还送免费的CDN加速流量  </p><h2 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h2><p>有了云服务器，还需要一个域名。国内的域名需要备案，购买的话阿里云腾讯云都可以。</p><h1 id="搭建Apache-MySQL-PHP7环境"><a href="#搭建Apache-MySQL-PHP7环境" class="headerlink" title="搭建Apache+MySQL+PHP7环境"></a>搭建Apache+MySQL+PHP7环境</h1><p>这一部分介绍如何在Centos7 上配置Apache+MySQL+PHP7.</p><h2 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h2><p> yum install httpd httpd-devel  </p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>在CentOS7 中默认安装有MariaDB，这个是MySQL的分支，还是要在系统中安装MySQL，而且安装完成之后可以直接覆盖掉MariaDB</p><ul><li>下载MySQL官方的 Yum Repository 并安装MySQL。<br>[root@localhost ~]# wget -i -c <a href="http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm" target="_blank" rel="noopener">http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</a><br>[root@localhost ~]# yum -y install mysql57-community-release-el7-10.noarch.rpm<br>[root@localhost ~]# yum -y install mysql-community-server</li><li>MySQL 设置<br>找出初始的root用户的密码，通过如下命令可以在日志文件中找出密码：<br>[root@localhost ~]# grep “password” /var/log/mysqld.log<br>2019-05-19T00:42:03.830587Z 1 [Note] A temporary password is generated for root@localhost: 5&amp;vPo_Vej1GZ<br>如下命令进入数据库：<br>[root@localhost ~]# mysql -uroot -p<br>输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库：<br>mysql&gt; ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘new password’;</li></ul><h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><ul><li><p>安装php</p><h1 id="检查当前安装的PHP包"><a href="#检查当前安装的PHP包" class="headerlink" title="检查当前安装的PHP包"></a>检查当前安装的PHP包</h1><p>yum list installed | grep php<br>如果有安装的PHP包，先删除他们</p><h1 id="更新yum-源"><a href="#更新yum-源" class="headerlink" title="更新yum 源"></a>更新yum 源</h1><p>rpm -Uvh <a href="http://mirror.webtatic.com/yum/el5/latest.rpm" target="_blank" rel="noopener">http://mirror.webtatic.com/yum/el5/latest.rpm</a>    ##CentOs 5.x<br>rpm -Uvh <a href="http://mirror.webtatic.com/yum/el6/latest.rpm" target="_blank" rel="noopener">http://mirror.webtatic.com/yum/el6/latest.rpm</a>    ##CentOs 6.x<br>rpm -Uvh <a href="https://mirror.webtatic.com/yum/el7/epel-release.rpm" target="_blank" rel="noopener">https://mirror.webtatic.com/yum/el7/epel-release.rpm</a>   ##CentOs 7.X<br>rpm -Uvh <a href="https://mirror.webtatic.com/yum/el7/webtatic-release.rpm" target="_blank" rel="noopener">https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>yum install php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_64</p></li><li><p>测试PHP<br>[root@localhost ~]# cd  /var/www/html/<br>[root@localhost html]# vi info.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">        phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">测试：</span><br><span class="line">curl -I http://localhost/info.php</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 25 May 2019 01:06:40 GMT</span><br><span class="line">Server: Apache/2.4.6 (CentOS) PHP/7.0.33</span><br><span class="line">X-Powered-By: PHP/7.0.33</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure></li></ul><h1 id="基于LAMP-部署WordPress"><a href="#基于LAMP-部署WordPress" class="headerlink" title="基于LAMP 部署WordPress"></a>基于LAMP 部署WordPress</h1><h2 id="安装WordPress"><a href="#安装WordPress" class="headerlink" title="安装WordPress"></a>安装WordPress</h2><ul><li>下载WordPress<br>直接通过wget命令去它官网下载最新的版本（英文）：<br>wget <a href="http://wordpress.org/latest.tar.gz" target="_blank" rel="noopener">http://wordpress.org/latest.tar.gz</a><br>下载中文wordpress-5.0.3:<br>wget <a href="https://cn.wordpress.org/wordpress-5.0.3-zh_CN.tar.gz" target="_blank" rel="noopener">https://cn.wordpress.org/wordpress-5.0.3-zh_CN.tar.gz</a><br>tar -xzvf wordpress-5.0.3-zh_CN.tar.gz</li></ul><h2 id="创建WordPress操作的数据库和用户"><a href="#创建WordPress操作的数据库和用户" class="headerlink" title="创建WordPress操作的数据库和用户"></a>创建WordPress操作的数据库和用户</h2><ul><li><p>创建数据库：<br>CREATE DATABASE wordpress;</p></li><li><p>配置权限：<br>GRANT ALL PRIVILEGES ON wordpress.* TO wordpress@localhost IDENTIFIED BY ‘your password’;<br>FLUSH PRIVILEGES;</p></li></ul><h2 id="配置WordPress"><a href="#配置WordPress" class="headerlink" title="配置WordPress"></a>配置WordPress</h2><ul><li><p>修改配置文件wordpress/wp-config-sample.php<br>修改的内容包括DB_NAME，DB_USER，DB_PASSWORD以及下面的唯一key</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">define( &apos;DB_NAME&apos;, &apos;wordpress&apos; );</span><br><span class="line">define( &apos;DB_USER&apos;, &apos;wordpress&apos; );</span><br><span class="line">define( &apos;DB_PASSWORD&apos;, &apos;WordPress@1234&apos; );</span><br><span class="line">define( &apos;DB_HOST&apos;, &apos;localhost&apos; );</span><br></pre></td></tr></table></figure></li><li><p>拷贝WordPress源码至网站根目录<br>rm -rf /var/www/html<br>cp -r wordpress/* /var/www/<br>mv wordpress html</p></li><li><p>安装WordPress<br>访问你的ip或者是域名应该就是这样子的了：<br><a href="http://x.x.x.x/wp-admin/install.php" target="_blank" rel="noopener">http://x.x.x.x/wp-admin/install.php</a><br><img src="https://s2.ax1x.com/2019/05/25/VkkWx1.png" alt="VkkWx1.png"></p></li><li><p>根据提示安装并登录<br>安装WordPress -&gt; 数据库信息 -&gt; 站点、用户、邮箱 -&gt;登陆</p></li><li><p>后台管理<br>输入“域名/wp-admin/”或“公网ip/wp-admin/”，就可以进入网站的后台管理页面了：<br><img src="https://s2.ax1x.com/2019/05/25/VkkBrV.md.png" alt="VkkBrV.md.png"></p></li><li><p>访问你的IP或者域名，一个初始的博客就搭建好了~：<br><img src="https://s2.ax1x.com/2019/05/25/VkZkzd.md.png" alt="VkZkzd.md.png"></p></li></ul>]]></content>
    
    <summary type="html">
    
      「WordPress」
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Wordpress" scheme="http://yoursite.com/tags/Wordpress/"/>
    
  </entry>
  
  <entry>
    <title>Python 的常用模块</title>
    <link href="http://yoursite.com/2019/05/20/Python/03.High-level/03.Pyhton%E7%9A%84%E5%B8%B8%E7%94%A8%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2019/05/20/Python/03.High-level/03.Pyhton的常用模块/</id>
    <published>2019-05-20T10:11:07.000Z</published>
    <updated>2019-05-24T08:29:00.003Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用模块"><a href="#常用模块" class="headerlink" title="常用模块"></a>常用模块</h1><ul><li>calendar</li><li><a href="https://www.runoob.com/python/python-date-time.html" target="_blank" rel="noopener">time</a></li><li><a href="https://www.cnblogs.com/tkqasn/p/6001134.html" target="_blank" rel="noopener">datetime</a></li><li>timeit</li><li><a href="https://www.runoob.com/python3/python3-os-file-methods.html" target="_blank" rel="noopener">os</a></li><li>shutil</li><li>归档</li><li>zip</li><li>random</li><li>string</li><li>上述所有模块使用理论上都应该先导入，string是特例</li></ul><h2 id="calendar"><a href="#calendar" class="headerlink" title="calendar"></a>calendar</h2><ul><li>跟日历相关的模块</li></ul><h2 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h2><ul><li><p>时间戳<br>一个时间表示，根据不同语言，可以是整数或者浮点数<br>是从1970年1月1日0时0分0秒到现在经历的秒数<br>如果表示的时间是1970年以前或者太遥远的未来，可能出现异常<br>32位操作系统能够支持到2038年</p></li><li><p>UTC时间<br>UTC又称为世界协调时间，以英国的格林尼治天文所在地区的时间作为参考的时间，也叫做世界标准时间。<br>中国时间是 UTC+8 东八区</p></li><li><p>夏令时<br>夏令时就是在夏天的时候将时间调快一小时，本意是督促大家早睡早起节省蜡烛！ 每天变成25个小时，本质没变还是24小时</p></li></ul><h3 id="时间元组"><a href="#时间元组" class="headerlink" title="时间元组"></a>时间元组</h3><ul><li><p>一个包含时间内容的普通元组</p><pre><code>索引      内容    属性            值0       年       tm_year     20151       月       tm_mon      1～122       日       tm_mday     1～313       时       tm_hour     0～234       分       tm_min      0～595       秒       tm_sec      0～61  60表示闰秒  61保留值6       周几     tm_wday     0～67       第几天    tm_yday     1～3668       夏令时    tm_isdst    0，1，-1（表示夏令时）</code></pre></li></ul><h3 id="时间模块的属性"><a href="#时间模块的属性" class="headerlink" title="时间模块的属性"></a>时间模块的属性</h3><ul><li>timezone: 当前时区和UTC时间相差的秒数，在没有夏令时的情况下的间隔,东八区的是 -28800</li><li>altzone  获取当前时区与UTC时间相差的秒数，在有夏令时的情况下，</li><li>daylight 测当前是否是夏令时时间状态, 0 表示是。time.daylight</li></ul><h3 id="时间模块的方法"><a href="#时间模块的方法" class="headerlink" title="时间模块的方法"></a>时间模块的方法</h3><ul><li><p>time.time()<br>返回值: 时间戳</p></li><li><p>localtime() 得到当前时间的时间结构<br>t = time.localtime()<br>print(t.tm_hour)</p></li><li><p>asctime() 返回元组的正常字符串化之后的时间格式<br>格式：time.asctime（时间元组）<br>返回值:字符串 Tue Jun  6 11:11:00 2017<br>t = time.localtime()<br>tt = time.asctime(t)</p></li><li><p>ctime: 获取字符串化的当前时间<br>格式：time.ctime()<br>返回值：字符串 Mon Mar 26 20:46:30 2018<br>t = time.ctime()</p></li><li><p>mktime() 使用时间元组获取对应的时间戳<br>格式：time.mktime（时间元组）<br>返回值：浮点数时间戳<br>lt = time.localtime()<br>ts = time.mktime(lt)</p></li><li><p>sleep: 使程序进入睡眠，n秒后继续<br>格式：sleep(5)</p></li><li><p>clock() 获取CPU时间<br>格式：time.clock()</p></li><li><p>strftime:将时间元组转化为自定义的字符串格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">格式  含义  备注</span><br><span class="line">%a  本地（locale）简化星期名称    </span><br><span class="line">%A  本地完整星期名称    </span><br><span class="line">%b  本地简化月份名称    </span><br><span class="line">%B  本地完整月份名称    </span><br><span class="line">%c  本地相应的日期和时间表示    </span><br><span class="line">%d  一个月中的第几天（01 - 31）   </span><br><span class="line">%H  一天中的第几个小时（24 小时制，00 - 23）   </span><br><span class="line">%I  一天中的第几个小时（12 小时制，01 - 12）   </span><br><span class="line">%j  一年中的第几天（001 - 366）  </span><br><span class="line">%m  月份（01 - 12） </span><br><span class="line">%M  分钟数（00 - 59）    </span><br><span class="line">%p  本地 am 或者 pm 的相应符    注1</span><br><span class="line">%S  秒（01 - 61）  注2</span><br><span class="line">%U  一年中的星期数（00 - 53 星期天是一个星期的开始）第一个星期天之前的所有天数都放在第 0 周   注3</span><br><span class="line">%w  一个星期中的第几天（0 - 6，0 是星期天） 注3</span><br><span class="line">%W  和 %U 基本相同，不同的是 %W 以星期一为一个星期的开始  </span><br><span class="line">%x  本地相应日期  </span><br><span class="line">%X  本地相应时间  </span><br><span class="line">%y  去掉世纪的年份（00 - 99）    </span><br><span class="line">%Y  完整的年份   </span><br><span class="line">%z  用 +HHMM 或 -HHMM 表示距离格林威治的时区偏移（H 代表十进制的小时数，M 代表十进制的分钟数）      </span><br><span class="line">%%  %号本身</span><br><span class="line"></span><br><span class="line"># 把时间表示成: 2018年3月26日 21:05</span><br><span class="line">t = time.localtime()</span><br><span class="line">ft = time.strftime(&quot;%Y年%m月%d日 %H:%M&quot; , t)</span><br></pre></td></tr></table></figure></li></ul><h2 id="datetime-模块"><a href="#datetime-模块" class="headerlink" title="datetime 模块"></a>datetime 模块</h2><ul><li>datetinme 提供日期和时间的运算和表示</li></ul><h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><ul><li><p>datetime.today()<br>返回当前本地datetime.</p></li><li><p>datetime.fromtimestamp(time.time()). </p></li><li><p>datetime.now([tz])<br>返回当前本地日期和时间,如果可选参数tz为None或没有详细说明,这个方法会像today().  </p></li><li><p>datetime.utcnow()<br>返回当前的UTC日期和时间, 如果tzinfo None ,那么与now()类似.</p></li><li><p>datetime.fromtimestamp(timestamp[, tz])<br>根据时间戳返回本地的日期和时间.tz指定时区.</p></li><li><p>datetime.utcfromtimestamp(timestamp)<br>根据时间戳返回 UTC datetime.</p></li><li><p>datetime.fromordinal(ordinal)<br>根据Gregorian ordinal 返回datetime.</p></li><li><p>datetime.combine(date, time)<br>根据date和time返回一个新的datetime.</p></li><li><p>datetime.strptime(date_string, format)<br>根据date_string和format返回一个datetime.</p></li></ul><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><ul><li><p>datetime.date()<br>返回相同年月日的date对象.</p></li><li><p>datetime.time()<br>返回相同时分秒微秒的time对象.</p></li><li><p>datetime.replace(kw)<br>kw in [year, month, day, hour, minute, second, microsecond, tzinfo], 与date类似.</p></li></ul><h3 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h3><ul><li>datetime.min: datetime(MINYEAR, 1, 1).</li><li>datetime.max: datetime(MAXYEAR, 12, 31, 23, 59, 59, 999999).</li></ul><h3 id="实例属性-read-only"><a href="#实例属性-read-only" class="headerlink" title="实例属性(read-only)"></a>实例属性(read-only)</h3><ul><li>datetime.year: 1 至 9999</li><li>datetime.month: 1 至 12</li><li>datetime.day: 1 至 n</li><li>datetime.hour: In range(24). 0 至 23</li><li>datetime.minute: In range(60).</li><li>datetime.second: In range(60).</li><li>datetime.microsecond: In range(1000000).</li></ul><h2 id="timeit-时间测量工具"><a href="#timeit-时间测量工具" class="headerlink" title="timeit-时间测量工具"></a>timeit-时间测量工具</h2><ul><li><p>测量程序运行时间间隔实验</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import timeit</span><br><span class="line"></span><br><span class="line"># 生成列表两种方法的比较</span><br><span class="line"># 如果单纯比较生成一个列表的时间，可能很难实现</span><br><span class="line">c = &apos;&apos;&apos;</span><br><span class="line">sum = []</span><br><span class="line">for i in range(1000):</span><br><span class="line">    sum.append(i)</span><br><span class="line"> </span><br><span class="line"># 利用timeit调用代码，执行100000次，查看运行时间</span><br><span class="line">t1= timeit.timeit(stmt=&quot;[i for i in range(1000)]&quot;, number=100000 )</span><br><span class="line"></span><br><span class="line"># 测量代码c执行100000次运行结果</span><br><span class="line">t2 = timeit.timeit(stmt=c, number=100000)</span><br><span class="line">print(t1)</span><br><span class="line">print(t2)</span><br><span class="line"></span><br><span class="line">2.6834080209991953</span><br><span class="line">6.945136217000254</span><br></pre></td></tr></table></figure></li><li><p>timeit 可以执行一个函数，来测量一个函数的执行时间 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">def doIt():</span><br><span class="line">    num = 3</span><br><span class="line">    for i in range(num):</span><br><span class="line">        print(&quot;Repeat for &#123;0&#125;&quot;.format(i))</span><br><span class="line">       </span><br><span class="line"># 执行函数，重复10次</span><br><span class="line">t = timeit.timeit(stmt=doIt, number=10)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">s = &apos;&apos;&apos;</span><br><span class="line">def doIt(num):</span><br><span class="line">    for i in range(num):</span><br><span class="line">        print(&quot;Repeat for &#123;0&#125;&quot;.format(i))</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line"># 执行doIt(num)</span><br><span class="line"># setup负责把环境变量准备好</span><br><span class="line"># 实际相当于给timeit创造了一个小环境</span><br><span class="line"># 在创作的小环境中， 代码执行的顺序大致是</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">def doIt(num):</span><br><span class="line">    .....</span><br><span class="line">    </span><br><span class="line">num = 3</span><br><span class="line"></span><br><span class="line">doIt(num)</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">t = timeit.timeit(&quot;doIt(num)&quot;, setup=s+&quot;num=3&quot;, number=10)</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure></li></ul><h2 id="os-操作系统相关"><a href="#os-操作系统相关" class="headerlink" title="os - 操作系统相关"></a>os - 操作系统相关</h2><ul><li>跟操作系统相关，主要是文件操作</li><li>于系统相关的操作，主要包含在三个模块里<ul><li>os， 操作系统目录相关</li><li>os.path, 系统路径相关操作</li><li>shutil， 高级文件操作，目录树的操作，文件赋值，删除，移动</li></ul></li><li>路径：<ul><li>绝对路径： 总是从根目录上开始</li><li>相对路径： 基本以当前环境为开始的一个相对的地方</li></ul></li><li>import os</li></ul><h3 id="os-模块"><a href="#os-模块" class="headerlink" title="os 模块"></a>os 模块</h3><ul><li><p>getcwd() 获取当前的工作目录<br>格式：os.getcwd()<br>返回值：当前工作目录的字符串</p></li><li><p>chdir() 改变当前的工作目录<br>格式：os.chdir（路径）<br>返回值：无</p></li><li><p>listdir() 获取一个目录中所有子目录和文件的名称列表<br>格式:os.listdir(路径)<br>返回值：所有子目录和文件名称的列表</p></li><li><p>makedirs（） 递归创建文件夹<br>格式：os.makedirs(递归路径)<br>返回值：无<br>递归路径：多个文件夹层层包含的路径就是递归路径 例如 ‘a/b/c…’</p></li></ul><ul><li><p>system() 运行系统shell命令<br>格式：os.system(系统命令)<br>返回值：打开一个shell或者终端界面<br>一般推荐使用subprocess代替</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rst = os.system(&quot;ls&quot;)</span><br><span class="line">print(rst)</span><br></pre></td></tr></table></figure></li><li><p>getenv() 获取指定的系统环境变量值<br>相应的还有putenv<br>格式：os.getenv(‘环境变量名’)<br>返回值：指定环境变量名对应的值</p></li></ul><h3 id="值部分"><a href="#值部分" class="headerlink" title="值部分"></a>值部分</h3><ul><li>os.curdir: curretn dir,当前目录</li><li>os.pardir: parent dir， 父亲目录</li><li>os.sep: 当前系统的路径分隔符<ul><li>windows: “\”</li><li>linux: “/“</li></ul></li><li>os.linesep: 当前系统的换行符号<ul><li>windows: “\r\n”</li><li>unix,linux,macos: “\n”</li></ul></li><li>os.name： 当前系统名称<ul><li>windows： nt</li><li>mac，unix，linux： posix</li></ul></li></ul><h3 id="os-path-模块-路径相关的模块"><a href="#os-path-模块-路径相关的模块" class="headerlink" title="os.path 模块,路径相关的模块"></a>os.path 模块,路径相关的模块</h3><ul><li><p>abspath() 将路径转化为绝对路径<br>格式:os.path.abspath(‘路径’)<br>返回值：路径的绝对路径形式</p></li><li><p>basename() 获取路径中的文件名部分<br>格式:os.path.basename(路径)<br>返回值：文件名字符串</p></li><li><p>join() 将多个路径拼合成一个路径<br>格式：os.path.join(路径1，路径2….)<br>返回值：组合之后的新路径字符串</p></li><li><p>split() 将路径切割为文件夹部分和当前文件部分<br>格式:os.path.split（路径）<br>返回值：路径和文件名组成的元组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t = op.split(&quot;/home/tlxy/dana.haha&quot;)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line">d,p = op.split(&quot;/home/tlxy/dana.haha&quot;)</span><br><span class="line">print(d, p)</span><br><span class="line"></span><br><span class="line">(&apos;/home/tlxy&apos;, &apos;dana.haha&apos;)</span><br><span class="line">/home/tlxy dana.haha</span><br></pre></td></tr></table></figure></li><li><p>isdir() 检测是否是目录<br>格式：os.path.isdir(路径)<br>返回值：布尔值</p></li><li><p>jexists() 检测文件或者目录是否存在<br>格式：os.path.exists(路径)<br>返回值:布尔值</p></li></ul><h2 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h2><ul><li><p>copy() 复制文件<br>格式：shutil.copy(来源路径，目标路径)<br>返回值：返回目标路径<br>拷贝的同时，可以给文件重命名</p></li><li><p>copy2() 复制文件,(保留元数据文件信息）<br>格式：shutil.copy2(来源路径，目标路径)<br>返回值：返回目标路径<br>注意：copy和copy2的唯一区别在于copy2复制文件时尽量保留元数据</p></li><li><p>copyfile()将一个文件中的内容复制到另外一个文件当中<br>格式：shutil.copyfile（’源路径’,’目标路径’)<br>返回值：无</p></li><li><p>move() 移动文件/文件夹<br>格式：shutil.move(源路径，目标路径)<br>返回值：目标路径</p></li></ul><h2 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h2><ul><li><p>归档： 把多个文件或者文件夹合并到一个文件当中</p></li><li><p>make_archive() 归档操作<br>格式:shutil.make_archive(‘归档之后的目录和文件名’,’后缀’,’需要归档的文件夹’)<br>返回值：归档之后的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#help(shutil.make_archive)</span><br><span class="line"></span><br><span class="line"># 是想得到一个叫做tuling.zip的归档文件</span><br><span class="line">rst = shutil.make_archive(&quot;/home/tlxy/tuling&quot;, &quot;zip&quot;, &quot;/home/tlxy/dana&quot;)</span><br><span class="line">print(rst) # /home/tlxy/tuling.zip</span><br></pre></td></tr></table></figure></li><li><p>unpack_archive() 解包操作<br>格式：shutil.unpack_archive(‘归档文件地址’,’解包之后的地址’)<br>返回值：解包之后的地址</p></li></ul><h2 id="zip-压缩包"><a href="#zip-压缩包" class="headerlink" title="zip - 压缩包"></a>zip - 压缩包</h2><ul><li>压缩： 用算法把多个文件或者文件夹无损或者有损合并到一个文件当中</li><li><p>模块名称叫 zipfile</p></li><li><p>zipfile.ZipFile(file[, mode[, compression[, allowZip64]]])</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个ZipFile对象，表示一个zip文件。参数file表示文件的路径或类文件对象(file-like object)；参数mode指示打开zip文件的模式，默认值为’r’，表示读已经存在的zip文件，也可以为’w’或’a’，’w’表示新建一个zip文档或覆盖一个已经存在的zip文档，’a’表示将数据附加到一个现存的zip文档中。参数compression表示在写zip文档时使用的压缩方法，它的值可以是zipfile. ZIP_STORED 或zipfile. ZIP_DEFLATED。如果要操作的zip文件大小超过2G，应该将allowZip64设置为True。</span><br><span class="line"></span><br><span class="line"># 对/home/tlxy/tuling.zip压缩</span><br><span class="line">zf = zipfile.ZipFile(&quot;/home/tlxy/tuling.zip&quot;)</span><br></pre></td></tr></table></figure></li><li><p>ZipFile.getinfo(name):<br>获取zip文档内指定文件的信息。返回一个zipfile.ZipInfo对象，它包括文件的详细信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rst = zf.getinfo(&quot;dana.haha&quot;)</span><br><span class="line">print(rst)</span><br><span class="line"></span><br><span class="line">&lt;ZipInfo filename=&apos;dana.haha&apos; compress_type=deflate filemode=&apos;-rw-rw-r--&apos; file_size=41 compress_size=46&gt;</span><br></pre></td></tr></table></figure></li><li><p>ZipFile.namelist()<br>获取zip文档内所有文件的名称列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nl = zf.namelist()</span><br><span class="line"></span><br><span class="line"># ZipFile.extractall([path[, members[, pwd]]])</span><br><span class="line">#  解压zip文档中的所有文件到当前目录。参数members的默认值为zip文档内的所有文件名称列表，也可以自己设置，选择要解压的文件名称。</span><br><span class="line"></span><br><span class="line">rst = zf.extractall(&quot;/home/tlxy/dana&quot;)</span><br></pre></td></tr></table></figure></li></ul><h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><ul><li>随机数</li><li><p>所有的随机模块都是伪随机</p></li><li><p>random() 获取0-1之间的随机小数<br>格式：random.random()<br>返回值：随机0-1之间的小数</p></li><li><p>choice() 随机返回序列中的某个值<br>格式：random.choice(序列)<br>返回值：序列中的某个值</p></li></ul><ul><li><p>shuffle() 随机打乱列表<br>格式：random.shuffle(列表)<br>返回值：打乱顺序之后的列表</p></li><li><p>randint(a,b): 返回一个a到b之间的随机整数，包含a和b</p></li></ul>]]></content>
    
    <summary type="html">
    
      「常用模块」
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 的异常处理</title>
    <link href="http://yoursite.com/2019/05/14/Python/03.High-level/02.Python%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/14/Python/03.High-level/02.Python的异常处理/</id>
    <published>2019-05-14T10:11:07.000Z</published>
    <updated>2019-05-24T08:32:13.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><ul><li>异常的分类</li><li>异常处理</li><li>异常手动抛出</li><li>自定义异常</li></ul><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><pre><code>AssertError 断言语句（assert）失败AttributeError 尝试访问未知的对象属性EOFError 用户输入文件末尾标志EOF（Ctrl+d）FloatingPointError 浮点计算错误GeneratorExit generator.close()方法被调用的时候ImportError 导入模块失败的时候IndexError 索引超出序列的范围KeyError 字典中查找一个不存在的关键字KeyboardInterrupt 用户输入中断键（Ctrl+c）MemoryError 内存溢出（可通过删除对象释放内存）NameError 尝试访问一个不存在的变量NotImplementedError 尚未实现的方法OSError 操作系统产生的异常（例如打开一个不存在的文件）OverflowError 数值运算超出最大限制ReferenceError 弱引用（weak reference）试图访问一个已经被垃圾回收机制回收了的对象RuntimeError 一般的运行时错误StopIteration 迭代器没有更多的值SyntaxError Python的语法错误IndentationError 缩进错误TabError Tab和空格混合使用SystemError Python编译器系统错误SystemExit Python编译器进程被关闭TypeError 不同类型间的无效操作UnboundLocalError 访问一个未初始化的本地变量（NameError的子类）UnicodeError Unicode相关的错误（ValueError的子类）UnicodeEncodeError Unicode编码时的错误（UnicodeError的子类）UnicodeDecodeError Unicode解码时的错误（UnicodeError的子类）UnicodeTranslateError Unicode转换时的错误（UnicodeError的子类）ValueError 传入无效的参数ZeroDivisionError 除数为零</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><ul><li>不能保证程序永远正确运行</li><li>但是，必须保证程序在最坏的情况下得到的问题被妥善处理</li><li><p>python的异常处理模块全部语法为：</p><pre><code>try:    尝试实现某个操作，    如果没出现异常，任务就可以完成    如果出现异常，将异常从当前代码块扔出去尝试解决异常except 异常类型1:    解决方案1：用于尝试在此处处理异常解决问题except 异常类型2：    解决方案2：用于尝试在此处处理异常解决问题except (异常类型1,异常类型2...)    解决方案：针对多个异常使用相同的处理方式excpet:    解决方案：所有异常的解决方案else:    如果没有出现任何异常，将会执行此处代码finally:    管你有没有异常都要执行的代码</code></pre></li></ul><ul><li>流程</li></ul><ol><li>执行try下面的语句</li><li>如果出现异常，则在except语句里查找对应异常病进行处理</li><li>如果没有出现异常，则执行else语句内容</li><li>最后，不管是否出现异常，都要执行finally语句</li></ol><ul><li>除except(最少一个)以外，else和finally可选<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"># 简单异常案例1:</span><br><span class="line">try:</span><br><span class="line">    num = int(input(&quot;Plz input your number:&quot;))</span><br><span class="line">    rst = 100/num</span><br><span class="line">    print(&quot;计算结果是： &#123;0&#125;&quot;.format(rst))</span><br><span class="line">except:</span><br><span class="line">    print(&quot;你特娘的输入的啥玩意儿&quot;)</span><br><span class="line">    # exit是退出程序的意思</span><br><span class="line">    exit()</span><br><span class="line">  </span><br><span class="line">Plz input your number:0</span><br><span class="line">你特娘的输入的啥玩意儿  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 简单异常案例2:</span><br><span class="line"># 给出提示信息</span><br><span class="line">try:</span><br><span class="line">    num = int(input(&quot;Plz input your number:&quot;))</span><br><span class="line">    rst = 100/num</span><br><span class="line">    print(&quot;计算结果是： &#123;0&#125;&quot;.format(rst))</span><br><span class="line"># 捕获异常后，把异常实例化，出息信息会在实例里</span><br><span class="line"># 注意以下写法</span><br><span class="line"># 以下语句是捕获ZeroDivisionError异常并实例化实例e</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&quot;你特娘的输入的啥玩意儿&quot;)</span><br><span class="line">    print(e)</span><br><span class="line">    # exit是退出程序的意思</span><br><span class="line">    exit()</span><br><span class="line">    </span><br><span class="line">Plz input your number:0</span><br><span class="line">你特娘的输入的啥玩意儿</span><br><span class="line">division by zero</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 简单异常案例3:</span><br><span class="line"># 给出提示信息</span><br><span class="line">try:</span><br><span class="line">    num = int(input(&quot;Plz input your number:&quot;))</span><br><span class="line">    rst = 100/num</span><br><span class="line">    print(&quot;计算结果是： &#123;0&#125;&quot;.format(rst))</span><br><span class="line"></span><br><span class="line"># 如果是多种error的情况</span><br><span class="line"># 需要把越具体的错误，越往前放</span><br><span class="line"># 在异常类继承关系中，越是子类的异常，越要往前放，</span><br><span class="line"># 越是父亲类的异常，越要往后放</span><br><span class="line"></span><br><span class="line"># 在处理异常的时候，一旦拦截到某一个异常，则不在继续往下查看，直接进行下一个</span><br><span class="line"># 代码，即有finally则执行finally语句块，否则就执行下一个大的语句</span><br><span class="line">except ZeroDivisionError as e:</span><br><span class="line">    print(&quot;你特娘的输入的啥玩意儿&quot;)</span><br><span class="line">    print(e)</span><br><span class="line">    # exit是退出程序的意思</span><br><span class="line">    exit()</span><br><span class="line">except NameError as e:</span><br><span class="line">    print(&quot;名字起错了&quot;)</span><br><span class="line">    print(e)</span><br><span class="line"></span><br><span class="line">except AttributeError as e:</span><br><span class="line">    print(&quot;好像属性有问题&quot;)</span><br><span class="line">    print(e)</span><br><span class="line">    exit()</span><br><span class="line">   </span><br><span class="line"># 所有异常都是继承自Exception</span><br><span class="line"># 如果写上下面这句话，任何异常都会拦截住</span><br><span class="line"># 而且，下面这句话一定是最后一个exception</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(&quot;我也不知道就出错了&quot;)</span><br><span class="line">    print(e)</span><br><span class="line">    </span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&quot;NO&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;) </span><br><span class="line"></span><br><span class="line">Plz input your number:rerer</span><br><span class="line">我也不知道就出错了</span><br><span class="line">invalid literal for int() with base 10: &apos;rerer&apos;</span><br></pre></td></tr></table></figure></li></ul><h2 id="用户手动引发异常"><a href="#用户手动引发异常" class="headerlink" title="用户手动引发异常"></a>用户手动引发异常</h2><ul><li>当某些情况，用户希望自己引发一个异常的时候，可以使用</li><li>raise 关键字来引发异常<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># raise案例-1</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    # 手动引发一个异常</span><br><span class="line">    #　注意语法：　raise　errorclassname</span><br><span class="line">    raise ValueError</span><br><span class="line">    print(&quot;还没完呀&quot;)</span><br><span class="line">except NameError as e:</span><br><span class="line">    print(&quot;NameError&quot;)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&quot;ValueError&quot;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(&quot;有异常&quot;)</span><br><span class="line">finally:</span><br><span class="line">    print(&quot;我肯定会被执行的&quot;)</span><br><span class="line">    </span><br><span class="line">ValueError</span><br><span class="line">我肯定会被执行的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># raise案例-2</span><br><span class="line"></span><br><span class="line"># 自己定义异常</span><br><span class="line"># 需要注意：　自定义异常必须是系统异常的子类</span><br><span class="line">class DanaValueError(ValueError):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    # 手动引发一个异常</span><br><span class="line">    #　注意语法：　raise　errorclassname</span><br><span class="line">    raise DanaValueError</span><br><span class="line">    print(&quot;还没完呀&quot;)</span><br><span class="line">except NameError as e:</span><br><span class="line">    print(&quot;NameError&quot;)</span><br><span class="line">except ValueError as e:</span><br><span class="line">    print(&quot;ValueError&quot;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(&quot;有异常&quot;)</span><br><span class="line">finally:</span><br><span class="line">    print(&quot;我肯定会被执行的&quot;)</span><br><span class="line">    </span><br><span class="line">ValueError</span><br><span class="line">我肯定会被执行的    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># else语句案例:</span><br><span class="line">try:</span><br><span class="line">    num = int(input(&quot;Plz input your number:&quot;))</span><br><span class="line">    rst = 100/num</span><br><span class="line">    print(&quot;计算结果是： &#123;0&#125;&quot;.format(rst))</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(&quot;Exception&quot;)</span><br><span class="line">    </span><br><span class="line">else:</span><br><span class="line">    print(&quot;No Exception&quot;)</span><br><span class="line">finally:</span><br><span class="line">    print(&quot;反正我会被执行&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Plz input your number:ghhj</span><br><span class="line">Exception</span><br><span class="line">反正我会被执行</span><br></pre></td></tr></table></figure></li></ul><h2 id="关于自定义异常"><a href="#关于自定义异常" class="headerlink" title="关于自定义异常"></a>关于自定义异常</h2><ul><li>只要是raise异常，则推荐自定义异常</li><li>在自定义异常的时候，一般包含以下内容：<ul><li>自定义发生异常的异常代码</li><li>自定义发生异常后的问题提示</li><li>自定义发生异常的行数</li></ul></li><li>最终的目的是，一旦发生异常，方便程序员快速定位错误现场</li></ul>]]></content>
    
    <summary type="html">
    
      「异常」
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 的模块和包</title>
    <link href="http://yoursite.com/2019/05/10/Python/03.High-level/01.Python%E7%9A%84%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85/"/>
    <id>http://yoursite.com/2019/05/10/Python/03.High-level/01.Python的模块和包/</id>
    <published>2019-05-10T10:11:07.000Z</published>
    <updated>2019-05-24T08:10:05.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-的模块和包"><a href="#Python-的模块和包" class="headerlink" title="Python 的模块和包"></a>Python 的模块和包</h1><ul><li>模块</li><li>包  </li><li>命名空间</li></ul><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><ul><li>一个模块就是一个包含pytho代码的文件， 后缀名成是.py就可以，模块就是个python文件</li><li><p>为什么我们用模块<br>程序太大，编写维护非常不方便，需要拆分<br>模块可以增加代码重复利用的方式<br>当做命名空间使用，避免命名冲突</p></li><li><p>如何定义模块<br>模块就是一个普通文件，所以任何代码可以直接书写<br>不过根据模块的规范，最好在模块中编写以下内容：<br>函数（单一功能）<br>类（相似功能的组合，或者类似业务模块）<br>测试代码</p></li><li><p>如何使用模块<br>模块直接导入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import module_name</span><br><span class="line">module_name.function_name</span><br><span class="line">module_name.class_name</span><br></pre></td></tr></table></figure></li><li><p>假如模块名称直接以数字开头，借助importlib帮助</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 借助于importlib包可以实现导入以数字开头的模块名称</span><br><span class="line">import importlib</span><br><span class="line"></span><br><span class="line"># 相当于导入了一个叫01的模块并把导入模块赋值给了tuling</span><br><span class="line">tuling = importlib.import_module(&quot;01&quot;)</span><br><span class="line"></span><br><span class="line">stu = tuling.Student()</span><br><span class="line">stu.say()</span><br></pre></td></tr></table></figure></li><li><p>import 模块 as 别名<br>from module_name import func_name, class_name<br>按上述方法有选择性的导入<br>使用的时候可以直接使用导入的内容，不需要前缀</p></li><li><p>from module_name import *<br>导入模块所有内容</p></li><li><p><code>if __name__ == &quot;__main__</code> 的使用<br>可以有效避免模块代码被导入的时候被动执行的问题<br>建议所欲程序的入口都以此代码为入口</p></li></ul><h3 id="模块的搜索路径和存储"><a href="#模块的搜索路径和存储" class="headerlink" title="模块的搜索路径和存储"></a>模块的搜索路径和存储</h3><ul><li><p>什么是模块的搜索路径：<br>加载模块的时候，系统会在那些地方寻找此模块</p></li><li><p>系统默认的模块搜索路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">sys.path 属性可以获取路径列表</span><br></pre></td></tr></table></figure></li><li><p>添加搜索路径: sys.path.append(dir)</p></li><li><p>模块的加载顺序<br>搜索内存中已经加载好的模块<br>搜索python的内置模块<br>搜索sys.path路径 </p></li></ul><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul><li>包是一种组织管理代码的方式，包里面存放的是模块<br>-　用于将模块包含在一起的文件夹就是包  </li><li>自定义包的结构</li></ul><pre><code>|---包|---|--- __init__.py  包的标志文件|---|--- 模块1|---|--- 模块2|---|--- 子包(子文件夹)|---|---|--- __init__.py  包的标志文件|---|---|--- 子包模块1|---|---|--- 子包模块2</code></pre><ul><li><p>包的导入操作<br>import package_name<br>直接导入一个包，可以使用<strong>init</strong>.py中的内容<br>使用方式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package_name.func_name</span><br><span class="line">package_name.class_name.func_name()</span><br></pre></td></tr></table></figure></li><li><p>import package_name as p<br>注意:此种方法是默认对<strong>init</strong>.py内容的导入    </p></li><li><p>import package.module<br>导入包中某一个具体的模块<br>使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package.module.func_name</span><br><span class="line">package.module.class.fun()</span><br><span class="line">package.module.class.var</span><br></pre></td></tr></table></figure></li><li><p>import package.module as pm </p></li><li><p>from … import 导入<br>from package import module1, module2, module3<br>此种导入方法不执行<code>__init__</code>的内容</p></li><li><p>from package import *<br>导入当前包 <code>__init__.py</code>文件中所有的函数和类<br>使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func_name()</span><br><span class="line">class_name.func_name()</span><br><span class="line">class_name.var</span><br></pre></td></tr></table></figure></li><li><p>from package.module import *<br>导入包中指定的模块的所有内容<br>使用方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func_name()</span><br><span class="line">class_name.func_name()</span><br></pre></td></tr></table></figure></li><li><p>在开发环境中经常会所以用其他模块，可以在当前包中直接导入其他模块中的内容</p></li><li><p>import 完整的包或者模块的路径</p></li><li><p><code>__all__</code> 的用法<br>在使用from package import <em> 的时候， </em> 可以导入的内容  </p></li><li><p><code>__init__.py</code>中如果文件为空， 或者没有 <code>__all__</code>， 那么只可以把<code>__init__</code>中的内容导入</p></li><li><p><code>__init__</code> 如果设置了<code>__all__</code>的值，那么则按照<code>__all__</code> 指定的子包或者模块进行加载<br>  如此则不会载入<code>__init__</code>中的内容</p></li><li><p><code>__all__=[&#39;module1&#39;, &#39;module2&#39;, &#39;package1&#39;.........]</code></p></li></ul><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><ul><li>用于区分不同位置不同功能但相同名称的函数或者变量的一个特定前缀</li><li>作用是防止命名冲突<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setName()</span><br><span class="line">Student.setName()</span><br><span class="line">Dog.setName()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      「Python 的模块和包」
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus</title>
    <link href="http://yoursite.com/2019/05/01/Prometheus/01.pro/"/>
    <id>http://yoursite.com/2019/05/01/Prometheus/01.pro/</id>
    <published>2019-05-01T10:11:07.000Z</published>
    <updated>2019-05-23T09:17:15.565Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Prometheus" scheme="http://yoursite.com/categories/Prometheus/"/>
    
    
      <category term="Prometheus" scheme="http://yoursite.com/tags/Prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Python 的面向对象</title>
    <link href="http://yoursite.com/2019/05/01/Python/02.Oop/01.Python%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/05/01/Python/02.Oop/01.Python的面向对象/</id>
    <published>2019-05-01T10:11:07.000Z</published>
    <updated>2019-05-24T08:07:25.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python的面向对象"><a href="#Python的面向对象" class="headerlink" title="Python的面向对象"></a>Python的面向对象</h1><pre><code>- OO- 类的基本实现- 类和对象的成员分析- self</code></pre><h2 id="面向对象概述（ObjectOriented，OO）"><a href="#面向对象概述（ObjectOriented，OO）" class="headerlink" title="面向对象概述（ObjectOriented，OO）"></a>面向对象概述（ObjectOriented，OO）</h2><ul><li><p>OOP思想<br>接触到任意一个任务，首先想到的是任务这个世界的构成，是由模型构成的<br>OO:面向对象<br>OOA：面向对象的分析<br>OOD：面向对象的设计<br>OOI：xxx的实现<br>OOP：xxx的编程<br>OOA-&gt;OOD-&gt;OOI: 面向对象的实现过程</p></li><li><p>类和对象的概念<br>类：抽象名词，代表一个集合，共性的事物<br>对象：具象的事物，单个个体<br>类跟对象的关系<br>一个具象，代表一类事物的某一个个体<br>一个是抽象，代表的是一大类事物</p></li><li><p>类中的内容，应该具有两个内容<br>表明事物的特征，叫做属性(变量)<br>表明事物功能或动作， 称为成员方法(函数)</p></li></ul><h2 id="类的基本实现"><a href="#类的基本实现" class="headerlink" title="类的基本实现"></a>类的基本实现</h2><ul><li><p>类的命名<br>遵守变量命名的规范<br>大驼峰（由一个或者多个单词构成，每个单词首字母大写，单词跟单词直接相连）<br>尽量避开跟系统命名相似的命名</p></li><li><p>你如何声明一个类<br>class关键字<br>类由属性和方法构成，其他不允许出现<br>成员属性定义可以直接使用变量赋值，如果没有值，许使用None</p></li><li><p>实例化类</p><pre><code>变量 = 类名() #实例化了一个对象</code></pre></li><li><p>访问对象成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj.成员属性名称  </span><br><span class="line">obj.成员方法</span><br></pre></td></tr></table></figure></li><li><p>对象的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># dict前后各有两个下划线</span><br><span class="line">obj.__dict__</span><br></pre></td></tr></table></figure></li><li><p>类的所有成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># dict前后各有两个下划线</span><br><span class="line">class_name.__dict__</span><br></pre></td></tr></table></figure></li></ul><h2 id="类和对象的成员分析"><a href="#类和对象的成员分析" class="headerlink" title="类和对象的成员分析"></a>类和对象的成员分析</h2><ul><li>类和对象都可以存储成员，成员可以归类所有，也可以归对象所有</li><li>类存储成员时使用的是与类关联的一个对象</li><li>独享存储成员是是存储在当前对象中</li><li>对象访问一个成员时，如果对象中没有该成员，尝试访问类中的同名成员， 如果对象中有此成员，一定使用对象中的成员</li><li><p>创建对象的时候，类中的成员不会放入对象当中，而是得到一个空对象，没有成员 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    name = &quot;kobe&quot;</span><br><span class="line">    number = 24</span><br><span class="line"></span><br><span class="line"># A 称为类实例    </span><br><span class="line">print (&quot;A&quot;,A.name,id(A.name))</span><br><span class="line">print (&quot;A&quot;,A.number,id(A.number))</span><br><span class="line">print(&quot;*&quot; * 20)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print (&quot;a&quot;,a.name,id(a.name))</span><br><span class="line">print (&quot;a&quot;,a.number,id(a.number))</span><br><span class="line"></span><br><span class="line"># 查看所有的属性</span><br><span class="line">print (&quot;A&quot;,A.__dict__)</span><br><span class="line">print (&quot;a&quot;,a.__dict__)  #&#123;&#125; 空  </span><br><span class="line"></span><br><span class="line"># 在不对对象的实例属性赋值的前提下，类实例的属性和其对象实例的属性指向同一个变量</span><br><span class="line"></span><br><span class="line">A kobe 140589649254976</span><br><span class="line">A 24 9306720</span><br><span class="line">********************</span><br><span class="line">a kobe 140589649254976</span><br><span class="line">a 24 9306720</span><br><span class="line">A &#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;name&apos;: &apos;kobe&apos;, &apos;number&apos;: 24, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;A&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;A&apos; objects&gt;, &apos;__doc__&apos;: None&#125;</span><br><span class="line">a &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过对象对类中成员重新赋值或者通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">案例:</span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    name = &quot;kobe&quot;</span><br><span class="line">    number = 24</span><br><span class="line">    </span><br><span class="line"># A 称为类实例    </span><br><span class="line">print (&quot;A&quot;,A.name,id(A.name))</span><br><span class="line">print (&quot;A&quot;,A.number,id(A.number))</span><br><span class="line">print(&quot;*&quot; * 20)</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print (&quot;a&quot;,a.name,id(a.name))</span><br><span class="line">print (&quot;a&quot;,a.number,id(a.number))</span><br><span class="line"></span><br><span class="line">## 查看所有的属性</span><br><span class="line">print (&quot;A&quot;,A.__dict__)</span><br><span class="line">print (&quot;a&quot;,a.__dict__)  #&#123;&#125;   </span><br><span class="line">print(&quot;*&quot; * 20)</span><br><span class="line"></span><br><span class="line">#赋值</span><br><span class="line">a.name  =  &quot;Owen&quot;</span><br><span class="line">a.number = 11</span><br><span class="line"></span><br><span class="line">print (&quot;a&quot;,a.name,id(a.name))</span><br><span class="line">print (&quot;a&quot;,a.number,id(a.number))</span><br><span class="line">print (&quot;a&quot;,a.__dict__)</span><br><span class="line"></span><br><span class="line">#通过对象对类中成员重新赋值或者通过对象添加成员时，对应成员会保存在对象中，而不会修改类成员</span><br><span class="line"></span><br><span class="line">A kobe 140589649254976</span><br><span class="line">A 24 9306720</span><br><span class="line">********************</span><br><span class="line">a kobe 140589649254976</span><br><span class="line">a 24 9306720</span><br><span class="line">A &#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;name&apos;: &apos;kobe&apos;, &apos;number&apos;: 24, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;A&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;A&apos; objects&gt;, &apos;__doc__&apos;: None&#125;</span><br><span class="line">a &#123;&#125;</span><br><span class="line">********************</span><br><span class="line">a Owen 140589649496696</span><br><span class="line">a 11 9306304</span><br><span class="line">a &#123;&apos;name&apos;: &apos;Owen&apos;, &apos;number&apos;: 11&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="self"><a href="#self" class="headerlink" title="self"></a>self</h2><ul><li>self在对象的方法中表示当前对象本身，如果通过对象调用一个方法，那么该对象会自动传入到当前方法的第一个参数中 </li><li><p>self并不是关键字，只是一个用于接受对象的普通参数，理论上可以用任何一个普通变量名代替</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">案例:</span><br><span class="line">class Student():</span><br><span class="line">    name = &quot;dana&quot;</span><br><span class="line">    age = 18</span><br><span class="line">    </span><br><span class="line">    # 注意say的写法，参数有一个self</span><br><span class="line">    def say(self):</span><br><span class="line">        self.age = 200</span><br><span class="line">        print(&quot;My age is &#123;0&#125;&quot;.format(self.age))</span><br><span class="line">    # 任何一个普通变量名代替self    </span><br><span class="line">    def sayAgain(s):</span><br><span class="line">        print(&quot;My age is &#123;0&#125;&quot;.format(s.age))</span><br><span class="line">          </span><br><span class="line">yueyue = Student()</span><br><span class="line">yueyue.say()</span><br><span class="line">yueyue.sayAgain()</span><br><span class="line"></span><br><span class="line">My age is 200</span><br><span class="line">My age is 200</span><br></pre></td></tr></table></figure></li><li><p>方法中有self形参的方法是非绑定类的方法，可以通过对象访问； 没有self的是绑定类的方法，只能通过类访问</p></li><li><p>类方法中需要访问当前类的成员，可以通过 <strong>class</strong>成员名来访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Teacher():</span><br><span class="line">    name = &quot;dana&quot;</span><br><span class="line">    age = 19</span><br><span class="line">    </span><br><span class="line">    def say(self):</span><br><span class="line">        self.name = &quot;yaona&quot;</span><br><span class="line">        self.age = 17</span><br><span class="line">        print(&quot;My name is &#123;0&#125;&quot;.format(self.name))</span><br><span class="line">        # 调用类的成员变量需要用 __class__</span><br><span class="line">        print(&quot;My age is &#123;0&#125;&quot;.format(__class__.age))</span><br><span class="line">    def sayAgain():</span><br><span class="line">        print(__class__.name)</span><br><span class="line">        print(__class__.age )</span><br><span class="line">        print(&quot;Hello, nice to see you again&quot;)</span><br><span class="line">        </span><br><span class="line">t = Teacher()</span><br><span class="line">t.say()</span><br><span class="line"></span><br><span class="line"># 调用绑定类函数使用类名</span><br><span class="line">Teacher.sayAgain()</span><br><span class="line"></span><br><span class="line"># 如果类方法中需要访问当前类的成员，可以通过 __class__成员名来访问</span><br><span class="line"></span><br><span class="line">My name is yaona</span><br><span class="line">My age is 19</span><br><span class="line">dana</span><br><span class="line">19</span><br><span class="line">Hello, nice to see you again</span><br></pre></td></tr></table></figure></li><li><p>关于self的案例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 案例:</span><br><span class="line">class A():</span><br><span class="line">    name = &quot; liuying&quot;</span><br><span class="line">    age = 18</span><br><span class="line">    </span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = &quot;aaaa&quot;</span><br><span class="line">        self.age = 200</span><br><span class="line">        </span><br><span class="line">    def say(self):</span><br><span class="line">        print(self.name)</span><br><span class="line">        print(self.age)</span><br><span class="line">        </span><br><span class="line">class B():</span><br><span class="line">    name = &quot;bbbb&quot;</span><br><span class="line">    age = 90</span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"># 此时，系统会默认把对象a作为第一个参数传入函数</span><br><span class="line">a.say()</span><br><span class="line">   </span><br><span class="line">A.say()    #错误，类实例不会自动传入第一个参数，需要手动传入一个</span><br><span class="line"># 此时，self被a替换</span><br><span class="line">A.say(a)</span><br><span class="line"># 同样可以把A作为参数传入</span><br><span class="line">A.say(A)</span><br><span class="line"></span><br><span class="line"># 此时，传入的是类实例B，因为B具有name和age属性，所以不会报错</span><br><span class="line">A.say(B)</span><br><span class="line"></span><br><span class="line"># 以上代码，利用了鸭子模型</span><br><span class="line"></span><br><span class="line">aaaa</span><br><span class="line">200</span><br><span class="line">aaaa</span><br><span class="line">200</span><br><span class="line">liuying</span><br><span class="line">18</span><br><span class="line">bbbb</span><br><span class="line">90</span><br></pre></td></tr></table></figure></li></ul><h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><pre><code>- 封装- 继承- 多态、Mixin- 类的相关函数- 类的成员描述符- 类的内置属性- 魔法函数- 类和对象的三种方法- 抽象类- 自定义类</code></pre><ul><li>面向对象的三大特性：封装、继承、多态</li></ul><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><ul><li>将属性和方法封装到一个抽象的类中</li><li><p>封装的三个级别：<br>公开，public<br>受保护的，protected<br>私有的，private<br>public，private，protected不是关键字</p></li><li><p>判别对象的位置<br>对象内部<br>对象外部<br>子类中</p></li><li><p><a href="http://blog.csdn.net/handsomekang/article/details/40303207" target="_blank" rel="noopener">python中下划线使用</a></p></li><li><p>私有<br>私有成员是最高级别的封装，只能在当前类或对象中访问<br>在成员前面添加两个两个下划线即可: __age<br>Python的私有不是真私有，是一种成为name mangling的改名策略<br>可以使用:对象._classname_attributename访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 案例:</span><br><span class="line"></span><br><span class="line"># __age是私有变量,不能直接访问。</span><br><span class="line">print(p.__age)  #注意报错信息</span><br><span class="line">        </span><br><span class="line"># name mangling技术     </span><br><span class="line">print(Person.__dict__)</span><br><span class="line">p._Person__age = 19</span><br><span class="line">print(p._Person__age)</span><br><span class="line">        </span><br><span class="line">&#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;name&apos;: &apos;liuying&apos;, &apos;_Person__age&apos;: 18, &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Person&apos; objects&gt;, &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Person&apos; objects&gt;, &apos;__doc__&apos;: None&#125;</span><br><span class="line">19</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>受保护的封装  protected<br>受保护的封装是将对象成员进行一定级别的封装，然后，在类中或者子类中都可以进行访问，但是在外部不可以<br>封装方法： 在成员名称前添加一个下划线即可<br>name mangling的改名策略<br>可以使用:对象._classname_attributename访问</p></li><li><p>公开的，公共的 public<br>公共的封装实际对成员没有任何操作，任何地方都可以访问  </p></li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><ul><li>继承就是一个类可以获得另外一个类中的成员属性和成员方法</li><li><p>作用： 减少代码，增加代码的复用功能， 同时可以设置类与类直接的关系</p></li><li><p>继承与被继承的概念：<br>被继承的类叫父类，也叫基类，也叫超类<br>用于继承的类，叫子类，也叫派生类<br>继承与被继承一定存在一个 is-a 关系</p></li><li><p>继承的语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#父类写在括号内</span><br><span class="line">class Teacher(Person):</span><br></pre></td></tr></table></figure></li><li><p>继承的特征<br>所有的类都继承自object类，即所有的类都是object类的子类<br>子类一旦继承父类，则可以使用父类中除私有成员外的所有内容<br>子类继承父类后并没有将父类成员完全赋值到子类中，而是通过引用关系访问调用<br>子类中可以定义独有的成员属性和方法<br>子类中定义的成员和父类成员如果相同，则优先使用子类成员<br>子类如果想扩充父类的方法，可以在定义新方法的同时访问父类成员来进行代码重用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[父类名.父类成员]的格式来调用父类成员</span><br><span class="line">super().父类成员的格式来调用</span><br></pre></td></tr></table></figure></li><li><p>子类扩充父类功能的案例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 人由工作的函数， 老师也由工作的函数，但老师的工作需要讲课</span><br><span class="line">class Person():</span><br><span class="line">    name = &quot;NoName&quot;</span><br><span class="line">    age = 18</span><br><span class="line">    __score = 0 # 考试成绩是秘密，只要自己知道</span><br><span class="line">    _petname = &quot;sec&quot; #小名，是保护的，子类可以用，但不能公用</span><br><span class="line">    def sleep(self):</span><br><span class="line">        print(&quot;Sleeping ... ...&quot;)</span><br><span class="line">    def work(self):</span><br><span class="line">        print(&quot;make some money&quot;)</span><br><span class="line">        </span><br><span class="line">#父类写在括号内</span><br><span class="line">class Teacher(Person):</span><br><span class="line">    teacher_id = &quot;9527&quot;</span><br><span class="line">    name = &quot;DaNa&quot;</span><br><span class="line">    def make_test(self):</span><br><span class="line">        print(&quot;attention&quot;)</span><br><span class="line">        </span><br><span class="line">    def work(self):</span><br><span class="line">        # 扩充父类的功能只需要调用父类相应的函数</span><br><span class="line">        #Person.work(self)</span><br><span class="line">        # 扩充父类的另一种方法</span><br><span class="line">        # super代表得到父类</span><br><span class="line">        super().work()</span><br><span class="line">        self.make_test()</span><br><span class="line">        </span><br><span class="line">t = Teacher()</span><br><span class="line">t.work()</span><br><span class="line"></span><br><span class="line">make some money</span><br><span class="line">attention</span><br></pre></td></tr></table></figure></li><li><p>继承变量函数的查找顺序问题<br>优先查找自己的变量<br>没有则查找父类<br>构造函数如果本类中没有定义，则自动查找调用父类构造函数<br>如果本类有定义，则不在继续向上查找</p></li><li><p>构造函数<br>是一类特殊的函数，在类进行实例化之前进行调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">案例：</span><br><span class="line">class Dog():</span><br><span class="line"># __init__就是构造函数</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;I am init in dog&quot;)</span><br><span class="line"></span><br><span class="line"># 实例话的时候，括号内的参数需要跟构造函数参数匹配</span><br><span class="line">kaka = Dog()</span><br><span class="line">    </span><br><span class="line">I am init in dog</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>构造函数查找顺序<br>如果定义了构造函数，则实例化时使用构造函数，不查找父类构造函数<br>如果没定义，则自动查找父类构造函数<br>如果子类没定义，父类的构造函数带参数，则构造对象时的参数应该按父类参数构造 </p></li><li><p>super<br>super不是关键字， 而是一个类<br>super的作用是获取MRO（MethodResolustionOrder）列表中的第一个类<br>super于父类直接没任何实质性关系，但通过super可以调用到父类<br>super使用的两个方法,参见在构造函数中调用父类的构造函数</p></li><li><p>单继承和多继承<br>单继承：每个类只能继承一个类<br>多继承，每个类允许继承多个类</p></li><li><p>单继承和多继承的优缺点<br>单继承：<br>优点：传承有序逻辑清晰语法简单隐患少呀<br>缺点：功能不能无限扩展，只能在当前唯一的继承链中扩展<br>多继承：<br>优点：类的功能扩展方便<br>缺点：继承关系混乱</p></li><li><p>菱形继承/钻石继承问题<br>多个子类继承自同一个父类，这些子类由被同一个类继承，于是继承关系图形成一个菱形图谱<br><a href="https://www.cnblogs.com/whatisfantasy/p/6046991.html" target="_blank" rel="noopener">MRO</a><br>关于多继承的MRO<br>MRO就是多继承中，用于保存继承顺序的一个列表<br>python本身采用C3算法来多多继承的菱形继承进行计算的结果</p></li><li><p>MRO列表的计算原则：<br>子类永远在父类前面<br>如果多个父类，则根据继承语法中括号内类的书写顺序存放<br>如果多个类继承了同一个父类，孙子类中只会选取继承语法括号中第一个父类的父类</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">案例：扩展构造函数</span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;A&quot;)</span><br><span class="line"></span><br><span class="line">class B(A):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        print(&quot;B&quot;)</span><br><span class="line">        print(name)</span><br><span class="line">        </span><br><span class="line">class C(B):</span><br><span class="line">    # c中想扩展B的构造函数，</span><br><span class="line">    # 即调用B的构造函数后在添加一些功能</span><br><span class="line">    # 由两种方法实现</span><br><span class="line">    </span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    # 第一种是通过父类名调用</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        # 首先调用父类构造函数</span><br><span class="line">        B.__init__(self, name)</span><br><span class="line">        # 其次，再增加自己的功能</span><br><span class="line">        print(&quot;这是C中附加的功能&quot;)</span><br><span class="line">    &apos;&apos;&apos;  </span><br><span class="line">        </span><br><span class="line">    # 第二种，使用super调用</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        # 首先调用父类构造函数</span><br><span class="line">        super(C, self).__init__(name)</span><br><span class="line">        # 其次，再增加自己的功能</span><br><span class="line">        print(&quot;这是C中附加的功能&quot;)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"># 此时，首先查找C的构造函数</span><br><span class="line"># 如果没有，则向上按照MRO顺序查找父类的构造函数，知道找到为止</span><br><span class="line"># 此时，会出现参数结构不对应错误</span><br><span class="line">c = C(&quot;我是C&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">B</span><br><span class="line">我是C</span><br><span class="line">这是C中附加的功能</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul><li>不同的子类对象调用相同的父类方法，产生不同的执行结果</li><li>以继承和重写父类方法为前提</li><li>多态性：同一种调用方式，产生不同的执行效果</li><li><a href="https://www.cnblogs.com/luchuangao/p/6739557.html" target="_blank" rel="noopener">多态和多态性</a></li><li>Mixin设计模式<br>主要采用多继承方式对类的功能进行扩展<br><a href="https://www.zhihu.com/question/20778853" target="_blank" rel="noopener">Mixin概念</a><br><a href="http://blog.csdn.net/robinjwong/article/details/48375833" target="_blank" rel="noopener">MRO and Mixin</a><br><a href="https://www.cnblogs.com/xybaby/p/6484262.html" target="_blank" rel="noopener">Mixin模式</a><br><a href="http://runforever.github.io/2014-07-19/2014-07-19-python-mixin%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">Mixin MRO</a><br><a href="http://xiaocong.github.io/blog/2012/06/13/python-mixin-and-mro/" target="_blank" rel="noopener">MRO</a>    </li><li>我们使用多继承语法来实现Minxin</li><li>使用Mixin实现多继承的时候非常小心<br>首先他必须表示某一单一功能，而不是某个物品<br>职责必须单一，如果由多个功能，则写多个Mixin<br>Mixin不能依赖于子类的实现<br>子类及时没有继承这个Mixin类， 也能照样工作，只是缺少了某个功能</li><li>优点<br>使用Mixin可以在不对类进行任何修改的情况下，扩充功能<br>可以方便的组织和维护不同功能组件的划分<br>可以根据需要任意调整功能类的组合<br>可以避免创建很多新的类，导致类的继承混乱</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># Mixin案例</span><br><span class="line"></span><br><span class="line">class Person():</span><br><span class="line">                name = &quot;liuying&quot;</span><br><span class="line">                age = 18</span><br><span class="line"></span><br><span class="line">                def eat(self):</span><br><span class="line">                    print(&quot;EAT.......&quot;)</span><br><span class="line">                    </span><br><span class="line">                def drink(self):</span><br><span class="line">                    print(&quot;DRINK......&quot;)</span><br><span class="line">                    </span><br><span class="line">                def sleep(self):</span><br><span class="line">                    print(&quot;SLEEP.....&quot;)</span><br><span class="line">                </span><br><span class="line">class Teacher(Person):</span><br><span class="line">                def work(self):</span><br><span class="line">                    print(&quot;Work&quot;)</span><br><span class="line"></span><br><span class="line">class Student(Person):</span><br><span class="line">                def study(self):</span><br><span class="line">                    print(&quot;Study&quot;)</span><br><span class="line">                    </span><br><span class="line"></span><br><span class="line">class Tutor(Teacher, Student):</span><br><span class="line">                pass</span><br><span class="line"></span><br><span class="line">t = Tutor()</span><br><span class="line">             </span><br><span class="line">print(Tutor.__mro__)</span><br><span class="line">print(t.__dict__)</span><br><span class="line">print(Tutor.__dict__)</span><br><span class="line"></span><br><span class="line">print(&quot;*&quot;*20)</span><br><span class="line">class TeacherMixin():</span><br><span class="line">                def work(self):</span><br><span class="line">                    print(&quot;Work&quot;)</span><br><span class="line"></span><br><span class="line">class StudentMixin():</span><br><span class="line">                def study(self):</span><br><span class="line">                    print(&quot;Study&quot;)</span><br><span class="line">                    </span><br><span class="line">class TutorM(Person, TeacherMixin, StudentMixin):</span><br><span class="line">                pass</span><br><span class="line"></span><br><span class="line">tt = TutorM()</span><br><span class="line">print(TutorM.__mro__)</span><br><span class="line">print(tt.__dict__)</span><br><span class="line">print(TutorM.__dict__)</span><br></pre></td></tr></table></figure><h2 id="类相关函数"><a href="#类相关函数" class="headerlink" title="类相关函数"></a>类相关函数</h2><ul><li>issubclass:检测一个类是否是另一个类的子类</li><li>isinstance:检测一个对象是否是一个类的实例</li><li>hasattr:检测一个对象是否由成员xxx</li><li>getattr: get attribute</li><li>setattr: set attribute</li><li>delattr: delete attribute</li><li>dir: 获取对象的成员列表</li></ul><h2 id="类的成员描述符（属性）"><a href="#类的成员描述符（属性）" class="headerlink" title="类的成员描述符（属性）"></a>类的成员描述符（属性）</h2><ul><li><p>类的成员描述符是为了在类中对类的成员属性进行相关操作而创建的一种方式<br>get： 获取属性的操作<br>set：修改或者添加属性操作<br>delete： 删除属性的操作</p></li><li><p>如果想使用类的成员描述符，大概有三种方法<br>使用类实现描述器<br>使用属性修饰符<br>使用property函数:property(fget, fset, fdel, doc) </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># peroperty案例</span><br><span class="line"></span><br><span class="line"># 定义一个Person类，具有name，age属性</span><br><span class="line"># 对于任意输入的姓名，我们希望都用大写方式保存</span><br><span class="line"># 年龄，我们希望内部统一用整数保存</span><br><span class="line"># x = property(fget, fset, fdel, doc)</span><br><span class="line">class Person():</span><br><span class="line"></span><br><span class="line">    # 函数的名称可以任意</span><br><span class="line">    def fget(self):</span><br><span class="line">        return self._name * 2</span><br><span class="line">    </span><br><span class="line">    def fset(self, name):</span><br><span class="line">        # 所有输入的姓名以大写形式保存</span><br><span class="line">        self._name = name.upper()</span><br><span class="line">        </span><br><span class="line">    def fdel(self):</span><br><span class="line">        self._name = &quot;NoName&quot;</span><br><span class="line">    </span><br><span class="line">    name2 = property(fget, fset, fdel, &quot;对name进行下下操作啦&quot;)</span><br></pre></td></tr></table></figure></li><li><p>无论哪种修饰符都是为了对成员属性进行相应的控制<br>类的方式： 适合多个类中的多个属性共用用一个描述符<br>property：使用当前类中使用，可以控制一个类中多个属性<br>属性修饰符： 使用于当前类中使用，控制一个类中的一个属性</p></li></ul><h2 id="类的内置属性"><a href="#类的内置属性" class="headerlink" title="类的内置属性"></a>类的内置属性</h2><ul><li><p><strong>dict</strong><br>以字典的方式显示类的成员组成</p></li><li><p><strong>doc</strong>:<br>获取类的文档信息</p></li><li><p><strong>name</strong><br>获取类的名称，如果在模块中使用，获取模块的名称</p></li><li><p><strong>bases</strong><br>获取某个类的所有父类，以元组的方式显示</p></li></ul><h2 id="类的常用魔术方法"><a href="#类的常用魔术方法" class="headerlink" title="类的常用魔术方法"></a>类的常用魔术方法</h2><ul><li>魔术方法就是不需要人为调用的方法，基本是在特定的时刻自动触发</li><li>魔术方法的统一的特征，方法名被前后各两个下滑线包裹</li><li>操作类<br><code>__init__</code>: 构造函数<br><code>__new__</code>: 对象实例化方法，此函数较特殊，一般不需要使用<br><code>__call__</code>: 对象当函数使用的时候触发<br><code>__str__</code>: 当对象被当做字符串使用的时候调用<br><code>__repr__</code>: 返回字符串 </li></ul><ul><li>描述符相关<br><code>__set__</code><br><code>__get__</code><br><code>__delete__</code></li></ul><ul><li><p>属性操作相关<br><code>__getattr__</code>: 访问一个不存在的属性时触发<br><code>__setattr__</code>: 对成员属性进行设置的时候触发<br>参数：<br>self用来获取当前对象<br>被设置的属性名称，以字符串形式出现<br>需要对属性名称设置的值<br>作用：进行属性设置的时候进行验证或者修改<br>注意： 在该方法中不能对属性直接进行赋值操作，否则死循环 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># __setattr__案例</span><br><span class="line"></span><br><span class="line">class Person():</span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    def __setattr__(self, name, value):</span><br><span class="line">        print(&quot;设置属性： &#123;0&#125;&quot;.format(name))</span><br><span class="line">        # 下面语句会导致问题，死循环</span><br><span class="line">        #self.name = value</span><br><span class="line">        </span><br><span class="line">        # 此种情况，为了避免死循环，规定统一调用父类魔法函数</span><br><span class="line">        super().__setattr__(name, value)</span><br><span class="line">        </span><br><span class="line">p = Person()</span><br><span class="line">print(p.__dict__)</span><br><span class="line">p.age = 18</span><br></pre></td></tr></table></figure></li><li><p>运算分类相关魔术方法<br><code>__gt__</code>: 进行大于判断的时候触发的函数<br>参数：<br>self<br>第二个参数是第二个对象<br>返回值:可以是任意值，推荐返回布尔值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># __gt__</span><br><span class="line"></span><br><span class="line">class Student():</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self._name = name</span><br><span class="line">    </span><br><span class="line">    def __gt__(self, obj):</span><br><span class="line">        print(&quot;哈哈， &#123;0&#125; 会比 &#123;1&#125; 大吗？&quot;.format(self, obj))</span><br><span class="line">        return self._name &gt; obj._name</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">stu1 = Student(&quot;one&quot;)</span><br><span class="line">stu2 = Student(&quot;two&quot;)</span><br><span class="line"></span><br><span class="line">print(stu1 &gt; stu2)</span><br><span class="line"></span><br><span class="line">哈哈， &lt;__main__.Student object at 0x7f4aac6b3b00&gt; 会比 &lt;__main__.Student object at 0x7f4aac6b3ac8&gt; 大吗？</span><br><span class="line">False</span><br></pre></td></tr></table></figure></li></ul><h2 id="类和对象的三种方法"><a href="#类和对象的三种方法" class="headerlink" title="类和对象的三种方法"></a>类和对象的三种方法</h2><ul><li><p>实例方法<br>需要实例化对象才能使用的方法，使用过程中可能需要截止对象的其他对象的方法完成</p></li><li><p>静态方法<br>不需要实例化，通过类直接访问</p></li><li><p>类方法<br>不需要实例化</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 三种方法的案例</span><br><span class="line"></span><br><span class="line">class Person:</span><br><span class="line">    # 实例方法</span><br><span class="line">    def eat(self):</span><br><span class="line">        print(self)</span><br><span class="line">        print(&quot;Eating.....&quot;)</span><br><span class="line">    </span><br><span class="line">    #类方法</span><br><span class="line">    # 类方法的第一个参数，一般命名为cls，区别于self</span><br><span class="line">    @classmethod</span><br><span class="line">    def play(cls):</span><br><span class="line">        print(cls)</span><br><span class="line">        print(&quot;Playing.....&quot;)</span><br><span class="line">        </span><br><span class="line">    # 静态方法</span><br><span class="line">    # 不需要用第一个参数表示自身或者类</span><br><span class="line">    @staticmethod</span><br><span class="line">    def say():</span><br><span class="line">        print(&quot;Saying....&quot;)</span><br><span class="line">        </span><br><span class="line">yueyue = Person()</span><br><span class="line"></span><br><span class="line"># 实例方法</span><br><span class="line">yueyue.eat()</span><br><span class="line"># 类方法</span><br><span class="line">Person.play()</span><br><span class="line">yueyue.play()</span><br><span class="line">#静态方法</span><br><span class="line">Person.say()</span><br><span class="line">yueyue.say()</span><br></pre></td></tr></table></figure><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>抽象方法：没有具体实现内容的方法成为抽象方法</li><li>抽象方法的主要意义是规范了子类的行为和接口</li><li><p>抽象类的使用需要借助abc模块</p><pre><code>import abc</code></pre></li><li><p>抽象类：包含抽象方法的类叫抽象类，通常成为ABC类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 抽象类的实现</span><br><span class="line"></span><br><span class="line">import abc</span><br><span class="line"></span><br><span class="line">#声明一个类并且指定当前类的元类</span><br><span class="line">class Human(metaclass=abc.ABCMeta):</span><br><span class="line"></span><br><span class="line">    # 定义一个抽象的方法</span><br><span class="line">    @abc.abstractmethod</span><br><span class="line">    def smoking(self):</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    # 定义类抽象方法</span><br><span class="line">    @abc.abstractclassmethod</span><br><span class="line">    def drink():</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    # 定义静态抽象方法</span><br><span class="line">    @abc.abstractstaticmethod</span><br><span class="line">    def play():</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    # 定义一个具体方法</span><br><span class="line">    def sleep(self):</span><br><span class="line">        print(&quot;Sleeping.......&quot;)</span><br></pre></td></tr></table></figure></li><li><p>抽象类的使用<br>抽象类可以包含抽象方法，也可以包含具体方法<br>抽象类中可以有方法也可以有属性<br>抽象类不允许直接实例化<br>必须继承才可以使用，且继承的子类必须实现所有继承来的抽象方法<br>假定子类没有是现实所有继承的抽象方法，则子类也不能实例化<br>抽象类的主要作用是设定类的标准，以便于开发的时候具有统一的规范</p></li></ul><h2 id="自定义类"><a href="#自定义类" class="headerlink" title="自定义类"></a>自定义类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 函数名可以当变量使用</span><br><span class="line"></span><br><span class="line">def sayHello(name):</span><br><span class="line">    print(&quot;&#123;0&#125;你好 &quot;.format(name))</span><br><span class="line">    </span><br><span class="line">sayHello(&quot;月月&quot;)</span><br><span class="line"></span><br><span class="line">B = sayHello</span><br><span class="line">B(&quot;yueyue&quot;)</span><br></pre></td></tr></table></figure><ul><li>类其实是一个类定义和各种方法的自由组合</li><li><p>可以定义类和函数，然后自己通过类直接赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 组装类 1 </span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def say(self):</span><br><span class="line">    print(&quot;Saying... ...&quot;)</span><br><span class="line">    </span><br><span class="line">#等同于    </span><br><span class="line">class B():</span><br><span class="line">    def say(self):</span><br><span class="line">        print(&quot;Saying......&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">say(9)</span><br><span class="line">A.say = say</span><br><span class="line">a = A()</span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure></li><li><p>可以借助于MethodType实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 组装类例子 2</span><br><span class="line"></span><br><span class="line"># 自己组装一个类</span><br><span class="line">from types import MethodType</span><br><span class="line"></span><br><span class="line">class A():</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">def say(self):</span><br><span class="line">    print(&quot;Saying... ...&quot;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">a = A()</span><br><span class="line"># 通过MethodType 把say组装到A  </span><br><span class="line">a.say = MethodType(say, A)</span><br><span class="line">a.say()</span><br></pre></td></tr></table></figure></li><li><p>借助于type实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 利用type造一个类</span><br><span class="line"></span><br><span class="line"># 先定义类应该具有的成员函数</span><br><span class="line">def say(self):</span><br><span class="line">    print(&quot;Saying.....&quot;)</span><br><span class="line">    </span><br><span class="line">def talk(self):</span><br><span class="line">    print(&quot;Talking .....&quot;)</span><br><span class="line">    </span><br><span class="line">#用type来创建一个类</span><br><span class="line">A = type(&quot;AName&quot;, (object, ), &#123;&quot;class_say&quot;:say, &quot;class_talk&quot;:talk&#125;)</span><br><span class="line"></span><br><span class="line"># 然后可以像正常访问一样使用类</span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line">a.class_say()</span><br><span class="line">a.class_talk()</span><br></pre></td></tr></table></figure></li><li><p>利用元类实现- MetaClass<br>元类是类<br>被用来创造别的类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 元类演示</span><br><span class="line"># 元类写法是固定的，必须继承自type</span><br><span class="line"># 元类一般命名以MetaClass结尾</span><br><span class="line"></span><br><span class="line">class TulingMetaClass(type):</span><br><span class="line">    # 注意以下写法</span><br><span class="line">    def __new__(cls, name, bases, attrs):</span><br><span class="line">        #自己的业务处理</span><br><span class="line">        print(&quot;哈哈，我是元类呀&quot;)</span><br><span class="line">        attrs[&apos;id&apos;] = &apos;000000&apos;</span><br><span class="line">        attrs[&apos;addr&apos;] = &quot;北京海淀区公主坟西翠路12号&quot;</span><br><span class="line">        return type.__new__(cls, name, bases, attrs)</span><br><span class="line">    </span><br><span class="line"># 元类定义完就可以使用，使用注意写法</span><br><span class="line">class Teacher(object, metaclass=TulingMetaClass):</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">t = Teacher()</span><br><span class="line"></span><br><span class="line">t.id</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      「面向对象」「面向对象编程」
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 的流程控制</title>
    <link href="http://yoursite.com/2019/04/27/Python/01.Basic-level/02.Python%E7%9A%84%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/27/Python/01.Basic-level/02.Python的流程控制/</id>
    <published>2019-04-27T10:11:07.000Z</published>
    <updated>2019-05-24T07:55:15.246Z</updated>
    
    <content type="html"><![CDATA[<h1 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h1><ul><li>分支结构</li><li>循环结构</li></ul><h2 id="分支结构-选择结构"><a href="#分支结构-选择结构" class="headerlink" title="分支结构/选择结构"></a>分支结构/选择结构</h2><ul><li>单项分支: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if 条件表达式：   </span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>双向分支      </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 条件表达式:</span><br><span class="line">    ...</span><br><span class="line">else:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p>多项分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if 条件表达式：</span><br><span class="line">    ...</span><br><span class="line">elif 条件表达式:</span><br><span class="line">    ... </span><br><span class="line">elif 条件表达式：</span><br><span class="line">    ...</span><br><span class="line">else:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li><li><p>巢状分支<br>巢状分支就是多个其他if…else分支的嵌套组合  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if x &lt; 5:</span><br><span class="line">    print(&apos;x真的小于5哦&apos;)</span><br><span class="line">    if y &lt; 6:</span><br><span class="line">        print(&apos;如果y &lt; 6，我会被输出&apos;)</span><br><span class="line">    elif y &gt; 6:</span><br><span class="line">        print(&apos;如果上y大于6，我会被输出&apos;)</span><br><span class="line">elif x &gt; 5:</span><br><span class="line">    print(&apos;x大于5&apos;)</span><br></pre></td></tr></table></figure></li></ul><p>注意：：在python中并没有switch…case分支。后期可以使用字典和函数的组合来代替。</p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><ul><li><p>while …: …  </p></li><li><p>while …: …     else: …   </p></li><li><p>while True: …</p></li></ul><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><ul><li>for … in 循环  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 格式1:  </span><br><span class="line">for 变量 in 序列:</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"># 格式2:</span><br><span class="line">for 变量1,变量2.. in 多层序列：</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"># 格式3：</span><br><span class="line">for 变量 in 序列：:</span><br><span class="line">    ...</span><br><span class="line">else:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></li></ul><h3 id="其他流程控制语句"><a href="#其他流程控制语句" class="headerlink" title="其他流程控制语句"></a>其他流程控制语句</h3><ul><li><p>break 破坏，结束，打破<br>作用：结束程序循环，一旦程序执行了break语句，那么当前break所在的循环就会被终止  </p></li><li><p>continue 继续<br>作用：结束本次循环，开始下一次的循环，他不会终止整个循环，仅对于循环中的某次循环有效  </p></li><li><p>pass 通过，忽略<br>作用：在程序结构中有时不需用写任何python内容，但是如果没有内容，语言结构会出现语法错误！pass可以作为语法占位符使用，pass语句没有任何意义，也不会做任何操作</p></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><h3 id="最基本的函数结构"><a href="#最基本的函数结构" class="headerlink" title="最基本的函数结构"></a>最基本的函数结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def 函数名()：</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">调用函数： 函数名()</span><br></pre></td></tr></table></figure><h3 id="具有参数的函数结构"><a href="#具有参数的函数结构" class="headerlink" title="具有参数的函数结构"></a>具有参数的函数结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def 函数名(参数名，参数名...):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">调用函数: 函数名(值,值...)</span><br></pre></td></tr></table></figure><p>声明函数的()中的参数称之为形参，形参表示形式上的参数<br>调用函数的()中的参数称之为实参，实参表示真实的值<br>注意:实参传递值给形参的过程，本质上就是普通的变量赋值  </p><h3 id="具有默认值参数的函数"><a href="#具有默认值参数的函数" class="headerlink" title="具有默认值参数的函数"></a>具有默认值参数的函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def 函数名(形参名 = 默认值,形参名 = 默认值...):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">调用函数1：函数名()</span><br><span class="line">调用函数2:函数名(实参,实参...)</span><br></pre></td></tr></table></figure><h3 id="函数文档"><a href="#函数文档" class="headerlink" title="函数文档"></a>函数文档</h3><ul><li><p>查看函数文档：<br>使用help(函数名)，可以查看函数文档信息，查看信息时信息会换行<br>使用函数名.<strong>doc</strong>的方式查看，查看信息时信息不会换行，会显示\n  </p></li><li><p>自定义函数文档：<br>在函数内部开始的第一行使用字符串定义文字内容即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def 函数名()：</span><br><span class="line"></span><br><span class="line">    &apos;此处书写函数文档信息，单引号中使用\n换行&apos;</span><br><span class="line"></span><br><span class="line">    函数中的其他代码...</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">def 函数名():</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line">    此处书写函数文档信息</span><br><span class="line">    此处书写函数文档信息</span><br><span class="line">    &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    函数中的其他代码...</span><br></pre></td></tr></table></figure></li></ul><h3 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a>lambda表达式</h3><ul><li><p>lambda不是一种函数结构，只是一种表达式而且不需要函数名。（匿名函数）<br>格式：</p><p>  变量 = lambda 形参,形参…： 功能代码</p></li><li><p>案例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#传入两个参数返回这两个数的乘积  </span><br><span class="line">lambda x,y :x*y </span><br><span class="line"></span><br><span class="line">#根据条件表达式的真假返回值1还是值2  </span><br><span class="line">lambda x： 值1  if 条件表达式 else 值2</span><br></pre></td></tr></table></figure></li><li><p>优点：<br>lambda表达式书写简单，不用def关键字，可惜要用lambda<br>lambda表达式不需要函数名，省得命名头疼<br>看起来比较装逼！  </p></li><li><p>缺点：<br>lambda表达式功能受限，无法使用循环以及部分流程控制相关语句<br>lambda表达式不适合较为复杂的程序。  </p></li></ul><h3 id="收集参数"><a href="#收集参数" class="headerlink" title="收集参数"></a>收集参数</h3><ul><li>收集参数1 (专用于收集非关键字参数)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 「*」 形参格式的收集参数会收集到调用函数时传入的所有没有关键字的形参  </span><br><span class="line">def 函数名(*形参名)：</span><br><span class="line">    ...    </span><br><span class="line"></span><br><span class="line">调用函数： 函数名(实参,实参....)</span><br></pre></td></tr></table></figure></li></ul><p>注意:<br>1) 收集参数收集到的最终数据是由所有非关键字实参组成的元组。<br>2) 收集参数和普通的参数（关键字参数）可以共存</p><ul><li>收集参数2 (专门用于收集关键字参数)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#「**」 形参格式会收集调用函数时传入函数的所有关键字参数  </span><br><span class="line">def 函数名(**args):</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">调用函数：函数名(形参名 = 值,形参名=值...)</span><br></pre></td></tr></table></figure></li></ul><p>-注意:<br>1) 收集的所有关键字参数最终组成的数据为字典类型<br>2) 关键字参数收集的方式可以和普通形参共存，但是必须在最后  </p><ul><li>注意：<br>普通形参，非关键字收集形参和关键字收集形参具有顺序关系<br>普通形参放最前面<br>非关键字形参放中间<br>关键字形参放最后<br>所有收集参数只能够收集没有形参接受的实参 </li></ul><h2 id="函数的变量作用域"><a href="#函数的变量作用域" class="headerlink" title="函数的变量作用域"></a>函数的变量作用域</h2><h3 id="全局变量和局部变量"><a href="#全局变量和局部变量" class="headerlink" title="全局变量和局部变量"></a>全局变量和局部变量</h3><ul><li>全局变量: 在函数外部声明的变量就是全局变量   </li><li>局部变量: 在函数内部声明的变量就是局部变量  </li></ul><h3 id="局部变量和全局变量的作用范围"><a href="#局部变量和全局变量的作用范围" class="headerlink" title="局部变量和全局变量的作用范围"></a>局部变量和全局变量的作用范围</h3><ul><li>全局变量在全局范围内可以使用  </li><li>全局变量在局部范围内可以使用(访问)  </li><li>局部变量在局部范围内可以使用  </li><li>局部变量在全局范围内无法正常使用  </li></ul><h3 id="global-关键字"><a href="#global-关键字" class="headerlink" title="global 关键字"></a>global 关键字</h3><ul><li>global 关键字的作用是提升局部变量为全局变量<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def 函数名():</span><br><span class="line">...</span><br><span class="line">    #提升局部变量为全局变量</span><br><span class="line">    global 局部变量</span><br></pre></td></tr></table></figure></li></ul><h3 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h3><ul><li><p>在函数内部声明的函数就是内部函数  </p></li><li><p>特征:<br>内部函数在函数内部可以访问<br>内部函数的调用必须在定义内部函数之后<br>内部函数不可以在函数外部调用<br>本质上内部函数等同于内部变量  </p></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li><p>闭包<br>将函数内部的局部变量或者内部函数,弄到函数外,并且可以正常使用的特殊方法.突破了局部作用域的限制!<br>注意:闭包少用!</p></li><li><p>闭包格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def 外层函数()：</span><br><span class="line">局部变量</span><br><span class="line">局部变量</span><br><span class="line"></span><br><span class="line">   def 内部函数()：</span><br><span class="line">pass</span><br><span class="line">return (局部变量，局部变量...内部函数,内部函数...)</span><br></pre></td></tr></table></figure></li></ul><h3 id="nonlocal关键字"><a href="#nonlocal关键字" class="headerlink" title="nonlocal关键字"></a>nonlocal关键字</h3><ul><li>声明当前变量不是当前函数内部的变量，他有可能是当前函数的外部变量（不是全局变量）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def 外部函数()</span><br><span class="line"></span><br><span class="line">    局部变量</span><br><span class="line"></span><br><span class="line">    def 内部函数（）:</span><br><span class="line"></span><br><span class="line">        nonlocal 变量名#声明当前变量不是内部函数中的变量</span><br><span class="line"></span><br><span class="line">        其他代码...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return 代码</span><br></pre></td></tr></table></figure></li></ul><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><ul><li>在函数中调用当前函数本身的函数就是递归函数。<br>示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def recursion(n):</span><br><span class="line">    #输出当前的n的值</span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line">    #判断n的值是否&gt;0,决定下一步操作</span><br><span class="line">    if n&gt;0:        #n&gt;0 在此调用当前函数digui，将n - 1放进去</span><br><span class="line">        recursion(n-1)</span><br><span class="line">    else:</span><br><span class="line">        #n&gt;0 为False 输出分隔线</span><br><span class="line">        print(&apos;------&apos;)</span><br><span class="line"></span><br><span class="line">    #再次输出n的值</span><br><span class="line">    print(n)</span><br><span class="line"></span><br><span class="line">recursion(3)</span><br><span class="line"></span><br><span class="line">执行结果:</span><br><span class="line">3 2 1 0 ----- 0 1 2 3</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      「流程控制」「函数」
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python 的语法基础</title>
    <link href="http://yoursite.com/2019/04/25/Python/01.Basic-level/01.Python%E7%9A%84%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/04/25/Python/01.Basic-level/01.Python的语法基础/</id>
    <published>2019-04-25T10:11:07.000Z</published>
    <updated>2019-05-24T07:43:20.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python的语法基础"><a href="#Python的语法基础" class="headerlink" title="Python的语法基础"></a>Python的语法基础</h1><ul><li>基础语法</li></ul><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul><li><p>编码<br>默认情况下，Python 3 源码文件以 UTF-8 编码，所有字符串都是 unicode 字符串。 </p></li><li><p>查看数据类型<br>用法：type(变量名)</p></li><li><p>获取变量在内存中的id标识<br>用法：id(变量名)  </p></li></ul><ul><li><p>系统中保留关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import keyword     </span><br><span class="line">print (keyword.kwlist)</span><br></pre></td></tr></table></figure></li><li><p>多行语句<br>Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠()来实现多行语句     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line">        </span><br><span class="line"># 在 [], &#123;&#125;, 或 () 中的多行语句，不需要使用反斜杠(\)</span><br><span class="line">total = [&apos;item_one&apos;, &apos;item_two&apos;, &apos;item_three&apos;,</span><br><span class="line">        &apos;item_four&apos;, &apos;item_five&apos;]</span><br></pre></td></tr></table></figure></li><li><p>等待用户输入：input()</p></li><li>同一行显示多条语句  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Python可以在同一行中使用多条语句，语句之间使用分号(;)分割</span><br><span class="line"> </span><br><span class="line">import sys; x = &apos;runoob&apos;; sys.stdout.write(x + &apos;\n&apos;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="Python的数据类型"><a href="#Python的数据类型" class="headerlink" title="Python的数据类型"></a>Python的数据类型</h1><p>Python中可以自定义数据类型,可以具有无限种数据类型<br>系统默认提供6个标准数据类型：</p><ul><li>Number类型(数字) </li><li>String类型（字符串） </li><li>List类型 (列表) </li><li>tuple类型(元组) </li><li>Dictionary类型(字典) </li><li>Set类型（集合）</li></ul><h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>Number类型主要包含数学相关的数据：一共分为4种小类型：  </p><ul><li><p>整型<br>整型就是整数。包括正整数负整数和0<br>二进制（0b开头）<br>变量 = 0b10101<br>八进制（0o开头）<br>变量 = 0o777<br>十进制（不需要）<br>变量  = 250<br>十六进制（0x开头）<br>变量 = 0xabcd  </p></li><li><p>浮点型<br>浮点型就是小数。<br>使用小数表示浮点数 float1 = 3.141592653<br>科学计数法表示浮点数<br>float2 = 314e-2 # 314*10的-2次方  </p></li><li><p>复数<br>什么是复数。 复数由实数和虚数两部分组成<br>表达式: 163 + 2j<br>使用复数功能结构: com2 = complex(15,3)  </p></li><li><p>布尔类类型<br>布尔值就是表示确定或者否定的数据类型，只有2个值：True和False 在python当中没有真正的布尔类型，而是使用数字0来表示False，数字1表示True，所以bool是Number类型</p></li></ul><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>字符串就是文字类型 </p><h3 id="字符串的声明："><a href="#字符串的声明：" class="headerlink" title="字符串的声明："></a>字符串的声明：</h3><ul><li><p>单引号声明字符串<br>  变量 = ‘值’</p></li><li><p>双引号声明字符串<br>  变量 = “值”  </p></li><li><p>三引号声明变量<br>  变量 = ‘’’值’’’<br>  变量 = “””值”””<br>  三引号声明字符串的方式适合大数据的字符串、多行数据  </p></li></ul><h3 id="字符串相关操作"><a href="#字符串相关操作" class="headerlink" title="字符串相关操作"></a>字符串相关操作</h3><ul><li><p>常用<br>字符串连接符号: +<br>字符复制操作: *<br>[] 通过指定位置（索引）来获取指定位置的字符<br>[:] 取片操作（不包含结束位置）<br>注意事项：<br>单引号中不可以直接使用单引号<br>双引号中不可以直接使用双引号<br>三引号中可以随意使用单双引号   </p></li><li><p>字符串的转义操作：<br>(在行尾时) 续行符<br>\  反斜杠符号<br>\’  单引号<br>\”  双引号<br>\a  响铃<br>\b  退格(Backspace)<br>\e  转义<br>\000    空<br>\n  换行<br>\v  纵向制表符<br>\t  横向制表符<br>\r  回车<br>\f  换页<br>\oyy    八进制数，yy代表的字符，例如：\o12代表换行<br>\xyy    十六进制数，yy代表的字符，例如：\x0a代表换行<br>\other  其它的字符以普通格式输出 </p></li><li><p>r 防止转义:<br>print(r’hello\nrunoob’)    </p></li></ul><h3 id="str-的内置函数"><a href="#str-的内置函数" class="headerlink" title="str 的内置函数"></a>str 的内置函数</h3><ul><li><p>capitalize()  首字母大写<br>格式： str.capitalize()<br>返回值：首字母大写的字符串，仅把整个字符串的第一个字符大写  </p></li><li><p>upper()  将所有英文字符变为大写<br>格式：str.upper()<br>返回值：返回所有英文字符大写的字符串 </p></li><li><p>lower()   将所有英文字符变为小写<br>格式：str.lower()<br>返回值：返回所有英文字符小写的字符串  </p></li><li><p>swapcase()  大小写互相转换<br>格式：str.swapcase()<br>返回值：转换之后的字符串  </p></li><li><p>title()  按照标题格式进行大小写转换（每个单词首字母大写)<br>格式：str.title()<br>返回值：返回所有英文单词首字母大写的字符串  </p></li><li><p>len()  计算字符串的字符个数,以后也可以用于计算元组列表等序列<br>格式: len(str)<br>返回值:整型  </p></li><li><p>count()  计算一个字符串中出现指定字符串的次数<br>格式：str.count(‘查找的字符串’[,开始位置])<br>返回值:返回整型</p></li><li><p>find()  查找字符串中是否具有指定的字符串,查找不到返回-1<br>格式：str.find(查找的字符串[，开始位置])<br>返回值:第一次出现的位置</p></li><li><p>index()  查找字符串中是否具有指定的字符串，查找不到直接报错<br>格式：str.index(查找的字符串[，开始位置])<br>返回值:第一次出现的位置  </p></li><li><p>startswith()  检测字符串是否以指定的字符串开头<br>格式： str.startswith(‘查找的字符串’[，开始位置])<br>返回值：布尔值 </p></li><li><p>endswith()  检测字符串是否以指定的字符串结尾<br>格式： str.endswith(‘查找的字符串’[，开始位置])<br>返回值：布尔值  </p></li><li><p>isupper()  检测字符串中字母是否都是大写字母<br>格式：str.isupper()<br>返回值：布尔值  </p></li><li><p>islower()  检测字符串中的字母是否都是小写字母<br>格式：str.islower()<br>返回值：布尔值  </p></li><li><p>isalnum()  检测一个字符串是否都是有数字或者是否都是有字母组成<br>格式：str.isalnum()<br>返回值:布尔值<br>注意：空字符串返回False  </p></li><li><p>isalpha()  检测字符串是否都是有字母类型构成，汉字作为字母处理<br>格式：str.isalpha()<br>返回值：布尔值<br>注意：空字符串返回False</p></li><li><p>isdigit()  检测字符串是否由纯数字字符组成<br>格式：str.isdigit()<br>返回值：布尔值<br>注意：空字符串返回False  </p></li><li><p>isspace()  检测字符串是否完全由空白字符组成<br>格式：str.isspace()<br>返回值：布尔值<br>注意：回车，换行，缩进，空格都可以当作空白字符，空字符串是False</p></li><li><p>istitle()  检测字符串是否符合title()的结果，每个单词首字母大写<br>格式：str.istitle()<br>返回值：布尔值  </p></li><li><p>isnumeric()  检测字符串是否有纯数字构成<br>格式：str.isnumeric()<br>返回值：布尔值  </p></li><li><p>isdecimal()  检测字符串是否完全由十进制字符组成<br>格式：str.isdecimal()<br>返回值：布尔值  </p></li><li><p>split()  使用指定的字符将字符串卷拆解成多个字符串<br>格式： str.split(‘用于拆解的字符串’)<br>返回值：列表类型  </p></li><li><p>splitlines()  使用\n，\r或者\r\n切割字符串<br>格式：str.splitlines()<br>返回值：列表类型  </p></li><li><p>join()  使用指定的字符串将序列中的内容组成新的字符串<br>格式：连接字符串.join(序列)<br>返回值：组成的新的字符串  </p></li><li><p>zfill()  0填充操作<br>格式： str.zfill(长度)<br>返回值：填充0的字符串<br>注意：填充结果原有内容靠右对齐，前面位数不足使用0来补充，常用于数字类型字符串。  </p></li><li><p>center() 将字符串进行居中操作，并且在空白处进行填充<br>格式： str.center(未来字符宽度,空白填充字符)<br>返回值：新的字符串  </p></li><li><p>ljust（） 将字符串进行左对齐操作，并且在空白处进行填充<br>格式： str.ljust(未来字符宽度,空白填充字符)<br>返回值：新的字符串  </p></li><li><p>rjust() 将字符串进行右对齐操作，并且在空白处进行填充<br>格式： str.rjust(未来字符宽度,空白填充字符)<br>返回值：新的字符串   </p></li><li><p>lstrip() 去掉字符串左侧的空白<br>格式： str.lstrip()<br>返回值：字符串  </p></li><li><p>rstrip()去掉字符串右侧的空白<br>格式： str.rstrip()<br>返回值：字符串  </p></li><li><p>strip()去掉字符串两侧的空白<br>格式： str.strip()<br>返回值：字符串  </p></li><li><p>replace() 字符串替换操作<br>格式： str.replace(被替换的字符串,替换字符串)<br>返回值：替换之后的字符串、  </p></li><li><p>maketrans() 制作一个字符串映射表，为了给translate函数使用<br>格式:str.maketrans（’被替换的字符串’,’替换字符串’）<br>返回值：字典类型，被替换字符串组成键，替换字符串组成值<br>注意： 两个参数的字符串个数必须一一对应，这里的str不是值字符串，而是真正的str，也可以写空字符串代替str（字符串都是str制作的）  </p></li><li><p>translate() 进行字符串翻译操作，类似转换<br>格式：str.translate(映射表)<br>返回值:新的字符串<br>注意:translate用于多字符替换，replace用于长字符串替换  </p></li></ul><h3 id="string模块相关内容"><a href="#string模块相关内容" class="headerlink" title="string模块相关内容"></a>string模块相关内容</h3><ul><li><p>获取所有的空白字符:<br>print (string.whitespace)  </p></li><li><p>获取ascii码的所有字母表（包含大写和小写）:<br>print(string.ascii_letters)  </p></li><li><p>获取ascii码中的所有大写字母:<br>print(string.ascii_uppercase)  </p></li><li><p>获取ascii码中所有的小写字母:<br>print(string.ascii_lowercase)  </p></li><li><p>获取ascii码中所有10进制数字字符:<br>print(string.digits)  </p></li><li><p>获取八进制所有数字字符:<br>print(string.octdigits)  </p></li><li><p>获取十六进制的所有数字字符<br>print(string.hexdigits)  </p></li><li><p>打印所有可见字符<br>print(string.printable)  </p></li><li><p>打印所有标点符号<br>print(string.punctuation)  </p></li></ul><h2 id="List类型-列表"><a href="#List类型-列表" class="headerlink" title="List类型 (列表)"></a>List类型 (列表)</h2><h3 id="列表的定义和访问："><a href="#列表的定义和访问：" class="headerlink" title="列表的定义和访问："></a>列表的定义和访问：</h3><ul><li><p>列表的定义<br>变量 = [值,值,值….]<br>列表的标志符号是[]   </p></li><li><p>列表的访问操作<br>列表变量：[索引位置]<br>添加列表操作：不可以使用索引方式添加<br>修改列表操作：列表变量[索引位置] = 新值<br>删除列表操作：del 列表变量[索引位置] </p></li></ul><h3 id="列表的序列操作"><a href="#列表的序列操作" class="headerlink" title="列表的序列操作"></a>列表的序列操作</h3><ul><li><p>索引操作<br>格式： 列表变量[索引]  </p></li><li><p>分片操作<br>列表[:]<br>表示获取列表的所有数据<br>列表[开始索引：]<br>表示丛开始索引位置截取到列表的最后<br>列表[:结束索引]<br>表示从列表的开头截取到结束索引位置之前，不包含结束位置<br>列表[开始索引:结束索引]<br>表示从列表的开始索引位置截取到结束索引位置之前，不包含结束位置<br>列表[开始索引:结束索引:跳步值]<br>表示从开始索引位置到结束索引位置之间，不包含索引位置，并且获取数据时索引每次+跳步值来获取，默认跳步值为1  </p></li><li><p>序列相加<br>格式：列表 = 列表1 + 列表2</p></li><li><p>列表相乘<br>格式： 列表 = 列表1 * 整数<br>结果：将列表重复N分组成新的列表<br>注意： 数字必须为整数    </p></li><li><p>成员资格运算<br>格式1：数据  in 列表<br>作用：检测数据是否在列表当中<br>返回值：布尔值<br>格式2：数据  not in 列表<br>作用：检测数据是不是不在列表当中<br>返回值：布尔值</p></li><li><p>最大、最小、长度计算</p></li></ul><h3 id="列表的遍历"><a href="#列表的遍历" class="headerlink" title="列表的遍历"></a>列表的遍历</h3><ul><li><p>for i in 列表: </p></li><li><p>while i &lt; length:</p></li><li><p>双层列表循环<br>列表 = [[值1,值2],[值1,值2]，[值1,值2]…]<br>for i,j in 列表:</p></li></ul><h3 id="列表内涵：-list-content"><a href="#列表内涵：-list-content" class="headerlink" title="列表内涵： list content"></a>列表内涵： list content</h3><ul><li><p>简单的列表内涵：<br>格式：[[变量 for [变量 in 列表]<br>作用：遍历列表中的数据并且组成新的列表，如果需要改变原有数据，在最开始i处修改<br>结果：新的列表  </p></li><li><p>带有判断的列表内涵<br>格式 [变量 for 变量 in 列表 判断条件]<br>作用：遍历列表中的数据，根据判断条件取出符合条件的数据组成新的列表<br>结果:新的列表  </p></li><li><p>多循环带判断的列表内涵<br>格式：[[变量1+变量2 for 变量1 in 列表1 for 变量2 in 列表2 判断条件]<br>作用：将列表1中和列表2中每个数据进行操作，但是必须在符合判断条件的前提下进行。<br>结果：新的列表  </p></li></ul><h3 id="序列函数"><a href="#序列函数" class="headerlink" title="序列函数"></a>序列函数</h3><ul><li><p>len() 获取列表的数据长度<br>格式：len(列表)<br>返回值：整型  </p></li><li><p>max() 获取列表中的最大值<br>格式：max(列表)<br>返回值：列表中的最大值  </p></li><li><p>min() 获取列表的最小值<br>格式：min(列表)<br>返回值：列表中的最小值  </p></li><li><p>list() 将其他序列类型转化为列表<br>格式：list(序列)<br>返回值：列表  </p></li></ul><h3 id="列表专用函数"><a href="#列表专用函数" class="headerlink" title="列表专用函数"></a>列表专用函数</h3><ul><li><p>append() 在列表的最后追加新数据<br>格式： 列表.append(数据)<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>insert() 在列表指定的位置插入数据<br>格式：列表.insert（索引,数据）<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>pop() 在列表中移除一个元素<br>格式：列表.pop()<br>返回值:移除掉的元素<br>注意：移除列表最后的元素  </p></li><li><p>格式：列表.pop(索引)<br>返回值：:移除掉的元素<br>注意：移除列表中指定索引的元素  </p></li><li><p>remove() 在列表中移除指定的值的元素<br>格式:列表.remove(值)<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>clear() 清空列表<br>格式：列表.clear()<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>reverse() 列表反转<br>格式：列表.reverse（）<br>返回值：无<br>注意：该操作直接改变原有列表  </p></li><li><p>extend() 在原有列表最后追加新的序列<br>格式:列表.extend(序列类型)<br>返回值：    无<br>注意：该操作直接改变原有列表  </p></li><li><p>count() 计算指定值在列表中出现的次数<br>格式: 列表.count(值)<br>返回值：整数  </p></li><li><p>copy() 复制原有列表<br>格式: 列表.copy()<br>返回值：新的列表 </p></li></ul><h2 id="tuple类型-元组"><a href="#tuple类型-元组" class="headerlink" title="tuple类型(元组)"></a>tuple类型(元组)</h2><h3 id="元组的创建和特征"><a href="#元组的创建和特征" class="headerlink" title="元组的创建和特征"></a>元组的创建和特征</h3><ul><li><p>元组的创建<br>创建空元组:变量 = ()<br>创建单个数据的元组: 变量 = (值,)   或  变量 = 值,<br>创建多个数据的元组: 变量 = (值,值，值…)  或者  变量 = 值,值，值…  </p></li><li><p>元组的特征<br>元组的关键符号是逗号而不是小括号。<br>元组不具备修改功能。<br>是一种特殊的列表。</p></li></ul><h3 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h3><ul><li><p>索引操作<br>元组[索引位置]  </p></li><li><p>分片操作<br>元组[:]<br>获取元素的所有数据<br>元组[开始索引:]<br>获取开始索引位置到最后的所有数据<br>元组[:结束索引]<br>获取元组开头到结束索引位置之前的所有数据（不包含结束位置）<br>元组[开始索引:结束索引]<br>获取元素开始索引位置到结束索引位置之间的所有数据（不包含结束位置）<br>元组[开始索引:结束索引:跳步值]<br>获取元素开始位置到结束索引之间的指定间隔的数据数据（不包含结束位置）  </p></li><li><p>相加操作<br>新元组 = 元组 + 元组  </p></li><li><p>相乘操作<br>新元组 = 元组 * 整数</p></li><li><p>成员检测<br>格式1:数据 in 元组<br>作用：检测数据是不是在元组当中<br>返回值：布尔值<br>格式2:数据 not in 元组<br>检测数据是否不在元组当中<br>返回值：布尔值</p></li></ul><h3 id="元组的遍历"><a href="#元组的遍历" class="headerlink" title="- 元组的遍历"></a>- 元组的遍历</h3><ul><li><p>for i in 元组：</p></li><li><p>双层元组循环<br>元组 = ((值1,值2),(值1,值2)，(值1,值2)…)<br>for i,j in 元组：</p></li></ul><h3 id="元组的函数"><a href="#元组的函数" class="headerlink" title="元组的函数"></a>元组的函数</h3><ul><li><p>len() 获取元组中数据的长度<br>格式： len(元组)<br>返回值：整数  </p></li><li><p>max() 返回元组中最大的值<br>格式：max(元组)  </p></li><li><p>min() 返回元组中的最小值<br>格式：min(元组)  </p></li><li><p>tuple() 将其他序列转化为元组类型<br>格式： tuple(任意序列)  </p></li></ul><h3 id="元组的方法"><a href="#元组的方法" class="headerlink" title="元组的方法"></a>元组的方法</h3><ul><li><p>count() 计算指定数据出现的次数<br>格式:元组.count(查找的数据)<br>返回值：整数  </p></li><li><p>index() 获取指定值在元组中的索引位置<br>格式：元组.index(查找的数据)<br>返回值：索引位置或者错误信息  </p></li><li><p>变量交换 （元组特殊用法）<br>a,b = b,a </p></li></ul><h2 id="Dictionary类型-字典"><a href="#Dictionary类型-字典" class="headerlink" title="Dictionary类型(字典)"></a>Dictionary类型(字典)</h2><ul><li><p>字典格式：<br>变量 = {键:值,键:值….}  </p></li><li><p>键就是标志或者说是目录,值就是真实的值  </p></li><li><p>字典的标志符号是{}   </p></li></ul><h3 id="字典的创建和特征"><a href="#字典的创建和特征" class="headerlink" title="字典的创建和特征"></a>字典的创建和特征</h3><ul><li><p>创建空字典<br>变量 = {} 或者 变量 = dict()</p></li><li><p>创建有数据的字典<br>变量 = {键:值,键:值,键:值…}<br>变量 = dict({键:值,键:值,键:值…})<br>变量 = dict(键=值,键=值,键=值…)<br>变量 = dict([(键,值),(键,值),（键,值）…])<br>变量 = dict(zip((键，键，键….),(值,值，值…)))</p></li><li><p>字典的特征<br>字典也是序列类型但是是无序序列，所以分片操作无法使用<br>字典中每个数据都由键和值两部分组成：<br>值：任意数据都可以当作值来使用<br>键：可以使用 int，float,str,tuple，冰冻集合，但是list，set，dict等不可以使用</p></li></ul><h3 id="字典的基本操作"><a href="#字典的基本操作" class="headerlink" title="字典的基本操作"></a>字典的基本操作</h3><ul><li><p>访问数据：<br>字典变量[键]</p></li><li><p>添加数据<br>字典变量[新键] = 值</p></li><li><p>修改数据<br>字典变量[键] = 新值</p></li><li><p>删除数据<br>del 字典变量[键]</p></li></ul><h3 id="序列操作-1"><a href="#序列操作-1" class="headerlink" title="序列操作"></a>序列操作</h3><ul><li><p>检测数据是否在字典的键中<br>格式：数据 in 字典</p></li><li><p>检测数据是否不再字典的键中<br>格式：数据 not in 字典</p></li></ul><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><ul><li><p>键遍历操作: for k in 字典:</p></li><li><p>键值遍历: for k,v in 字典.items()：</p></li></ul><h3 id="字典内涵"><a href="#字典内涵" class="headerlink" title="字典内涵"></a>字典内涵</h3><ul><li><p>基本的字典内涵<br>变量= {key:value for key,value in 字典.items()}  </p></li><li><p>带有条件的字典内涵<br>变量 = {key:value for key,value in 字典.items() if 条件}  </p></li></ul><h3 id="字典函数"><a href="#字典函数" class="headerlink" title="字典函数"></a>字典函数</h3><ul><li><p>len() 计算字典的长度<br>格式： len(字典)<br>返回值:字典的长度</p></li><li><p>max() 获取字典中的最大值 （默认比较字典的键）<br>格式:max(字典)<br>返回值：最大的键</p></li><li><p>min() 获取字典中的最小值（默认比较字典的键）<br>格式：min(字典)<br>返回值:最小值</p></li><li><p>dict() 将其他序列转化为字典<br>详情请看字典的定义</p></li><li><p>str(字典) 返回字典的字符串格式</p></li></ul><h3 id="字典方法"><a href="#字典方法" class="headerlink" title="字典方法"></a>字典方法</h3><ul><li><p>clear() 清空字典<br>格式：字典.clear()<br>返回值：无  None<br>注意：直接改变原有字典  </p></li><li><p>items() 获取字典的键值对组成的元组格式<br>格式：字典.items()<br>返回值：将键值对变成元组的列表形式。<br>注意:返回的数据是内建的dict_items类型，专用于字典的转换中间类型  </p></li><li><p>keys() 获取字典中所有键组成的序列，常用语字典遍历<br>格式： 字典.keys()<br>返回值:返回所有键的组合<br>注意：类型为 dict_keysL类型，也是一种字典转换的中间类型  </p></li><li><p>values() 获取字典中所有值组成的序列，常用语字典遍历<br>格式： 字典.values()<br>返回值：所有值的组合<br>注意：类型为dict_values类型，也是一种字典转换的中间类型  </p></li><li><p>get（） 根据指定的键获取值<br>格式：字典.get(键,默认值)<br>返回值：字典键对应的数据<br>注意：如果键不存在与字典中，则返回默认值而不会报错  </p></li><li><p>pop() 根据键从字典中删除数据<br>格式:字典.pop(键)<br>返回值：删除的键对应的值<br>注意：pop在字典中使用必须有参数，因为字典无序序列，直接改变原有字典  </p></li><li><p>copy() 赋值一个字典<br>格式：字典.copy()<br>返回值：复制出来的新的字典  </p></li><li><p>setdefault() 设置字典中不存在的键的值<br>格式：字典.setdefault(键,默认值)<br>返回值：设置时的默认值<br>注意：如果设置时键已经存在于字典中，则不进行任何操作，直接改变原有字典  </p></li><li><p>fromkeys() 使用指定的序列作为键,使用一个值作为字典的所有值<br>格式:字典.fromkeys(序列,值)<br>返回值：由序列作为字典的键，由值作为所有键对应的值组成的字典  </p></li><li><p>update() 使用字典更新另外一个字典<br>格式：字典1.update(字典2)<br>返回值：无<br>注意:直接改变原有字典  </p></li></ul><h2 id="Set类型（集合）"><a href="#Set类型（集合）" class="headerlink" title="Set类型（集合）"></a>Set类型（集合）</h2><h3 id="集合的创建和特征"><a href="#集合的创建和特征" class="headerlink" title="集合的创建和特征"></a>集合的创建和特征</h3><ul><li><p>创建空集合<br>变量 = set()  </p></li><li><p>创建多个数据的集合<br>变量 = {值,值,值….}  </p></li><li><p>集合的特征<br>集合是一种无序的数据类型，无法通过索引和分片进行操作<br>集合是内部元素绝对唯一的数据，常常用于去掉重复数据<br>集合的数据，str，int，float,bool,tuple，冰冻集合。  </p></li></ul><h3 id="集合序列操作"><a href="#集合序列操作" class="headerlink" title="集合序列操作"></a>集合序列操作</h3><ul><li><p>检测数据是否在集合当中<br>格式：数据 in 集合</p></li><li><p>检测数据是否不在集合当中<br>格式：数据 not in 集合</p></li></ul><h3 id="集合遍历操作"><a href="#集合遍历操作" class="headerlink" title="集合遍历操作"></a>集合遍历操作</h3><ul><li><p>for i in 集合:</p></li><li><p>带有元组的集合遍历<br>集合 = {(值1,值2..),(值3,值4..)…}<br>for i,j in 集合:</p></li></ul><h3 id="集合内涵"><a href="#集合内涵" class="headerlink" title="集合内涵"></a>集合内涵</h3><ul><li><p>普通集合内涵<br>新集合 = {变量 for 变量 in 集合}  </p></li><li><p>带条件的集合内涵<br>新集合 = {变量 for 变量 in 集合 if 条件}  </p></li><li><p>多循环的集合内涵<br>新集合 = {变量1+变量2 for 变量1 in 集合1 for 变量2 in 集合2 if 条件}    </p></li></ul><h3 id="集合函数"><a href="#集合函数" class="headerlink" title="集合函数"></a>集合函数</h3><ul><li><p>len() 获取集合中元素的个数<br>格式:len(集合)<br>返回值：整数</p></li><li><p>max() 获取集合中最大的元素<br>格式:max(集合)<br>返回值：集合中最大的值</p></li><li><p>min() 获取集合中最小的元组<br>格式：min(集合)<br>返回值：集合中的最小值</p></li><li><p>set() 将其他序列转化为集合类型<br>格式：set(序列)<br>返回值：集合类型</p></li></ul><h3 id="集合方法"><a href="#集合方法" class="headerlink" title="集合方法"></a>集合方法</h3><ul><li><p>add() 向集合中添加数据<br>格式： 集合.add(数据)<br>返回值：无<br>注意：直接改变原有集合，已存在的数据无法添加</p></li><li><p>clear() 清空集合<br>格式：集合.clear()<br>返回值：无<br>注意：直接改变原有集合</p></li><li><p>copy() 集合复制<br>格式:集合.copy()<br>返回值:原集合所有数据组成的新的集合</p></li><li><p>remove() 移除指定的值<br>格式:集合.remove(值)<br>返回值：无<br>注意：直接改变原有集合，如果要删除的值不存在，就报错</p></li><li><p>discard()移除集合中指定的值<br>格式:集合.discard(值)<br>返回值：无<br>注意：直接改变原有集合，如果要删除的值不存在，就不作任何操作</p></li><li><p>pop() 随机移除一个元素<br>格式：集合.pop（）<br>返回值：被移除的元素<br>注意：随机移除元素，没啥规律</p></li><li><p>intersection() 计算两个值集合之间的交集<br>格式： 集合1.intersection(集合2)<br>返回值：新的集合</p></li><li><p>difference() 计算两个集合之间的差集<br>格式： 集合1.difference(集合2)<br>返回值:新的集合</p></li><li><p>union() 计算两个集合之间的并集操作<br>格式：集合1.union（集合2）<br>返回值：新的集合</p></li><li><p>issubset() 检测一个集合是否是另外一个集合的子集<br>格式：集合1.issubset(集合2)<br>返回值：布尔值</p></li><li><p>issuperset() 检测一个集合是否是另外一个和集合的超集<br>格式：集合1.issuperset(集合2)<br>返回值：布尔值</p></li><li><p>difference_update（） 计算集合1和集合2的差集并且将结果赋值给集合1<br>格式：集合1.difference_update(集合2)<br>返回值:无<br>注意：操作结果直接赋值给集合1</p></li><li><p>intersection_update() 计算集合1和集合2的交集并且将结果赋值给集合1<br>格式：集合1.intersection_update(集合2)<br>返回值：无<br>注意:操作结果直接赋值给集合1</p></li><li><p>update() 计算集合1和集合2的并集并且将并集结果赋值给集合1<br>格式：集合1.update(集合2)<br>返回值:无<br>注意:操作结果直接赋值给集合1</p></li></ul><h3 id="冰冻集合-固定集合-frozen"><a href="#冰冻集合-固定集合-frozen" class="headerlink" title="冰冻集合/固定集合 frozen"></a>冰冻集合/固定集合 frozen</h3><ul><li><p>冰冻集合就是不可以进行任何修改相关操作的集合</p></li><li><p>创建冰冻集合<br>创建空的冰冻集合: 变量 = frozenset()<br>创建具有数据的冰冻集合: 变量 = fronzenset(一个序列)  </p></li><li><p>操作方法和函数<br>冰冻集合的操作相关函数和方法同集合类型一样。<br>只是不可以使用修改集合相关的方法和函数。  </p></li><li><p>注意:<br>frozenset 和普通的集合一样没有什么本质区别，能够使用的函数数量不一样，仅此而已哦</p></li></ul><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>类型转换会向着更加精确的类型进行转换  </p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>强制类型转换是根据程序需要，由程序员通过操作强制改变数据的类型。  </p><ul><li><p>int（) 强制将数据转化为整型<br>纯数字字符串转化为整型时，类型改变，值不变<br>只有纯整数字符串才可以转换，其他均不可以<br>浮点型可以转化为整型，去掉小数点后面的部分 </p></li><li><p>float() 强制将数据转化为浮点型<br>整数字符串和浮点数字符串均可以转化为浮点型<br>转化过程中类型改变，值不变<br>整型也可以用于浮点型转换     </p></li><li><p>complex（） 生成一个复数  </p></li><li><p>bool() 强制将数据转化为布尔值<br>能够转化为布尔值False的情况：<br>① 字符串 空字符串 ② 整型 0  ③浮点型 0.0 ④ 复数 0+0j ⑤ 布尔值 Flase ⑥ 列表 [] 空列表 ⑦ 元组 () 空元组 ⑧ 字典 {} 空字典 ⑨ 集合 set（）空集合  </p></li><li><p>str() 字符串类型转换<br>所有数据类型都可以转换为字符串，转换规则就是在原有数据基础上加了引号变成了字符串的格式。例如：[1，2，3] =<br>“[1，2，3]”  </p></li><li><p>list() 将其他数据转换为列表类型<br>能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据）</p></li><li><p>tuple() 将其他数据类型转换为元组类型<br>能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据）  </p></li><li><p>dict() 将其他数据转化为字典类型<br>字典类型转换可以转化的类型有三种：list 、tuple 、set<br>以上所有类型的每个数据必须由元组组成，并且每个元组必须有2个值<br>例子：<br>{(‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’)}<br>[(‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’)]<br>((‘aa’,’AA’),(‘bb’,’BB’),(‘cc’,’CC’))    </p></li><li><p>set() 集合类型转换<br>能够进行list转换的数据类型：str 、set 、tuple 、 dict （iterable数据） </p></li></ul><h1 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h1><h2 id="利用百分号格式化"><a href="#利用百分号格式化" class="headerlink" title="利用百分号格式化"></a>利用百分号格式化</h2><ul><li>%d 此处应该放入一个整数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;i am %d years old&quot;</span><br><span class="line">print (s%18)</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>%s 放入一个字符串 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;i am %s&quot;</span><br><span class="line">print (&quot;i love %s&quot;%&quot;KI&quot;)</span><br><span class="line">print (s%&quot;KIOVEN&quot;)</span><br></pre></td></tr></table></figure></li><li><p>如果出现多个占位符，则相应内容需要用括号括起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = &quot;i am %s,i am %d years old&quot;</span><br><span class="line">print (s%(&quot;ouwen&quot;,18))</span><br></pre></td></tr></table></figure></li></ul><h2 id="利用format格式化"><a href="#利用format格式化" class="headerlink" title="利用format格式化"></a>利用format格式化</h2><ul><li>以{}和： 代替%号，后面用format带参数完成<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = &apos;i love &#123;&#125;&apos;.format(&quot;you&quot;)</span><br><span class="line">print (s)</span><br><span class="line"></span><br><span class="line">s = &quot;i am &#123;1&#125; years old,i love &#123;0&#125; and &#123;1&#125; years old&quot;.format(&quot;tulingxueyuan&quot;,24)</span><br><span class="line">print (s)</span><br></pre></td></tr></table></figure></li></ul><h1 id="表达式、运算符"><a href="#表达式、运算符" class="headerlink" title="表达式、运算符"></a>表达式、运算符</h1><h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><p>由变量、运算符、数字、数字分组符号（括号）等以能求得数值的有意义排列方法所得的组合。</p><h2 id="运算符的分类"><a href="#运算符的分类" class="headerlink" title="运算符的分类"></a>运算符的分类</h2><ul><li>算术运算  </li><li>比较运算/关系运算  </li><li>赋值运算  </li><li>逻辑运算  </li><li>位运算  </li><li>成员运算  </li><li>身份运算  </li></ul><h3 id="算数运算"><a href="#算数运算" class="headerlink" title="算数运算"></a>算数运算</h3><pre><code>+  -  *  /  %(取余)  //(地板除，取商)  **幂运算 </code></pre><p>注意：<br>    python中没有自增自减的 ++ 或者– 运算<br>    混合计算时，Python会把整型转换成为浮点数  </p><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算"></a>比较运算</h3><pre><code>==  ！=  &gt;   &lt;   &gt;=  &lt;=</code></pre><p>注意：在python中没有 === 和 ！==运算，只要类型不同就是不等于</p><h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><pre><code>=   +=  -=  *=  /=  //= **=</code></pre><p>注意：a <em>= b 转换之后的表达式为 a = a </em> b 无论何种赋值运算都符合这个格式      </p><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><p>逻辑运算是布尔值之间的运算<br>and 与运算：有假则假<br>or 或运算：有真则真<br>not 非运算:真变假，假变真</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>位运算就是在二进制基础上进行的逻辑运算，将0视为False，将1视为True进行的运算     </p><ul><li>&amp;   按位与运算</li><li>|   按位或运算</li><li><p>～   按位非运算<br>注意：按位非运算之后计算机会进行反码和补码的相关操作之后进行数据存储   </p></li><li><p>^   按位抑或运算:将数据转化为2进制数据然后进行每个位上的逻辑抑或运算<br>变量 = 值1 ^ 值2  </p></li><li><p>左移运算:将数据转化为二进制之后，将二进制数据的所有数据向左移动指定的位数<br>变量 = 值  &lt;&lt;  移动位数<br>特征：左移N位相当于乘以2的N次方，此方法速度远高于乘法   </p></li><li><p>右移运算<br>将数据转化为二进制之后，将二进制数据的所有数据向右移动指定的位数，如果数据移除右侧边界，则会被删除，实际上相当于采用了地板除！<br>变量 = 值 &gt;&gt;  移动位数<br>特征：右移N位相当于除以2的N次方，舍弃小数部分。此方法速度远高于除法 </p></li></ul><h3 id="成员运算"><a href="#成员运算" class="headerlink" title="成员运算"></a>成员运算</h3><ul><li><p>in 检测一个值在指定的序列类型里面<br>格式：  值 in 可迭代序列  </p></li><li><p>not in 检测一个值是否不再指定的序列里面<br>格式：  值 not in 可迭代序列</p></li></ul><h3 id="身份运算"><a href="#身份运算" class="headerlink" title="身份运算"></a>身份运算</h3><ul><li><p>is 检测值1是不是和值2在内存中是否是同一个值，类似id()功能<br>格式: 数据1 is 数据2  </p></li><li><p>is not 检测值1是不是和值2在内存中是否不是同一个值，类似id()功能<br>格式:   数据1 is not 数据2 </p></li></ul><h3 id="检测数据归属"><a href="#检测数据归属" class="headerlink" title="检测数据归属"></a>检测数据归属</h3><ul><li><p>type() 测试时可以使用，开发尽量避免使用<br>格式：type(变量)  </p></li><li><p>isinstance() 检测一个数据是否由指定的类型创建<br>格式：isinstance(变量，检测的类型)  </p></li></ul><h3 id="运算优先级问题"><a href="#运算优先级问题" class="headerlink" title="运算优先级问题"></a>运算优先级问题</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">**  指数 (最高优先级)  </span><br><span class="line">~ + -   按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)  </span><br><span class="line">* / % //    乘，除，取模和取整除  </span><br><span class="line">+ - 加法减法  </span><br><span class="line">&gt;&gt; &lt;&lt;   右移，左移运算符  </span><br><span class="line">&amp;   位 <span class="string">'AND'</span>  </span><br><span class="line">^ | 位运算符  </span><br><span class="line">&lt;= &lt; &gt; &gt;=   比较运算符  </span><br><span class="line">== !=    等于运算符  </span><br><span class="line">= %= /= //= -= += *= **=    赋值运算符   </span><br><span class="line"><span class="keyword">is</span> <span class="keyword">is</span> <span class="keyword">not</span>   身份运算符  </span><br><span class="line"><span class="keyword">in</span> <span class="keyword">not</span> <span class="keyword">in</span>   成员运算符  </span><br><span class="line"><span class="keyword">not</span> <span class="keyword">or</span> <span class="keyword">and</span>  逻辑运算符    </span><br><span class="line">注意：我们并不推荐死记硬背优先级，在实际使用中最好使用()解决优先级问题</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      「语法基础」「数据类型」「字符串格式化」「表达式、运算符」
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 语法「四」</title>
    <link href="http://yoursite.com/2018/11/15/MySQL/04.MySQL/"/>
    <id>http://yoursite.com/2018/11/15/MySQL/04.MySQL/</id>
    <published>2018-11-15T10:11:07.000Z</published>
    <updated>2019-05-24T07:45:47.834Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-语法「四」"><a href="#MySQL-语法「四」" class="headerlink" title="MySQL 语法「四」"></a>MySQL 语法「四」</h1><ul><li>日志</li><li>备份  </li></ul><h2 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h2><ul><li>错误日志</li><li>查询日志</li><li>慢查询日志</li><li>二进制日志</li><li>中继日志</li><li>innodb 存储引擎级别的事务日志</li></ul><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>mysql 执行过程中的错误信息、警告信息、event  schedule运行时产生的信息、mysql 启动和停止过程的输出信息、主从结构中，从服务器IO复制线程的启动信息。<br>常用 log_error 和 log_warning 来定义。<br>show variables like “%log_errror%”;</p><p>log_warning: 标识告警信息是否一并记录到错误日志中、<br>为  0 表示不记录告警信息 、为1表示告警信息一并记录到错误日志中。<br>大于1 表示失败的连接 的信息和创建新连接时 拒绝访问类的错误信息也会被记录到错误日志。<br>show variables like “%log_warning%”;</p><h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show  variables where variable_name like &quot;%general_log%&quot; or variable_name=&quot;log_output&quot;;</span><br><span class="line">+------------------+----------------------------------+</span><br><span class="line">| Variable_name    | Value                            |</span><br><span class="line">+------------------+----------------------------------+</span><br><span class="line">| general_log      | OFF                              |</span><br><span class="line">| general_log_file | /var/lib/mysql/VM_0_2_centos.log |</span><br><span class="line">| log_output       | FILE                             |</span><br><span class="line">+------------------+----------------------------------+</span><br></pre></td></tr></table></figure><p>general_log：表示查询日志是否开启。默认为OFF</p><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><ul><li><p>show variables like “slow_query_log%”;<br>show variables where variable_name like “%slow_query%” or variable_name like “log_output”;<br>show variables like “slow_query_log%”;<br>log_slow_queries： 是否开启慢查询<br>log_output:慢查询开启后以哪种方式存放<br>FILE：表示慢查询日志存放于指定的文件中<br>TABLE：表示慢查询日志存放于mysql库的slow_log表中<br>FILE,TABLE：同时存放于指定文件和slow_log 表中<br>NONE：不记录查询日志<br>slow_query_log_file:log_output设置为FILE时，指定慢查询日志存储于哪个日志文件中。默认文件名为 “ 主机名-slow.log” ，位置为datadir参数。<br>long_query_time:认定的慢查询时间<br>log_queries_not_using_indexes:如果运行的sql语句没有使用到索引，是否也被当做慢查询记录到慢查询日志中，OFF 表示不记录，ON 表示记录。<br>set global slow_query_log=ON;<br>show variables where variable_name like “%slow_query%” or variable_name like “log_output”;<br>show variables like “slow_query_log%”;<br>set global long_query_time=3;<br>select @@global.long_query_time;<br>举例：select  sleep(5);<br>tail -fn6 /var/lib/mysql/<br>show global status like ‘%slow_queries%’;</p></li><li><p>mysqldumpslow 命令<br>mysql自带的对慢查询日志的统计分析工具。只能作用于慢查询日志文件，不会统计slow_log表。<br>mysqldumpslow -s t /var/lib/mysql/cos72ini-slow.log<br>mysqldumpslow -s r  /var/lib/mysql/DU-HOST-slow.log<br>c :执行计数<br>i:锁定时间<br>r:返回记录<br>t:执行时间<br>al：平均锁定时间<br>ar:平均返回记录数<br>mysqldumpslow -s r -t 2  /var/lib/mysql/DU-HOST-slow.log    -t 指明查看多少条统计信息。查看两条统计信息。</p></li><li><p>其他选项<br>mysqldumpslow –help</p></li></ul><h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><ul><li><p>binlog ：记录所有修改数据的语句、有可能改变数据库的语句—–主要用于时间点恢复（备份恢复），以及主从复制结构。</p></li><li><p>三种模式：<br>statement模式：记录对数据库修改的语句。<br>row模式：记录对数据库做出修改的语句所影响的数据行以及这些行的修改。<br>mixed模式：混合以上两种模式，一般语句使用statement模式，特殊函数使用row模式记录。<br>my.cnf 配置<br>binlog.format=row</p></li><li><p>二进制日志相关参数：<br>log_bin:控制是否开启二进制日志。只读变量，只能通过修改my.cnf，设置log_bin的值<br>sql_log_bin: 当前会话的操作是否会被记录于二进制中<br>binlog_format:二进制日志的记录方式<br>max_binlog_size:设置单个二进制日志文件的最大大小<br>sync_binlog：<br>show binary log;<br>show master logs;</p></li></ul><ul><li><p>查看二进制日志文件<br>①show binlog events in ‘二进制文件名’;<br>指定位置查看：<br>②show binlog events in ‘二进制文件名’ from 24 ;<br>limit 3 ;<br>limit 100,10;<br>③show master status;<br>查看当前使用的二进制文件，以及位置。</p></li><li><p>滚动二进制日志<br>flush logs;</p></li></ul><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><ul><li><p>备份相关术语：<br>全量备份：对某个时间点的数据完全的备份<br>差异备份：<br>增量备份：对上一次备份后的变化的数据的备份<br>时间点恢复<br>热备：在数据库正常运行的情况下备份<br>温备：备份期间数据库只能进行读。不能进行写操作<br>冷备：备份期间。读写均不可操作<br>物理备份：直接备份数据库对应的数据文件<br>逻辑备份：建数据从数据导出，并且将导出的数据进行存档备份  </p></li><li><p>常用的备份工具：<br><a href="http://www.zsythink.net/archives/1450" target="_blank" rel="noopener">mysqldump</a><br><a href="http://www.zsythink.net/archives/1455" target="_blank" rel="noopener">xtrabackup</a><br>select 语句进行部分备份<br>cp、tar命令。适于冷备。</p></li></ul>]]></content>
    
    <summary type="html">
    
      「日志」「备份」
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 语法「三」</title>
    <link href="http://yoursite.com/2018/11/14/MySQL/03.MySQL/"/>
    <id>http://yoursite.com/2018/11/14/MySQL/03.MySQL/</id>
    <published>2018-11-14T10:11:07.000Z</published>
    <updated>2019-05-24T07:45:36.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-语法「三」"><a href="#MySQL-语法「三」" class="headerlink" title="MySQL 语法「三」"></a>MySQL 语法「三」</h1><ul><li>增、删、改、查等     </li><li>查询缓存   </li><li>存储引擎</li></ul><h2 id="增、删、改、查-等"><a href="#增、删、改、查-等" class="headerlink" title="增、删、改、查 等"></a>增、删、改、查 等</h2><ul><li><p>insert<br>① insert into tb1（name,age) values(‘tom’,33);<br>insert into tb1(name,age) values(‘jerry’,33),(‘naruto’，28）；<br>insert into tb1 values(4,’sasuke’,28),(5,’hinata’,25);<br>② insert into tbl set id=2,name=’test’,age=18;</p></li><li><p>delete<br>delete from tb1;<br>delete from tb1 where age=22;<br>delete from tb1 where name like ‘k.*’;<br>delete from tb1 where age &gt; 30 order by age desc limit 1;</p></li><li><p>update<br>update tb1 set age=28;<br>update tb1 set name=’kkkk’ where id=3;<br>update tb1 set name=’xxxx’,age=22 where id=5;</p></li><li><p>select<br>① select <em> from tb1 limit 3;<br>select </em> from tb1 where age&gt;=25 and age&lt;=30;<br>select <em> from tb1 where age between 25 and 30;<br>select </em> from tb1 where age not between 25 and 30;    不在25-30区间。<br>② in 关键字指定列表：<br>select <em> from tb1 where age in(22,23,24,25);<br>③ 去重查询:distinct<br>select distinct age from sut;<br>④ 取别名：<br>select name as stuname,age from t1;<br>⑤ 分组和聚合：<br>select </em> from students froup by gender;<br>⑥ 对分组后的信息再次过滤，使用having 关键字<br>select avg(age) as aveage,gender from students froup by gender having aveage &gt; 20;<br>⑦ 多表查询：<br>select * fomr t1,t2;</p></li></ul><h2 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h2><ul><li><p>查看当前服务是否开启缓存<br>show variables like ‘%query_cache%’;<br>mysql&gt; show variables like ‘%query_cache%’;<br>+——————————+———+<br>| Variable_name                | Value   |<br>+——————————+———+<br>| have_query_cache             | YES     |                YES   支持缓存<br>| query_cache_limit            | 1048576 |                单挑查询缓存的最大值，默认1M。超过大小结果不会被缓存。<br>| query_cache_min_res_unit     | 4096    |        缓存存储于内存的最小单元，默认4K。<br>| query_cache_size             | 1048576 |            查询缓存的总大小<br>| query_cache_type             | OFF     |           ON、OFF、DEMAND 分别表示启用、禁用、按需缓存<br>| query_cache_wlock_invalidate | OFF     |<br>+——————————+———+<br>6 rows in set (0.00 sec)</p></li><li><p>使用：<br>① 在开启缓存（query_cache_type=ON) 指定对应的查询语句不使用缓存：<br>select sql_no_cache name from stu;<br>②在按需缓存（query_cache_type=DEMAND) 指定对应的查询语句使用缓存：<br>select sql_cache name from stu;</p></li><li><p>举例：在 my.cnf 设置查询未 按需缓存，缓存空间大小100M<br>query_cache_type=DEMAND<br>query_cache_size=100M</p></li><li><p>清除查询缓存中已经存在的缓存<br>reset query cache;</p></li></ul><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><ul><li><p>存储引擎也称为 “ 表类型”，每张表可以使用不同的存储引擎类型。<br>MYISAM: 支持级锁，不支持行级锁、不支持事务、不支持外部约束，支持全文索引，表空间文件较小<br>INNODB：支持表级锁、行级锁、事务、外检，不支持全文索引，表空间较大。<br>CSV：<br>MRG_MYISAM：<br>BLACKHOLE：<br>MEMORY：<br>PERFORMANCE_SCHEMA：<br>FEDERATED：<br>ARCHIVE：<br>FEDRATED：</p></li><li><p>查看表类型，查看存储引擎<br>show engines;<br>show create table t1;<br>show table status \G;<br>show table status like ‘%t1%’ \G;</p></li><li><p>设置存储引擎/ 表类型：<br>在创建表的时候指定： create table t1 (id int(10) default null) ENGINE=innodb;</p></li><li><p>修改表的存储引擎/修改默认表类型：<br>alter talbe t1 ENGINE=myisam;</p></li><li><p>修改默认的存储引擎<br>vim /etc/my.cnf<br>default-storage-engine=innodb<br>innodb_file_per_table=on</p></li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><ul><li><p>事务： 一组sql语句的集合。当做一个操作单元。（要么都执行成功、要么全部失败）<br>mysql 中，innodb 存储引擎是支持事务的，完全符合ACID 特性。<br>A： atomicity 原子性<br>C: consistency 一致性<br>I: isolation 隔离性<br>D: durability  持久性</p></li><li><p>redo log ：mysql 会将事务中的sql 语句涉及到的所有数据操作先记录到redo log 中，然后将操作从redo log 中执行。<br>redo log ：包含 redo log buffer(重做日志缓冲）和 redo log file(重做日志文件)<br>redo log  buffer :存在于内存中<br>redo log file： 存在于磁盘上</p></li><li><p>undo log : 数据被修改前的备份。</p></li><li><p>log group:重做日志组。有多个重做日志文件</p></li><li><p>事务日志参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">show global variables like &apos;%innodb%log%&apos;;</span><br><span class="line">mysql&gt; show global variables like &apos;%innodb%log%&apos;;</span><br><span class="line">+----------------------------------+-----------+</span><br><span class="line">| Variable_name                    | Value     |</span><br><span class="line">+----------------------------------+-----------+</span><br><span class="line">| innodb_api_enable_binlog         | OFF       |</span><br><span class="line">| innodb_flush_log_at_timeout      | 1         |</span><br><span class="line">| innodb_flush_log_at_trx_commit   | 1         |表示事务提交以后，是否立即将redo log 从内存耍写到redo log file  中。</span><br><span class="line">| innodb_locks_unsafe_for_binlog   | OFF       |</span><br><span class="line">| innodb_log_buffer_size           | 8388608   |</span><br><span class="line">| innodb_log_compressed_pages      | ON        |</span><br><span class="line">| innodb_log_file_size             | 50331648  |每个redo log file 的大小。</span><br><span class="line">| innodb_log_files_in_group        | 2         |每个重做日志组中有几个 redo log file</span><br><span class="line">| innodb_log_group_home_dir        | ./        |重做日志组文件所在路径，默认为 /var/log/mysql 此目录中的 lib_logfile0 和 lib_logfile1 即为日志组的两个重做日志5M，也对应了innodb_log_file_size 的值。</span><br><span class="line">| innodb_mirrored_log_groups       | 1         |一共有几组日志组</span><br><span class="line">| innodb_online_alter_log_max_size | 134217728 |</span><br><span class="line">| innodb_undo_logs                 | 128       |</span><br><span class="line">+----------------------------------+-----------+</span><br><span class="line">12 rows in set (0.03 sec)</span><br></pre></td></tr></table></figure></li><li><p>事务控制语句<br>查看是否开启自动提交功能：<br>show global variables like ‘autocommit%’;<br>show session variables like ‘autocommit%’;</p></li></ul>]]></content>
    
    <summary type="html">
    
      「增、删、改、查等」「查询缓存」「存储引擎」
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 语法「二」</title>
    <link href="http://yoursite.com/2018/11/12/MySQL/02.MySQL/"/>
    <id>http://yoursite.com/2018/11/12/MySQL/02.MySQL/</id>
    <published>2018-11-12T10:11:07.000Z</published>
    <updated>2019-05-24T07:45:23.538Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-语法「二」"><a href="#MySQL-语法「二」" class="headerlink" title="MySQL 语法「二」"></a>MySQL 语法「二」</h1><ul><li>约束、键  </li><li>索引</li><li>视图</li></ul><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><ul><li><p>常用约束：主键约束、唯一键约束、外键约束、非空约束等<br>主键 primary key ： 一个或多个字段的组合。只能有一个主键<br>唯一键 unique key：字段的数据必须不同于已经存在的其他行上的数据，但可以为空。可以有多个唯一键<br>外键：foreign key。 一个表中的外键字段中所有能插入的数据取值范围，取决于引用的另一个表上主键字段上的已经存在的数据集合<br>检查条件约束：check，自定义的逻辑表达式  </p></li><li><p>非空约束<br>添加非空约束：<br>alter table testtb modify name varchar(100) not null;<br>删除非空约束：<br>alter table testtb modify name varchar(100) null;</p></li><li><p>自动增长<br>添加自动增长：<br>alter table testtb modify id int auto_increment;<br>alter table testtb change id id int auto_increment;<br>删除自动增长：<br>alter table testtb change id id int;<br>alter table testtb modify id int;</p></li><li><p>主键约束<br>添加主键约束：<br>alter table testtb add primary key(id);<br>alter table testtb add constraint primary key(id);<br>删除主键约束：<br>alter table testtb drop primary key;<br>注意：如果对应的主键上存在自动增长，则不能直接删除主键，需先删除自动增长后，在删除主键。</p></li><li><p>唯一性约束<br>添加唯一性约束：<br>alter  table testtb add unique key(uid);<br>alter table testtb add unique key uni_test(test);<br>删除唯一键约束：<br>alter table testtb drop index uni_test;</p></li><li><p>外键约束<br>添加外键约束：<br>alter table testtb add column tid int defalut 0 not null;<br>alter table testtb and constraint testtb_tid_kd foreign key(tid) references testtb2(id);<br>删除外键约束：<br>alter table test4 drop foreign key test_tid_fk;</p></li><li><p>查看约束<br>select * from information_schema.key_column_usage where table_name=’test1’;</p></li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><ul><li><p>索引管理<br>单纯的值index<br>添加一个单纯的索引：<br>① alter table testtb add index ind_name(name);<br>②create index ind_name on testtb(name);<br>create index ind_name on testtb(name(20);<br>create index ind_name on testtb(name(20) desc);</p></li><li><p>联合索引<br>create index ind_id_name on test1(id,name);<br>create index ind_id_name on testtb1(id,name(20));</p></li><li><p>重建索引<br>repair table table_name quick;</p></li><li><p>删除索引<br>alter table test2 drop index uu_ttt;</p></li><li><p>查看索引<br>show index from testtb;<br>show index form testtb key_name like ‘ind%’;</p></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><ul><li><p>创建视图<br>select create_view_priv,,select_priv from mysql.user where user=’root’ and host=’%’;<br>create_view_priv 的值为Y，表示当前用户拥有创建视图的权利。<br>create view testvi as select <em> from classes where classid &lt;=3;<br>视图是一种虚表，不能与存在的表重名:<br>create or replace view testvi as select </em> from classes where classid &lt;=4  如果不存在testvi则创建，存在则覆盖。</p></li><li><p>视图使用自己的字段名称<br>create view testvi(a,b,c) select * from classes;<br>create view testvi(classname,stunum) as select class,num from classes</p></li><li><p>从多个表中查询出数据创建视图<br>create or replace view testvi as select s.name,s.age,c.class from students  s.classes c where s.classid=c.classid;</p></li><li><p>删除视图<br>drop view testvi;<br>如果视图testvi存在，则删除<br>drop view if exists testvi;</p></li><li><p>查看视图<br>select <em> from information_schema.views where table_schema=’U_DB_NAME’;<br>像查表一样使用：<br>select </em> from testvi;</p></li><li>修改视图<br>alter view testvi as select name,age from students;</li></ul>]]></content>
    
    <summary type="html">
    
      「约束、键」「索引」「视图」
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 语法「一」</title>
    <link href="http://yoursite.com/2018/11/08/MySQL/01.MySQL/"/>
    <id>http://yoursite.com/2018/11/08/MySQL/01.MySQL/</id>
    <published>2018-11-08T10:11:07.000Z</published>
    <updated>2019-05-24T07:45:13.568Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-语法"><a href="#MySQL-语法" class="headerlink" title="MySQL 语法"></a>MySQL 语法</h1><ul><li>MySQL 管理</li><li>MySQL 用户、授权</li><li>MySQL 库</li><li>MySQL 表</li></ul><h2 id="MySQL-管理"><a href="#MySQL-管理" class="headerlink" title="MySQL 管理"></a>MySQL 管理</h2><h3 id="启动和关闭"><a href="#启动和关闭" class="headerlink" title="启动和关闭"></a>启动和关闭</h3><ul><li>不是通过RPM包安装的MySQL<br>启动：    /usr/bin/mysqld_safe &amp;<br>关闭：    mysqladmin -uroot shutdown -p</li></ul><h3 id="MySQL-连接"><a href="#MySQL-连接" class="headerlink" title="MySQL 连接"></a>MySQL 连接</h3><ul><li><p>-D 指定将要登录的具体的数据库<br>mysql -uroot -D test -p123456  </p></li><li><p>本地连接mysql，-S  指定套接字位置<br>mysql -u root -p -S /var/lib/mysql/mysql.sock</p></li><li><p>远程连接mysql，-P 指定mysql服务对应的端口<br>mysql -u root -p 123456 -h 192.168.1.1 -P 3306</p></li><li><p>连接数据库的同时执行对应命令，并返回结果，不进入mysql 提示符<br>mysql -uroot -p123456 -e  ‘use mysql; select user,host,passwd from user;’<br>mysql -uroot -p123456 -e ‘create database if not exists testdb;show databases;’</p></li></ul><h3 id="Help"><a href="#Help" class="headerlink" title="Help"></a>Help</h3><ul><li>help create </li><li>help create databases</li><li>help contents</li><li>help ‘Data Types’</li></ul><h3 id="mysql的属性、状态、变量"><a href="#mysql的属性、状态、变量" class="headerlink" title="mysql的属性、状态、变量"></a>mysql的属性、状态、变量</h3><ul><li>mysql&gt; status</li><li><p>系统变量：配置了mysql的运行环境属性</p></li><li><p>全局变量：global variables ,作用域为整个mysql服务器<br>show  global variables；<br>版本相关：    show global variables  like ‘%version%’ ;<br>字符集相关：    show global variables where variable_name like ‘character%’;<br>日志是否关闭：    show global variables where variable_name like ‘%log%’ and value=’off’;</p></li><li><p>会话变量：session variables，作用域为当前会话<br>show session variables;<br>show variables; </p></li><li><p>查看单个全局系统变量或者会话系统变量：<br>select @@[global | session].system_var_name;<br>select @@global.pid_file;<br>select @@session.warning_count;</p></li><li><p>状态变量：mysql运行中的状态信息，不能设置。<br>查询mysql运行中信息和状态：状态变量也分为全局级别与会话级别<br>show  status;<br>show global status;<br>show session status;<br>show status where variable_name like ‘Uptime%’;</p></li><li><p>在写储存过程中，调用系统变量的值：<br>@@GLOBAL.var_name<br>@@SESSION.var_name<br>@@var_name 表示优先从会话级别获取变量值</p></li><li><p>修改变量值/设定变量值:<br>① 运行时修改：是否立即生效取决于修改的变量的类型，set 命令，运行时修改变量<br>运行时修改global级别的变量：对修改之前建立的会话没有影响，仅对修改后新建立的会话有效<br>运行时修改session级别的变量：仅对当前会话有效，且立即生效<br>② 配置文件修改：重启后生效。<br>例：<br>③ set @@session.autocommit=0;<br>设置系统变量语法总结：<br>set global.var_name = value;<br>set @@global.var_name = value;<br>set session.var_name = value;<br>set @@session.var_name = value;<br>set var_name = value; 不指定级别表示默认为设置会话级别的变量。</p></li></ul><h2 id="MySQL-用户"><a href="#MySQL-用户" class="headerlink" title="MySQL 用户"></a>MySQL 用户</h2><h3 id="MySQL-用户管理"><a href="#MySQL-用户管理" class="headerlink" title="MySQL 用户管理"></a>MySQL 用户管理</h3><ul><li>mysql 的用户格式：    usernmae@host<br>host: 主机名 或者 IP ，mysql 认为主机名 和 IP地址属于不同的主机。<br>通配符：</li><li><p>： 表示任意单个字符<br>%： 表示任意长度的任意字符<br>root@’10.1.%.%’    root用户可以通过10.1这个网段远程登录</p></li><li><p>查询用户<br>use mysql<br>select user,host,passwd from user;</p></li><li><p>创建用户<br>① create user ‘zabbix_proxy‘@’localhost’ identified by ‘zabbix_asp_2017’;<br>② 直接在mysql库的user 表中插入一条记录。（设置了严格的sql-mode  后无法使用）<br>insert  into mysql.user(user,host,passwd) values(‘pan’,’192.168.%.%’,passwd(‘123456’));<br>③ 在授权数据库的同时，如果对应的用户不存在，那么mysql会自动创建对应的用户。<br>grant all on pan.*to <a href="mailto:pan@127.0.0.1" target="_blank" rel="noopener">pan@127.0.0.1</a> identfied by ‘123456’;</p></li><li><p>删除用户<br>① delete 语句删除mysql.user 表中的用户对应的记录，有相关信息残留。<br>delete from mysql.user where user=’pan’ and host=’127.0.0.1’;<br>② drop user <a href="mailto:pan@127.0.0.1" target="_blank" rel="noopener">pan@127.0.0.1</a>     用户与用户对应的所有权限将被删除。</p></li><li><p>重命名用户：<br>rename user oldname to newname;</p></li></ul><h3 id="MySQL-密码管理"><a href="#MySQL-密码管理" class="headerlink" title="MySQL 密码管理"></a>MySQL 密码管理</h3><ul><li><p>更改用户名密码，官方推荐使用alter<br>ALTER USER test@’%’ IDENTIFIED BY ‘123456’;</p></li><li><p>update mysql.user set authentication_string=password(“新密码”) where User=”test” and Host=”localhost”;<br>flush privileges;</p></li><li><p>忘记root密码<br>① vi /etc/my.cnf，在[mysqld]中添加<br>skip-grant-tables<br>② 重启mysql : systemctl restart mysqld.service<br>③ mysql -uroot -p<br>④ use mysql;<br>⑤ 修改root密码：<br>update user set authentication_string=password(‘123456’) where user=’root’;<br>flush privileges;<br>⑥ 删除第1部增加的配置信息<br>skip-grant-tables<br>⑦ 重启mysql ： systemctl restart mysqld.service</p></li></ul><h2 id="授权管理"><a href="#授权管理" class="headerlink" title="授权管理"></a>授权管理</h2><ul><li><p>授权命令：<br>GRANT ALL privileges on db.tbl to ‘username‘@’host’ identified by ‘passwd’;<br>db 数据库名  tbl 表名    可以使用<em>通配。<br>示例：给本地用户授权某个数据库的所有权限<br>grant all privileges on pandb.</em> to pan@localhost identified by ‘123456’;<br>grant all on pandb.* to pan@localhost identified by ‘123456’;            privileges 关键字可省</p></li><li><p>给远程用户授权<br>grant all privileges on panthink.* to pan@’192.168.%.%’ identified by ‘123456’;<br>flush privileges;</p></li><li><p>授权用户某个数据库的某个权限，比如，只授权用户对于某个数据<br>grant select privileges on panthink.* to pan@’192.168.%.%‘；</p></li><li><p>授权某个数据库多个权限：<br>grant insert,delete,update,select on panthink.* to pan@’192.168.%.%’;</p></li><li><p>授权给多个用户：<br>grant select on mydb.* to pan@locakhost,pan2@localhost;</p></li><li><p>对某张表的某个字段授权：<br>grant select(name,age) on pan.students to pan@localhost;</p></li><li><p>授权test函数，用function关键字指明被操作的对象是函数：<br>grant execute on fuction panthink.test to pan@’192.168.%.%’;</p></li><li><p>强制用户使用ssl建立会话<br>grant useage on <em>.</em>  to ‘zabbix‘@’222.222.222.222’ require ssl;<br>取消ssl 连接限制<br>grant useage on <em>.</em>  to ‘zabbix‘@’222.222.222.222’ require none;</p></li><li><p>赋予用户授权的权限<br>授权zabbix用户db01 的 select权限，同时zabbix 用户也能将此权限授予给其他用户<br>grant select on db01.*  to ‘zabbix‘@’192.168.%.%’  with grant option;</p></li><li><p>查看授权：<br>从用户：    show grants for 用户名；<br>从数据库：select * from mysql.db where db=”要查看的数据库“；</p></li><li><p>删除授权：<br>revoke ‘要删除的权限’ on db.tb from user@host;<br>删除<a href="mailto:zabbix@192.168.1.1" target="_blank" rel="noopener">zabbix@192.168.1.1</a> 用户对于word数据库的所有权限:<br>revoke all on word.* from <a href="mailto:zabbix@192.168.1.1" target="_blank" rel="noopener">zabbix@192.168.1.1</a>;</p></li></ul><h2 id="库管理"><a href="#库管理" class="headerlink" title="库管理"></a>库管理</h2><ul><li><p>创建数据库<br>create database if not exists testdb charaacter set utf16;</p></li><li><p>查看数据库<br>show databases;<br>show create database testdb;<br>查看可用的字符集的命令<br>show character set;<br>查看排序方式的命令<br>show collation；</p></li><li><p>修改数据库<br>alter database testdb character set utf 8;<br>修改数据库的字符集，并设置为默认字符集，数据库中的表都会继承此字符集。<br>alter database testdb default character set utf8; </p></li><li><p>删除数据库<br>drop database if exists testdb;</p></li><li><p>数据库导出<br>mysqldump -u user_name -p database_name &gt; 导出的文件名</p></li><li><p>导出一个数据库结构（不包含数据）<br>mysqldump -u user_name -p -d –add-drop-table database_name &gt; outfile_name.sql</p></li><li><p>带语言参数导出<br>mysqldump -uroot -p –default-character-set=latin1 –set-charset=gbk –skip-opt database_name &gt; outfile_name.sql</p></li></ul><h2 id="表管理"><a href="#表管理" class="headerlink" title="表管理"></a>表管理</h2><ul><li><p>查看表的状态<br>show table status where name like ‘%tt%’;<br>desc table_name;<br>查看某张表创建时对应的sql 语句<br>show create table table_name;<br>复制表，但字段的约束和表的索引会丢失。<br>create table testtb2 select * from students;<br>完全的复制表结构<br>create table testdb3 like students;                    </p></li><li><p>修改表：<br>重命名表<br>alter table test1 rename as test2;<br>为表添加字段<br>alter  table ttt add cloumn age int;<br>alter table ttt add age int;        //  省略cloumn 默认为操作列。<br>添加字段设定相应的约束：<br>alter table ttt add age int not null default 0;<br>alter table ttt add cloumn age int not null default 0;<br>添加字段，指定字段在表中的位置：<br>alter table ttt add id int first;<br>alter table hosts add  categoryof varchar(200)  DEFAULT NULL after templateid;<br>删除字段：<br>alter table ttt drop stuname;<br>重命名字段：<br>alter table tsettb4 change name name1 char(20);<br>修改字段类型：<br>alter table testtb change age age char(20);<br>alter table testtb modify age int;    // modify 不能修改字段名称。</p></li><li><p>导出单个数据表结构和数据<br>mysqldump -u user_name -p database_name table_name &gt; outfile_name.sql</p></li><li><p>导出单个数据表结构（不包含数据）<br>mysqldump -h localhost -uroot -p123456  -d database table &gt; dump.sql</p></li></ul>]]></content>
    
    <summary type="html">
    
      「管理」「用户」「授权」「库」「表」
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Linux 系统运维</title>
    <link href="http://yoursite.com/2018/11/01/Linux/01.Linux%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    <id>http://yoursite.com/2018/11/01/Linux/01.Linux系统运维/</id>
    <published>2018-11-01T10:11:07.000Z</published>
    <updated>2019-05-24T03:09:20.151Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux-系统运维"><a href="#Linux-系统运维" class="headerlink" title="Linux 系统运维"></a>Linux 系统运维</h1><h2 id="系统状态"><a href="#系统状态" class="headerlink" title="系统状态"></a>系统状态</h2><h3 id="监控系统状态"><a href="#监控系统状态" class="headerlink" title="监控系统状态"></a>监控系统状态</h3><ul><li>w </li><li>uptime</li><li><p>vmstat<br>vmstat  1<br>vmstat 1 10<br>vmstat各指标含义：<br>r ：表示运行和等待cpu时间片的进程数，如果长期大于服务器cpu的个数，则说明cpu不够用了；<br>b ：表示等待资源的进程数，比如等待I/O, 内存等，这列的值如果长时间大于1，则需要关注一下了<br>si ：由交换区进入内存的数量；<br>so ：由内存进入交换区的数量；<br>bi ：从块设备读取数据的量（读磁盘）；<br>bo： 从块设备写入数据的量（写磁盘）；<br>wa ：表示I/O等待所占用cpu时间百分比.</p></li><li><p>top<br>用于动态监控进程所占系统资源，每隔3秒变一次。<br>RES 这一项为进程所占内存大小，而 %MEM 为使用内存百分比。在 top状态下，按 “shift + m”, 可以按照内存使用大小排序。按数字 ‘1’ 可以列出各颗cpu的使用状态。<br>top -bn1 它表示非动态打印系统资源使用情况，可以用在shell脚本中 </p></li><li><p>sar<br>没有这个命令，使用yum install -y sysstat<br>网卡流量 sar -n DEV, sar -n DEV 1 10<br>sar -n DEV -f /var/log/sa/sa24<br>查看历史负载  sar -q<br>查看磁盘读写  sar -b</p></li></ul><h3 id="PM"><a href="#PM" class="headerlink" title="PM"></a>PM</h3><ul><li><p>free查看系统内存使用情况<br>free以k为单位显示 -m以M为单位  -g以G为单位<br>mem(total):内存总数;<br>mem(used):已经分配的内存;<br>mem(free):未分配的内存;<br>mem(buffers):系统分配但未被使用的buffers；<br>mem(cached)系统分配但未被使用的cache<br>buffers/cache(used):实际使用的buffers与cache 总量，也是实际使用的内存；<br>buffers/cache(free):未被使用的buffers与cache和未被分配的内存之和，这就是系统当前实际可用内存<br>buffers是即将要被写入磁盘的，cache是被从磁盘中读出来的 </p></li><li><p>ps 查看系统进程<br>ps aux / ps -elf<br>PID ：进程的id，这个id很有用，在linux中内核管理进程就得靠pid来识别和管理某一个程，比如我想终止某一个进程，则用 ‘kill  进程的pid’ 有时并不能杀掉，则需要加一个-9选项了 kill  -9  进程pid<br>STAT ：表示进程的状态，进程状态分为以下几种<br>D 不能中断的进程（通常为IO）<br>R 正在运行中的进程<br>S 已经中断的进程，系统中大部分进程都是这个状态<br>T 已经停止或者暂停的进程，如果我们正在运行一个命令，比如说 sleep 10 如果我们按一下ctrl -z 让他暂停，那么我们用ps查看就会显示T这个状态<br>X 已经死掉的进程（这个从来不会出现）<br>Z 僵尸进程，杀不掉，打不死的垃圾进程，占系统一小点资源，不过没有关系。如果太多，就有问题了。<br>&lt; 高优先级进程<br>N 低优先级进程<br>L 在内存中被锁了内存分页<br>s 主进程<br>l 多线程进程</p></li></ul><ul><li>在前台的进程</li></ul><h2 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h2><h3 id="网络状态"><a href="#网络状态" class="headerlink" title="网络状态"></a>网络状态</h3><ul><li><p>netstat 查看网络状况<br>netstat -lnp  查看当前系统开启的端口以及socket<br>netstat -an  查看当前系统所有的连接</p></li><li><p>curl<br>curl -xip:port <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a>  # -x可以指定ip和端口，省略写hosts，方便实用<br>curl -Iv <a href="http://www.qq.com" target="_blank" rel="noopener">http://www.qq.com</a> # -I 可以把访问的内容略掉，只显示状态码,-v可以显示详细过程<br>curl  -u user:password  <a href="http://123.com" target="_blank" rel="noopener">http://123.com</a> # -u可以指定用户名和密码<br>curl  <a href="http://study.lishiming.net/index.html" target="_blank" rel="noopener">http://study.lishiming.net/index.html</a> -O #可以下载，还可以使用 -o 自定义名字 curl -o index2.html<a href="http://study.lishiming.net/index.html" target="_blank" rel="noopener">http://study.lishiming.net/index.html</a></p></li><li><p>nc -z -w2 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 1-1024  # -w2 表示 2s超时  port 这里可以只写一个端口，也可以写一个范围。 使用nc扫描端口时，必须要加 -z 否则不显示结果。另外，如果想把不开放的端口也显示出来，可以加一个 -v </p></li><li><p>tcpdump 系统自带抓包工具<br>tcpdump -nn -i eth0 tcp and host 192.168.0.1 and port 80<br>tcpdump -nn -vs0 tcp and port not 22 -c 100 -w 1.cap<br>wireshark 在linux下也可以安装 yum install -y wireshark<br>抓包分析http请求：tshark -n -t a -R http.request -T fields -e “frame.time” -e “ip.src” -e “http.host” -e “http.request.method” -e “http.request.uri”</p></li></ul><h1 id="Selinux、Iptables"><a href="#Selinux、Iptables" class="headerlink" title="Selinux、Iptables"></a>Selinux、Iptables</h1><ul><li><p>Selinux<br>配置文件 /etc/selinux/config<br>三种形式：enforcing, permissive, disabled SELINUX=disabled<br>setenforce 0/1<br>getenforce </p></li><li><p>netfilter –  iptables<br>iptables -nvL 查看规则<br>iptables -F 清除当前的规则<br>iptables -Z 计数器清零<br>service iptables save 保存规则 保存的规则文件为：/etc/sysconfig/iptables<br>service iptables stop  可以暂停防火墙，但是重启后它会读取/etc/sysconfig/iptables 从而启动防火墙，另外即使我们停止防火墙，但一旦我们添加任何一条规则，它也会开启<br>iptables -t  指定表名，默认不加-t则是filter表<br>filter 这个表主要用于过滤包的，是系统预设的表,内建三个链INPUT、OUTPUT以及FORWARD。INPUT作用于进入本机的包；OUTPUT作用于本机送出的包；FORWARD作用于那些跟本机无关的包。<br>nat 主要用处是网络地址转换，也有三个链。PREROUTING 链的作用是在包刚刚到达防火墙时改变它的目的地址，如果需要的话。OUTPUT链改变本地产生的包的目的地址。POSTROUTING链在包就要离开防火墙之前改变其源地址。<br>mangle 这个表主要是用于给数据包打标记，然后根据标记去操作哪些包。这个表几乎不怎么用。 </p></li><li><p>iptables规则相关：<br>查看规则 iptables -t nat -nvL<br>清除规则 iptables -t nat -F<br>增加/删除规则  iptables -A/-D INPUT -s 10.72.11.12 -p tcp –sport 1234 -d 10.72.137.159 –dport 80 -j DROP<br>插入规则 iptables -I INPUT -s 1.1.1.1 -j DROP/ACCEPT/REJECT<br>iptables -nvL –line-numbers  查看规则带有id号<br>iptables -D INPUT 1 根据规则的id号删除对应规则<br>iptables -P INPUT DROP  用来设定默认规则，默认是ACCEPT ，一旦设定为DROP后，只能使用 iptables -P ACCEPT 才能恢复成原始状态，而不能使用-F参数<br>示例：<br>针对filter表，预设策略INPUT链DROP，其他两个链ACCEPT，然后针对192.168.0.0/24开通22端口，对所有网段开放80端口，对所有网段开放21端口。 脚本如下：<br>#! /bin/bash<br>ipt=”/sbin/iptables”<br>$ipt -F; $ipt -P INPUT DROP;<br>$ipt -P OUTPUT ACCEPT; $ipt -P FORWARD ACCEPT;<br>$ipt -A INPUT -s 192.168.0.0/24 -p tcp –dport 22 -j ACCEPT<br>$ipt -A INPUT -p tcp –dport 80 -j ACCEPT<br>$ipt -A INPUT -p tcp –dport 21 -j ACCEPT<br>icmp的包有常见的应用,本机ping通外网，外网ping不通本机 iptables -I INPUT -p icmp –icmp-type 8 -j DROP </p></li><li><p>nat表应用：<br>路由器就是使用iptables的nat原理实现<br>假设您的机器上有两块网卡eth0和eth1，其中eth0的IP为192.168.10.11，eth1的IP为172.16.10.11 。eth0连接了intnet 但eth1没有连接，现在有另一台机器(172.16.10.12)和eth1是互通的，那么如何设置也能够让连接eth1的这台机器能够连接intnet?<br>echo “1” &gt; /proc/sys/net/ipv4/ip_forward<br>iptables -t nat -A POSTROUTING -s 172.16.10.0/24 -o eth0 -j MASQUERADE </p></li><li><p>iptables规则备份与恢复：<br>service iptables save 这样会保存到/etc/sysconfig/iptables<br>iptables-save &gt; myipt.rule 可以把防火墙规则保存到指定文件中<br>iptables-restore &lt; myipt.rule  这样可以恢复指定的规则</p></li></ul><h3 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h3><ul><li>Linux系统任务计划<br>/etc/crontab  cron的主配置文件，可以定义PATH<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cron格式如下：</span><br><span class="line"># .----------------分钟 (0 - 59)</span><br><span class="line"># |  .------------- 小时 (0 - 23)</span><br><span class="line"># |  |  .----------  日 (1 - 31)</span><br><span class="line"># |  |  |  .-------  月 (1 - 12)</span><br><span class="line"># |  |  |  |  .----   周 (0 - 6) (周日=0 or 7) </span><br><span class="line"># |  |  |  |  |</span><br><span class="line"># * *  * *  * user-name command to be executed</span><br><span class="line"></span><br><span class="line">cron 也是一个服务，所以需要先启动服务才能生效：service crond start; service crond status</span><br></pre></td></tr></table></figure></li></ul><h2 id="Linux-系统管理"><a href="#Linux-系统管理" class="headerlink" title="Linux 系统管理"></a>Linux 系统管理</h2><ul><li><p>Linux系统服务管理<br>工具ntsysv 类似图形界面管理工具，如果没有该命令使用 yum install -y ntsysv 安装<br>常用服务：crond, iptables, network, sshd, syslog, irqbalance, sendmail, microcode_ctl<br>chkconfig –list<br>chkconfig –add/del servicename<br>chkconfig –level [345] servicename on/off</p></li><li><p>Linux系统日志<br>/var/log/messages核心系统日志文件<br>每周归档一个日志 messages-20130901<br>/etc/logrotate.conf<br>messages由syslogd这个守护进程产生的，如果停掉这个服务则系统不会产生/var/log/messages<br>/var/log/wtmp  查看用户登录历史 last<br>/var/log/btmp  lastb 查看无效登录历史<br>/var/log/maillog<br>/var/log/secure<br>dmesg<br>/var/log/dmesg</p></li><li><p>exec与xargs<br>exec 和find同时使用<br>查找当前目录创建时间大于10天的文件并删除 ：find . -mtime +10 -exec rm -rf {} \;<br>批量更改文件名: find ./<em> -exec mv {} {}_bak \;<br>xargs 用在管道符号后面<br>find . -mtime +10 |xargs rm -rf<br>ls -d ./</em> |xargs -n1 -i{} mv {} {}_bak<br>xargs 可以把多行变成一行  cat 1.txt|xargs</p></li><li><p>screen 工具介绍<br>screen相当于一个虚拟终端，它不会因为网络中断而退出，每次登录都可以进入那个screen<br>使用方法：直接输入screen命令<br>screen -ls  查看已经开启的screen<br>Ctrl +a 再按d退出该screen会话，只是退出，并没有结束。结束的话输入Ctrl +d 或者输入exit<br>退出后还想再次登录某个screen会话，使用sreen -r screenid 若只有一个screen 直接screen -r<br>screen -S aming ； 登录的话 screen -r aming</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux-系统运维&quot;&gt;&lt;a href=&quot;#Linux-系统运维&quot; class=&quot;headerlink&quot; title=&quot;Linux 系统运维&quot;&gt;&lt;/a&gt;Linux 系统运维&lt;/h1&gt;&lt;h2 id=&quot;系统状态&quot;&gt;&lt;a href=&quot;#系统状态&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7 快速安装Zabbix3.4</title>
    <link href="http://yoursite.com/2018/09/25/Zabbix/01.ZabbixInstall/"/>
    <id>http://yoursite.com/2018/09/25/Zabbix/01.ZabbixInstall/</id>
    <published>2018-09-25T10:11:07.000Z</published>
    <updated>2019-05-27T15:05:45.162Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/05/27/Ve9sET.jpg" alt="Ve9sET.jpg"></p><ul><li>关于zabbix<br>  zabbix一开强大的开源监控工具，同类型还有nagios，ganglia，cacti等监控工具，通过过去一年Google趋势就知道zabbix全球的相对热度：<br><img src="https://s2.ax1x.com/2019/05/27/VZxPwF.md.png" alt="VZxPwF.md.png"></li><li>安装平台（摘自官网）　　　<br>  Linux / IBM AIX / FreeBSD / NetBSD / OpenBSD / HP-UX / Mac OS X / Solaris　　//能够部署server和agent<br>  Windows: all desktop and server versions since XP (Zabbix agent only)　  //windows平台只能安装agent，也就是“被监控”。</li></ul><h1 id="搭建LAMP-环境"><a href="#搭建LAMP-环境" class="headerlink" title="搭建LAMP 环境"></a>搭建LAMP 环境</h1><p>这一部分介绍如何在Centos7 上配置Apache+MySQL+PHP7</p><h2 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h2><p>yum install httpd httpd-devel  </p><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>在CentOS7 中默认安装有MariaDB，这个是MySQL的分支，还是要在系统中安装MySQL，而且安装完成之后可以直接覆盖掉MariaDB。</p><ul><li>下载MySQL官方的 Yum Repository 并安装MySQL。<br>[root@localhost ~]# wget -i -c <a href="http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm" target="_blank" rel="noopener">http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm</a><br>[root@localhost ~]# yum -y install mysql57-community-release-el7-10.noarch.rpm<br>[root@localhost ~]# yum -y install mysql-community-server</li><li>MySQL 设置<br>找出初始的root用户的密码，通过如下命令可以在日志文件中找出密码：<br>[root@localhost ~]# grep “password” /var/log/mysqld.log<br>2019-05-19T00:42:03.830587Z 1 [Note] A temporary password is generated for root@localhost: 5&amp;vPo_Vej1GZ<br>如下命令进入数据库：<br>[root@localhost ~]# mysql -uroot -p<br>输入初始密码，此时不能做任何事情，因为MySQL默认必须修改密码之后才能操作数据库：<br>mysql&gt; ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘new password’;</li></ul><h2 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h2><ul><li><p>安装php<br>检查当前安装的PHP包：<br>yum list installed | grep php<br>如果有安装的PHP包，先删除他们<br>更新yum 源：<br>rpm -Uvh <a href="http://mirror.webtatic.com/yum/el5/latest.rpm" target="_blank" rel="noopener">http://mirror.webtatic.com/yum/el5/latest.rpm</a>    ##CentOs 5.x<br>rpm -Uvh <a href="http://mirror.webtatic.com/yum/el6/latest.rpm" target="_blank" rel="noopener">http://mirror.webtatic.com/yum/el6/latest.rpm</a>    ##CentOs 6.x<br>rpm -Uvh <a href="https://mirror.webtatic.com/yum/el7/epel-release.rpm" target="_blank" rel="noopener">https://mirror.webtatic.com/yum/el7/epel-release.rpm</a>   ##CentOs 7.X<br>rpm -Uvh <a href="https://mirror.webtatic.com/yum/el7/webtatic-release.rpm" target="_blank" rel="noopener">https://mirror.webtatic.com/yum/el7/webtatic-release.rpm</a><br>安装：<br>yum install php70w.x86_64 php70w-cli.x86_64 php70w-common.x86_64 php70w-gd.x86_64 php70w-ldap.x86_64 php70w-mbstring.x86_64 php70w-mcrypt.x86_64 php70w-mysql.x86_64 php70w-pdo.x86_64</p></li><li><p>测试PHP<br>[root@nmserver-7 ~]# cd  /var/www/html/<br>[root@nmserver-7 html]# vi info.php</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">        phpinfo();</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">[root@localhost html]# curl -I http://localhost/info.php</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Sat, 25 May 2019 01:06:40 GMT</span><br><span class="line">Server: Apache/2.4.6 (CentOS) PHP/7.0.33</span><br><span class="line">X-Powered-By: PHP/7.0.33</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br></pre></td></tr></table></figure></li></ul><h1 id="Zabbix-安装"><a href="#Zabbix-安装" class="headerlink" title="Zabbix 安装"></a>Zabbix 安装</h1><h2 id="Zabbix3-4-安装"><a href="#Zabbix3-4-安装" class="headerlink" title="Zabbix3.4 安装"></a>Zabbix3.4 安装</h2><ul><li><p>安装zabbix的Repo</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -i http://repo.zabbix.com/zabbix/3.4/rhel/7/x86_64/zabbix-release-3.4-2.el7.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p>安装zabbix的服务端、界面端、监控端<br>yum install zabbix-server-mysql zabbix-web-mysql zabbix-agent </p></li><li><p>创建zabbix数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create database zabbix character set utf8 collate utf8_bin; </span><br><span class="line">mysql&gt; grant all on zabbix.* to zabbix@&apos;localhost&apos; identified by &apos;zabbix&apos;; </span><br><span class="line">mysql&gt; flush privileges; </span><br><span class="line">mysql&gt; \q 　　　　//退出</span><br></pre></td></tr></table></figure></li><li><p>导入表结构和数据<br>~]# zcat /usr/share/doc/zabbix-server-mysql-3.4.6/create.sql.gz |mysql -uzabbix -p zabbix </p></li></ul><h2 id="配置修改"><a href="#配置修改" class="headerlink" title="配置修改"></a>配置修改</h2><ul><li><p>zabbix server配置数据库信息<br>~]# vim /etc/zabbix/zabbix_server.conf<br>开启或修改以下关键字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DBHost=localhost</span><br><span class="line">DBName=zabbix</span><br><span class="line">DBUser=zabbix</span><br><span class="line">DBPassword=zabbix　　　　//根据自己定义的信息修改</span><br></pre></td></tr></table></figure></li><li><p>修改zabbix前端配置中的时区信息<br>~]# vim /etc/httpd/conf.d/zabbix.conf </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_php5.c&gt;</span><br><span class="line">    php_value max_execution_time 300</span><br><span class="line">    php_value memory_limit 128M</span><br><span class="line">    php_value post_max_size 16M</span><br><span class="line">    php_value upload_max_filesize 2M</span><br><span class="line">    php_value max_input_time 300</span><br><span class="line">    php_value max_input_vars 10000</span><br><span class="line">    php_value always_populate_raw_post_data -1</span><br><span class="line">    # php_value date.timezone Europe/Riga</span><br><span class="line">    php_value date.timezone Asia/Shanghai</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure></li><li><p>启动服务<br>~]# systemctl start httpd<br>~]# systemctl start zabbix-server<br>~]# systemctl start zabbix-agent </p></li></ul><h2 id="配置web界面"><a href="#配置web界面" class="headerlink" title="配置web界面"></a>配置web界面</h2><p>先访问<a href="http://SERVER_IP/zabbix" target="_blank" rel="noopener">http://SERVER_IP/zabbix</a> ，跳出如下：<br><img src="https://s2.ax1x.com/2019/05/27/VZxwTg.md.png" alt="VZxwTg.md.png"></p>]]></content>
    
    <summary type="html">
    
      「Zabbix」
    
    </summary>
    
      <category term="监控" scheme="http://yoursite.com/categories/%E7%9B%91%E6%8E%A7/"/>
    
    
      <category term="Zabbix" scheme="http://yoursite.com/tags/Zabbix/"/>
    
  </entry>
  
  <entry>
    <title>基于Hexo+Github+Coding搭建个人博客——基础篇(从菜鸟到放弃)</title>
    <link href="http://yoursite.com/2018/09/25/Hexo/01.hexo/"/>
    <id>http://yoursite.com/2018/09/25/Hexo/01.hexo/</id>
    <published>2018-09-25T10:11:07.000Z</published>
    <updated>2019-05-28T03:09:10.433Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s2.ax1x.com/2019/05/28/Ve3TXt.md.png" alt="Ve3TXt.md.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li><p>Hexo博客搭建的基础大致流程为:<br>安装Node.js →安装Git → 安装Hexo → 安装主题 → 本地测试运行 → 注册给github与coding并创建pages仓库 → 部署</p></li><li><p>对于使用windows的童鞋, 可参考文章末尾处的参考链接, 步骤大同小异<br>以下提到的站点配置文件指的是博客文件根目录下的 _config.yml, 主题配置文件是主题文件夹下的 _config.yml, 童鞋们不要混淆了</p></li></ul><h2 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h2><p>Node.js的安装有很多种方式, Hexo的官方文档 建议是用nvm 安装, 但好多人都说不行, 所以找了另外两种方式安装<br>windows的童鞋可参考安装Node.js</p><ul><li><p>方法一: 二进制包直接解压配置<br>在node.js的官网 下载二进制包来安装的, 下载过后, 解压, 设置软链接, 要不然每次都执行命令都要加上路径, 好麻烦<br>cp /home/ybd/Data/soft/application/node-v6.2.0-linux-x64/bin/node /usr/local/bin/node<br>cp /home/ybd/Data/soft/application/node-v6.2.0-linux-x64/bin/npm /usr/local/bin/npm<br>检查：<br>node -v<br>npm -v</p></li><li><p>方法二: 换源下载<br>安装 8.x 版本:<br>curl -sL <a href="https://rpm.nodesource.com/setup_8.x" target="_blank" rel="noopener">https://rpm.nodesource.com/setup_8.x</a> | sudo -E bash -<br>sudo yum install -y nodejs<br>npm 更换淘宝镜像:<br>npm config set registry <a href="https://registry.npm.taobao.org/" target="_blank" rel="noopener">https://registry.npm.taobao.org/</a></p></li><li><p>方法三: 源文件编译安装<br>在安装前, 首先需要配置安g++编译器<br>sudo yum install build-essential<br>去官网 下载源代码, 选择最后一项, Source Code<br>解压到某一目录, 然后进入此目录,依次执行以下3条命令<br>./configure<br>make<br>sudo make install<br>执行以下命令, 检测是否已经装好node.js<br>node -v</p></li><li><p>npm安装, 一条命令即可解决<br>curl <a href="http://npmjs.org/install.sh" target="_blank" rel="noopener">http://npmjs.org/install.sh</a> | sudo sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_2_centos ]# node -v</span><br><span class="line">v10.15.3</span><br><span class="line">[root@VM_0_2_centos ]# npm -v</span><br><span class="line">6.4.1</span><br></pre></td></tr></table></figure></li></ul><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><ul><li>linux系统下安装Git非常简单, 只需一条命令:<br>sudo yum install git<br>windows下就直接到Git官网 下载安装即可<br>然后终端执行 git –version 查看是否安装成功<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git version 1.8.3.1</span><br></pre></td></tr></table></figure></li></ul><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架. Hexo 使用 Markdown（或其他渲染引擎）解析文章, 在几秒内, 即可利用靓丽的主题生成静态网页.</p><p>所有以上必备的应用程序安装完成后, 无论是在哪个操作系统, 之后的操作都一样<br>安装Hexo的非常简单, 只要一条命令, 前提是安装好Node.js与Git</p><ul><li>npm install -g hexo-cli</li></ul><h2 id="本地启动Hexo"><a href="#本地启动Hexo" class="headerlink" title="本地启动Hexo"></a>本地启动Hexo</h2><ul><li><p>初始化<br>随便建一个文件夹, 名字随便取, 博主取其名为hexo, cd 到文件夹里, 先安装必要的文件, 执行以下命令:<br>hexo init  # hexo会在目标文件夹建立网站所需要的所有文件<br>npm install  # 安装依赖包</p></li><li><p>本地启动<br>有了必要的各种配置文件之后就可以在本地预览效果了<br>hexo g # 等同于hexo generate, 生成静态文件<br>hexo s # 等同于hexo server, 在本地服务器运行<br>之后打开浏览器并输入IP地址 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 查看, 效果如下:<br><img src="https://s2.ax1x.com/2019/05/28/VeJlfe.md.png" alt="VeJlfe.md.png"></p></li></ul><h2 id="安装主题（以NexT为例）"><a href="#安装主题（以NexT为例）" class="headerlink" title="安装主题（以NexT为例）"></a>安装主题（以NexT为例）</h2><ul><li><p>复制主题<br>Hexo 安装主题的方式非常简单, 只需要将主题文件拷贝至站点目录的 themes 目录下, 然后修改下配置文件即可<br>cd your-hexo-site<br>git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next</p></li><li><p>启用主题<br>打开站点配置文件_config.yml, 找到 theme 字段, 并将其值更改为 next<br>theme: next<br>然后 hexo s 即可预览主题效果</p></li><li><p>更换主题外观<br>博主用的是 Muse, 直接更改主题配置文件./next/_config.yml的 scheme 参数即可:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Schemes</span><br><span class="line">#scheme: Muse  #这是 Nex默认版本，黑白主调，大量留白</span><br><span class="line">#scheme: Mist  #Muse 的紧凑版本，整洁有序的单栏外观</span><br><span class="line">#scheme: Pisces #双栏 Scheme，小家碧玉似的清新</span><br><span class="line">scheme: Gemini  #双子座，也是双栏形式，和Pisces类似</span><br></pre></td></tr></table></figure></li></ul><p>再次执行 hexo clean 和 heox s 可预览效果<br>大部分的设定都能在NexT的官方文档 里面找到, 如侧栏、头像、打赏、评论等等, 在此就不多讲了, 照着文档走就行了, 接下只是个性定制的问题</p><h1 id="Github、Coding"><a href="#Github、Coding" class="headerlink" title="Github、Coding"></a>Github、Coding</h1><h2 id="注册Github和Coding并分别创建Pages"><a href="#注册Github和Coding并分别创建Pages" class="headerlink" title="注册Github和Coding并分别创建Pages"></a>注册Github和Coding并分别创建Pages</h2><p>在本地运行没有问题的话, 那么可以部署到外网去, 在此之前, 先得有服务器让你的项目可以托管, 那么Github Page与Coding Page就是个很好的东西, 它们可以让我们访问静态文件, 而Hexo生成的恰恰是静态文件</p><p>那为什么要注册两个网站呢？因为Github是国外的服务器, 访问速度比较慢, 而Coding是国内的, 速度相对来说比较快, 在后面DNS解析的时候可以把国内的解析到Coding, 国外的解析到Github, 相当的完美</p><h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><ul><li><p>注册Github帐号<br>进入Github 首页进行注册, 用户名、邮箱和密码之后都需要用到, 自己记好, 不知道怎么注册的童鞋去问问度娘</p></li><li><p>创建Repository(Github Pages)<br>Repository相当于一个仓库, 用来放置你的代码文件. 首先, 登陆进入Github, 选择首页中的 New repository 按钮<br><img src="https://s2.ax1x.com/2019/05/28/Vet3qI.md.png" alt="Vet3qI.md.png"><br>创建时, 只需要填写Repository name即可, 可以顺便创建README文件, 就是红色那个钩, 当然这个名字的格式必须为{user_name}.github.io, 其中{user_name}必须与你的用户名一样, 这是github pages的特殊命名规范<br>![VetYIf.md.png](<a href="https://s2.ax1x.com/2019/05/28/VetYIf.md.png" target="_blank" rel="noopener">https://s2.ax1x.com/2019/05/28/VetYIf.md.png</a></p></li></ul><h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><ul><li><p>注册Coding帐号<br>国内的网站, 绝大部分都是中文的, 注册什么的就不说了,进入Coding 滚键盘就是了= =</p></li><li><p>创建项目(Coding Pages)<br>Coding Pages请看 Coding Pages<br>注册之后进入主页, 点击项目, 点击+, 项目名为你的用户名<br><img src="https://s2.ax1x.com/2019/05/28/Ve0gF1.md.png" alt="Ve0gF1.md.png"></p></li></ul><p>查看Pages 服务是否开启: 点击项目 -&gt; 代码 -&gt; Pages 服务, 若没有开启则点开启<br><img src="https://s2.ax1x.com/2019/05/28/Ve0v6S.md.png" alt="Ve0v6S.md.png"></p><h2 id="配置SSH与Git"><a href="#配置SSH与Git" class="headerlink" title="配置SSH与Git"></a>配置SSH与Git</h2><p>那么我们有了两个免费的服务器之后, 就要绑定个人电脑与它们联系, 那就是SSH与Git<br>绑定之后我们每次部署项目就不用输入帐号和密码</p><ul><li><p>生成SSH Key<br>ssh-keygen -t rsa -C <a href="mailto:your_email@youremail.com" target="_blank" rel="noopener">your_email@youremail.com</a><br>后面的 <a href="mailto:your_email@youremail.com" target="_blank" rel="noopener">your_email@youremail.com</a> 改为你的邮箱, 之后会要求确认路径和输入密码, 我们这使用默认的一路回车就行. 成功的话会在~/下生成 .ssh 文件夹, 进去, 打开 id_rsa.pub, 复制里面的key</p></li><li><p>添加SSH Key<br>首先是Github, 登录Github, 右上角 头像 -&gt; Settings —&gt; SSH nd GPG keys —&gt; New SSH key . 把公钥粘贴到key中, 填好title并点击 Add SSH key<br>至于Coding, 登录进入主页, 点击 账户 —&gt; SSH公钥 —&gt; 输入key再点击 添加</p></li><li><p>验证成功与否<br>验证github:<br>ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a><br>如果是第一次的会提示是否continue, 输入yes就会看到: You’ve successfully authenticated, but GitHub does not provide shell access . 这就表示已成功连上github!之前博主就是因为没有输入yes, 导致几次失败, 粗心地一路回车= =<br>验证coding:<br>ssh -T <a href="mailto:git@git.coding.net" target="_blank" rel="noopener">git@git.coding.net</a><br>同上, 按yes</p></li><li><p>设置username和email<br>因为github每次commit都会记录他们<br>git config –global user.name your name<br>git config –global user.email <a href="mailto:your_email@youremail.com" target="_blank" rel="noopener">your_email@youremail.com</a></p></li></ul><h2 id="部署到Github与Coding"><a href="#部署到Github与Coding" class="headerlink" title="部署到Github与Coding"></a>部署到Github与Coding</h2><ul><li><p>先安装Git部署插件<br>npm install hexo-deployer-git –save</p></li><li><p>打开站点配置文件, 修改部署配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">#git@git.dev.tencent.com:AIRPAN/AIRPAN.coding.me.git</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo:</span><br><span class="line">    github: git@github.com:airpan/airpan.github.io.git</span><br><span class="line">    coding: git@git.coding.me:airpan/airpan.coding.me.git</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure></li></ul><p>注意冒号后面是网站对应的用户名, 接着就是/, 然后再是你的项目名加上 .git<br>保存后终端执行<br>hexo clean<br>hexo g<br>hexo d</p>]]></content>
    
    <summary type="html">
    
      「Hexo」「Github」「Coding」
    
    </summary>
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
